{"Nim 游戏(简单)":"---\r\ntitle: Nim 游戏(简单)\r\ndate: 2020-03-22 12:14:10\r\n---\r\n## 题目描述\r\n\r\n你和你的朋友，两个人一起玩 ``Nim`` 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。\r\n\r\n你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。\r\n\r\n**示例:**\r\n\r\n```\r\n输入: 4\r\n输出: false \r\n解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；\r\n    因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。\r\n```\r\n\r\n## 解题思路\r\n\r\n这题想复杂了，就会真的很复杂。但是只要发现了这道题目的本质，就非常的简单...简单到不可思议，所以记录一下\r\n\r\n由于每个人每次最多能拿 **3** 块石头，所以最后当面前的石头数量低于 **3** 时，你可以拿走全部的石头，你就赢了。\r\n\r\n当石头数量为 **4** 时，无论你怎么操作，最后总会给对手留下可以拿完的石头。但是如果为 **5块**、**6块**、**7块**时，你总是可以想办法留下让对手无法一次拿完的石头，这样你是可以赢的。  \r\n所以只要避免轮到你时，还剩下4块石头即可。同理，**8块**、**12块**也是一样的，也就是说，石头数量不能为4的倍数。\r\n\r\n\r\n## 答案\r\n\r\n\r\n```\r\n    fun canWinNim(n: Int): Boolean {\r\n        return (n % 4 != 0);\r\n    }\r\n```\r\n","Pow(x,n)  (中等)":"---\r\ntitle: Pow(x,n)  (中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n实现 ``pow(x, n)`` ，即计算 x 的 n 次幂函数。\r\n\r\n**示例 1:**\r\n\r\n\r\n```\r\n输入: 2.00000, 10\r\n输出: 1024.00000\r\n```\r\n\r\n**示例 2:**\r\n\r\n\r\n```\r\n输入: 2.10000, 3\r\n输出: 9.26100\r\n```\r\n\r\n**示例 3:**\r\n\r\n\r\n```\r\n输入: 2.00000, -2\r\n输出: 0.25000\r\n解释: 2-2 = 1/22 = 1/4 = 0.25\r\n```\r\n\r\n**说明:**\r\n\r\n- -100.0 < ``x`` < 100.0\r\n- ``n`` 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1]。\r\n\r\n\r\n## 解题思路\r\n\r\n最简单粗暴的办法去计算x的n次方，就是将x循环乘以n次。但是显而易见，这样当n非常大的时候计算次数会非常多。\r\n\r\n换一个思路，如果我们用折半的方法去缩小循环的次数呢？\r\n\r\n## 答案\r\n\r\n\r\n```\r\n    fun myPow(x: Double, n: Int): Double {\r\n        var result = 1.0\r\n        var num = x\r\n        var i = n\r\n        while (i != 0) {\r\n            if (i % 2 != 0) {\r\n                result *= num\r\n            }\r\n            num *= num\r\n            i /= 2\r\n        }\r\n        return if (n < 0) 1 / result else result\r\n    }\r\n```\r\n","Z字型变换(中等)":"---\r\ntitle: Z字型变换(中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n将一个给定字符串根据给定的行数，以从上往下、从左到右进行Z 字形排列。\r\n\r\n比如输入字符串为 ``\"LEETCODEISHIRING\"`` 行数为 3 时，排列如下：\r\n\r\n\r\n```\r\nL   C   I   R\r\nE T O E S I I G\r\nE   D   H   N\r\n```\r\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：``\"LCIRETOESIIGEDHN\"``。\r\n\r\n请你实现这个将字符串进行指定行数变换的函数：\r\n\r\n\r\n```\r\nstring convert(string s, int numRows);\r\n```\r\n\r\n\r\n**示例1:**\r\n\r\n\r\n```\r\n输入: s = \"LEETCODEISHIRING\", numRows = 3\r\n输出: \"LCIRETOESIIGEDHN\"\r\n```\r\n\r\n\r\n**示例2:**\r\n\r\n\r\n```\r\n输入: s = \"LEETCODEISHIRING\", numRows = 4\r\n输出: \"LDREOEIIECIHNTSG\"\r\n解释:\r\n\r\nL     D     R\r\nE   O E   I I\r\nE C   I H   N\r\nT     S     G\r\n```\r\n\r\n\r\n## 解题思路\r\n\r\n说实话，这题没有什么特别的解体思路。因为思路上来说解决这道题目很简单。\r\n\r\n那为什么我要将这题记录下来呢？\r\n\r\n主要做完题目后对比答案，被答案的解法给惊艳到了。这种感觉于我而言就像直接吃掉第六个烧饼，然后肚子就饱了。\r\n\r\n答案的解法可读性也不强，但是这种恰到好处的代码甚至让我怀疑出题者是先想到答案，再想到题目的。\r\n\r\n## 答案\r\n\r\n\r\n```\r\nclass Solution {\r\n    public String convert(String s, int numRows) {\r\n\r\n        if (numRows == 1) return s;\r\n\r\n        List<StringBuilder> rows = new ArrayList<>();\r\n        for (int i = 0; i < Math.min(numRows, s.length()); i++)\r\n            rows.add(new StringBuilder());\r\n\r\n        int curRow = 0;\r\n        boolean goingDown = false;\r\n\r\n        for (char c : s.toCharArray()) {\r\n            rows.get(curRow).append(c);\r\n            if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;\r\n            curRow += goingDown ? 1 : -1;\r\n        }\r\n\r\n        StringBuilder ret = new StringBuilder();\r\n        for (StringBuilder row : rows) ret.append(row);\r\n        return ret.toString();\r\n    }\r\n}\r\n\r\n```\r\n","三数之和(中等)":"---\r\ntitle: 三数之和(中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定一个包含 n 个整数的数组 ``nums``，判断 ``nums`` 中是否存在三个元素 *a，b，c* ，使得 *a + b + c = 0* ？找出所有满足条件且不重复的三元组。\r\n\r\n**注意**：答案中不可以包含重复的三元组。\r\n\r\n\r\n```\r\n例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，\r\n\r\n满足要求的三元组集合为：\r\n[\r\n  [-1, 0, 1],\r\n  [-1, -1, 2]\r\n]\r\n```\r\n\r\n\r\n## 解题思路\r\n\r\n#### 排序+双指针\r\n\r\n解决此题的思路的要点就是如何避免重复选择。所以需要用到排序，而双指针则可以加快选择\r\n\r\n## 答案\r\n\r\n\r\n```\r\nclass Solution {\r\n    fun threeSum(nums: IntArray): List<List<Int>> {\r\n        nums.sort()\r\n        val resultList = mutableListOf<List<Int>>()\r\n        for (i in 0 until nums.size - 2) {\r\n            if(nums[i] > 0) break\r\n            var left = i+1\r\n            var right = nums.size - 1\r\n            while (left < right){\r\n                val lv = nums[left]\r\n                val rv = nums[right]\r\n                val mv = nums[i]\r\n                val sum = lv + rv + mv\r\n                when {\r\n                    sum == 0 -> {\r\n                        val list = listOf(lv,mv,rv)\r\n                        if(!resultList.contains(list)) resultList.add(list)\r\n                        left++\r\n                        right--\r\n                    }\r\n                    sum < 0 -> left++\r\n                    else -> right--\r\n                }\r\n            }\r\n        }\r\n        return resultList\r\n    }\r\n}\r\n```\r\n\r\n\r\n","不同路径 II(中等)":"---\r\ntitle: 不同路径 II(中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n一个机器人位于一个 *m x n* 网格的左上角 （起始点在下图中标记为“Start” ）。\r\n\r\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\r\n\r\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\r\n\r\n![image](https://user-images.githubusercontent.com/30992818/72131874-76e5eb80-33b8-11ea-8cb9-a6cc28b18d9a.png)\r\n\r\n网格中的障碍物和空位置分别用 1 和 0 来表示。\r\n\r\n**说明**：m 和 n 的值均不超过 100。\r\n\r\n**示例 1:**\r\n\r\n\r\n```\r\n输入:\r\n[\r\n  [0,0,0],\r\n  [0,1,0],\r\n  [0,0,0]\r\n]\r\n输出: 2\r\n解释:\r\n3x3 网格的正中间有一个障碍物。\r\n从左上角到右下角一共有 2 条不同的路径：\r\n1. 向右 -> 向右 -> 向下 -> 向下\r\n2. 向下 -> 向下 -> 向右 -> 向右\r\n```\r\n\r\n\r\n## 解题思路\r\n\r\n这题相较于它的上一个版本来说，多了 **障碍物** 的设置。\r\n\r\n如果某个格子上有障碍物，那么我们不考虑包含这个格子的任何路径。也就是说**这个格子提供的路径值为0**。而没有障碍物的格子，提供的路径值为1。\r\n\r\n接下来我们还是将上边界和左边界全部设置为1(这里的1和用于表示障碍物的1，虽然数值一样，但是概念不同)，不过这里需要注意几点：\r\n- 如果第一个点就存在障碍物，那后面的点就都为0了\r\n- 如果第一个点没有障碍物，将第一个点的值由0设置为1，表示提供一个路径值\r\n- 遍历第一行，如果存在障碍物，将改点的数值由1设置为0，表示不提供路径值\r\n- 遍历第一列，与上面一样\r\n- 从第[1][1]点开始进行遍历，如果发现某个点有障碍物，将其值由1设为0，否则该点的值为左边的点和上边的点的值相加\r\n\r\n\r\n根据以上几点，我们就可以使用**动态规划**来解决问题了\r\n\r\n\r\n## 答案\r\n\r\n\r\n```\r\n    fun uniquePathsWithObstacles(obstacleGrid: Array<IntArray>): Int {\r\n        val column = obstacleGrid.size\r\n        val row = obstacleGrid[0].size\r\n        if(obstacleGrid[0][0] == 1) return 0\r\n        obstacleGrid[0][0] = 1\r\n        for (i in 1 until column) {\r\n            obstacleGrid[i][0] = if(obstacleGrid[i-1][0] == 1 && obstacleGrid[i][0] == 0) 1 else 0\r\n        }\r\n        for(i in 1 until row){\r\n            obstacleGrid[0][i] = if(obstacleGrid[0][i-1] == 1 && obstacleGrid[0][i] == 0) 1 else 0\r\n        }\r\n        for(i in 1 until column){\r\n            for(j in 1 until row){\r\n                if(obstacleGrid[i][j] == 1){\r\n                    obstacleGrid[i][j] = 0\r\n                } else {\r\n                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]\r\n                }\r\n            }\r\n        }\r\n        return obstacleGrid[column-1][row-1]\r\n    }\r\n```\r\n","不同路径(中等)":"---\r\ntitle: 不同路径(中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n一个机器人位于一个 *m x n* 网格的左上角 （起始点在下图中标记为“Start” ）。\r\n\r\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\r\n\r\n问总共有多少条不同的路径？\r\n\r\n\r\n![image](https://user-images.githubusercontent.com/30992818/72131874-76e5eb80-33b8-11ea-8cb9-a6cc28b18d9a.png)\r\n\r\n\r\n例如，上图是一个7 x 3 的网格。有多少可能的路径？\r\n\r\n**说明**：m 和 n 的值均不超过 100。\r\n\r\n**示例 1:**\r\n\r\n\r\n```\r\n输入: m = 3, n = 2\r\n输出: 3\r\n解释:\r\n从左上角开始，总共有 3 条路径可以到达右下角。\r\n1. 向右 -> 向右 -> 向下\r\n2. 向右 -> 向下 -> 向右\r\n3. 向下 -> 向右 -> 向右\r\n```\r\n\r\n**示例 2:**\r\n\r\n\r\n```\r\n输入: m = 7, n = 3\r\n输出: 28\r\n```\r\n\r\n## 解题思路\r\n\r\n这题涉及到 **动态规划** 的概念。\r\n\r\n由于机器人只能 **向右** 或者 **向下** 移动，如果我们以dp[i][j]表示机器人到达第i行第j列的路径数和。那么可以很容易得到：\r\n\r\n    dp[i][j] = dp[i-1][j] + dp[i][j-1]\r\n\r\n> 对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1\r\n\r\n![image](https://user-images.githubusercontent.com/30992818/72132900-14dab580-33bb-11ea-98af-a091211702af.png)\r\n\r\n![image](https://user-images.githubusercontent.com/30992818/72132916-1e641d80-33bb-11ea-830d-70a5d075890e.png)\r\n\r\n根据上面的式子，就可以求出所有路径\r\n\r\n(本题也可以根据排列组合来求解，不过太简单了，这里就不说了)\r\n\r\n## 答案\r\n\r\n\r\n```\r\n    fun uniquePaths(m: Int, n: Int): Int {\r\n        val dp = Array(n){IntArray(m)}\r\n        for (i in 0 until m) {\r\n            dp[0][i] = 1\r\n        }\r\n        for(i in 0 until n){\r\n            dp[i][0] = 1\r\n        }\r\n        for(i in 1 until n){\r\n            for(j in 1 until m){\r\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\r\n            }\r\n        }\r\n        return dp[n-1][m-1]\r\n    }\r\n```\r\n\r\n**优化版：**\r\n\r\n```\r\n    fun uniquePaths(m: Int, n: Int): Int {\r\n        val memo = IntArray(n){i -> 1}\r\n        for (i in 1 until m) {\r\n            for (j in 1 until n) {\r\n                memo[j] += memo[j - 1]\r\n            }\r\n        }\r\n        return memo[n - 1]\r\n    }\r\n```\r\n","两数之和 II - 输入有序数组(简单)":"---\r\ntitle: 两数之和 II - 输入有序数组(简单)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定一个已按照 ***升序排列*** 的有序数组，找到两个数使得它们相加之和等于目标数。\r\n\r\n函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。\r\n\r\n**说明:**\r\n- 返回的下标值（index1 和 index2）不是从零开始的。\r\n- 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素\r\n\r\n**示例:**\r\n\r\n\r\n```\r\n输入: numbers = [2, 7, 11, 15], target = 9\r\n输出: [1,2]\r\n解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。\r\n```\r\n\r\n\r\n## 解题思路\r\n\r\n#### 思路一\r\n\r\n常规思路，直接两个for循环，找到为止。\r\n\r\n\r\n#### 思路二\r\n\r\n根据本题的题干，输入的数组是一个 **升序数组** 所以我们完全可以同时进行首位一起查找\r\n\r\n\r\n## 答案\r\n\r\n#### 常规解法\r\n\r\n\r\n```\r\n    fun twoSum(numbers: IntArray, target: Int): IntArray {\r\n        for (i in 0 until  numbers.size - 1){\r\n            for (j in i+1 until numbers.size){\r\n                if(numbers[i] + numbers[j] == target){\r\n                    return intArrayOf(i+1,j+1)\r\n                }\r\n            }\r\n        }\r\n        return intArrayOf()\r\n    }\r\n```\r\n\r\n\r\n#### 双指针解法\r\n\r\n\r\n```\r\n    fun twoSum(numbers: IntArray, target: Int): IntArray {\r\n        var left = 0\r\n        var right = numbers.size-1\r\n        while (left < right){\r\n            val sum = numbers[left] + numbers[right];\r\n            if(sum == target){\r\n                return intArrayOf(left+1,right+1)\r\n            } else if(sum < target){\r\n                left++\r\n            } else{\r\n                right--\r\n            }\r\n        }\r\n        return intArrayOf()\r\n    }\r\n```\r\n","两数相除(中等)":"---\r\ntitle: 两数相除(中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定两个整数，被除数``dividend``和除数``divisor``。将两数相除，要求不使用乘法、除法和 mod 运算符。\r\n\r\n返回被除数``dividend``除以除数``divisor``得到的商。\r\n \r\n**示例 1:**\r\n\r\n\r\n```\r\n输入: dividend = 10, divisor = 3\r\n输出: 3\r\n```\r\n\r\n**示例 2:**\r\n\r\n\r\n```\r\n输入: dividend = 7, divisor = -3\r\n输出: -2\r\n```\r\n\r\n**说明:**\r\n\r\n- 被除数和除数均为 32 位有符号整数。\r\n- 除数不为 0。\r\n- 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。\r\n\r\n\r\n## 解题思路\r\n\r\n由于不能使用乘法与除法之类的操作。\r\n\r\n最简单的办法就是循环使用被除数减去除数，直到被除数小于除数为止。\r\n\r\n但是很明显，这样的方法耗时过多。所以并不推荐这种办法\r\n\r\n看一下除法的公式：\r\n\r\n```\r\na = mb + n\r\n\r\n其中 a 为被除数，b 为除数，m 为商，n 为余数\r\n```\r\n我们可以把公式转换一下：\r\n\r\n\r\n```\r\na - (m-1)b = b + n\r\n```\r\n这样看其实只要把 ``除数b`` 一直翻倍，直到再翻一倍就比 ``被除数a`` 大,这时候通过后者与前者的 ``差值`` ，再去求商即可。\r\n\r\n那么如何在不使用乘法的情况下对除数翻倍呢？答案就是移位！\r\n\r\n## 答案\r\n\r\n\r\n```\r\nclass Solution {\r\n    fun divide(dividend: Int, divisor: Int): Int {\r\n        var dividendNum = dividend\r\n        var divisorNum = divisor\r\n        val sign = (dividendNum > 0) xor (divisorNum > 0)\r\n        var result = 0\r\n        if (dividendNum > 0) {\r\n            dividendNum = -dividendNum\r\n        }\r\n        if (divisorNum > 0) divisorNum = -divisorNum\r\n        while (dividendNum <= divisorNum) {\r\n            var tempResult = -1\r\n            var tempDivisor = divisorNum\r\n            while (dividendNum <= tempDivisor shl 1) {\r\n                if (tempDivisor <= Integer.MIN_VALUE shr 1) break\r\n                tempResult = tempResult shl 1\r\n                tempDivisor = tempDivisor shl 1\r\n            }\r\n            dividendNum -= tempDivisor\r\n            result += tempResult\r\n        }\r\n        if (!sign) {\r\n            if (result <= Integer.MIN_VALUE) return Integer.MAX_VALUE\r\n            result = -result\r\n        }\r\n        return result\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n","两整数之和(简单)":"## 题目描述\n\n**不使用**运算符`` + ``和 ``-`` ，计算两整数 ``a`` 、``b`` 之和。\n\n**示例 1:**\n\n\n```\n输入: a = 1, b = 2\n输出: 3\n```\n\n**示例 2:**\n\n\n```\n输入: a = -2, b = 3\n输出: 1\n```\n\n## 解题思路\n\nleecode中有写的比较好的解题说明，所以这里直接拿来主义了\n\n因为不能使用 **+** 和 **-** 符号，那么我们就要使用其他方式来替代这两个运算符的功能\n\n#### 位运算中的加法\n位运算中，加法结果如下\n\n```\n0 + 0 = 0\n0 + 1 = 1\n1 + 0 = 1\n1 + 1 = 0（进位 1）\n```\n可以看出，这就是 **异或** 运算的结果：相同为0，不同为1\n\n#### 异或和与运算操作\n\n在位运算操作中，**异或**的一个重要特性是**无进位加法**。我们来看一个例子：\n\n```\na = 5 = 0101\nb = 4 = 0100\n\na ^ b 如下：\n\n0 1 0 1\n0 1 0 0\n-------\n0 0 0 1\n```\n``a ^ b`` 得到了一个无进位加法结果，如果要得到 ``a + b `` 的最终值，我们还要找到进位的数，把这二者相加。在位运算中，我们可以使用与操作获得进位\n\n```\na = 5 = 0101\nb = 4 = 0100\n\na & b 如下：\n\n0 1 0 1\n0 1 0 0\n-------\n0 1 0 0\n```\n由计算结果可见，``0100`` 并不是我们想要的进位，``1 + 1`` 所获得的进位应该要放置在它的更高位，即左侧位上，因此我们还要把 ``0100`` 左移一位，才是我们所要的进位结果。\n \n - ``a + b`` 的问题拆分为 ``(a 和 b 的无进位结果) + (a 和 b 的进位结果)``\n- 无进位加法使用**异或运算**计算得出\n- 进位结果使用与**运算**和**移位运算**计算得出\n- 循环此过程，直到进位为 0\n \n\n## 答案\n\n\n```\n    fun getSum(a: Int, b: Int): Int {\n        return if(b == 0) a else getSum(a xor b, (a and b) shl 1)\n    }\n```\n","二叉树的最小深度(简单)":"---\r\ntitle: 二叉树的最小深度(简单)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定一个二叉树，找出其最小深度。\r\n\r\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\r\n\r\n说明: 叶子节点是指没有子节点的节点。\r\n\r\n**示例:**\r\n\r\n给定二叉树 ``[3,9,20,null,null,15,7]``,\r\n\r\n```\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n```\r\n返回它的最小深度  2.\r\n\r\n## 解题思路\r\n\r\n参考一下“平衡二叉树（简单）”的解法，自然就知道如何解题了。\r\n\r\n通过递归，只返回节点左右子树中高度最小的数值即可\r\n\r\n## 答案\r\n\r\n\r\n```\r\n/**\r\n * Example:\r\n * var ti = TreeNode(5)\r\n * var v = ti.`val`\r\n * Definition for a binary tree node.\r\n * class TreeNode(var `val`: Int) {\r\n *     var left: TreeNode? = null\r\n *     var right: TreeNode? = null\r\n * }\r\n */\r\nimport kotlin.math.min\r\nimport kotlin.math.max\r\n\r\nclass Solution {\r\n    fun minDepth(root: TreeNode?): Int {\r\n        if(root == null) return 0\r\n        val left = minDepth(root.left)\r\n        val right = minDepth(root.right)\r\n        if(left == 0 || right == 0) return max(left,right) + 1\r\n        return min(left,right) + 1\r\n    }\r\n}\r\n```\r\n","全排列 II(中等)":"---\r\ntitle: 全排列 II(中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定一个可包含重复数字的序列，返回所有不重复的全排列。\r\n\r\n**示例:**\r\n\r\n\r\n```\r\n输入: [1,1,2]\r\n输出:\r\n[\r\n  [1,1,2],\r\n  [1,2,1],\r\n  [2,1,1]\r\n]\r\n```\r\n\r\n\r\n## 解题思路\r\n\r\n这题是 [全排列](https://leetcode-cn.com/problems/permutations/) 的进阶版，具体的改动就是，由不包含重复的输入序列变成了可包含重复的数字序列。\r\n\r\n显然，出了需要使用回溯外，还需要进行剪枝才行。这题的难点就是如何去写剪枝的逻辑了。\r\n\r\n先看看不减枝的常规解法：\r\n\r\n#### 一般思路：\r\n\r\n通过Set的特性，来完成去重操作，不过这样耗时会高很多。\r\n\r\n#### 优化思路：\r\n\r\nleecode上面有非常好的思路，下面将其放上：\r\n\r\n\r\n<img width=\"500\" alt=\"WeChatcf0b8272848f0486837568e93d4607e7\" src=\"https://user-images.githubusercontent.com/30992818/71465127-aa404c00-27f6-11ea-9979-43c572364b7a.png\">\r\n\r\n\r\n<img width=\"500\" alt=\"https://user-images.githubusercontent.com/30992818/71465153-c04e0c80-27f6-11ea-9427-acd5d30f7460.png\">\r\n\r\n<img width=\"500\" alt=\"https://user-images.githubusercontent.com/30992818/71465188-dbb91780-27f6-11ea-9b8d-7e4003484fed.png\">\r\n\r\n<img width=\"500\" alt=\"https://user-images.githubusercontent.com/30992818/71465247-ff7c5d80-27f6-11ea-9cee-c5dfb0d47f39.png\">\r\n\r\n\r\n\r\n## 答案\r\n\r\n#### 一般答案\r\n\r\n\r\n```\r\n    fun permute(nums: IntArray): List<List<Int>> {\r\n        val result = mutableListOf<List<Int>>()\r\n        for (i in nums.indices) {\r\n            val newNumbs = nums.toMutableList()\r\n            newNumbs.removeAt(i)\r\n            traceBackPermute(newNumbs, mutableListOf(nums[i]), result)\r\n        }\r\n        return result\r\n    }\r\n\r\n    private fun traceBackPermute(\r\n        numbs: List<Int>,\r\n        currentList: MutableList<Int>,\r\n        result: MutableList<List<Int>>\r\n    ) {\r\n        if (numbs.isEmpty()) {\r\n            val list = mutableListOf<Int>()\r\n            list.addAll(currentList)\r\n            if (!result.contains(list)) result.add(list)\r\n            return\r\n        }\r\n        for (i in numbs.indices) {\r\n            val newNumbs = numbs.toMutableList()\r\n            newNumbs.removeAt(i)\r\n            currentList.add(numbs[i])\r\n            traceBackPermute(newNumbs, currentList, result)\r\n            currentList.remove(currentList.last())\r\n        }\r\n    }\r\n```\r\n\r\n#### 优化答案\r\n\r\n\r\n```\r\n fun permuteUnique(nums: IntArray): List<List<Int>> {\r\n        val result = mutableListOf<List<Int>>()\r\n        nums.sort()\r\n        traceBackPermuteUnique(nums, MutableList(nums.size) {false},0, mutableListOf(),result)\r\n        return result.toList()\r\n    }\r\n\r\n    private fun traceBackPermuteUnique(nums: IntArray,\r\n                                        usedList: MutableList<Boolean>,\r\n                                        currentIndex: Int,\r\n                                        currentList: MutableList<Int>,\r\n                                        result: MutableList<List<Int>>){\r\n        if(currentIndex == nums.size) {\r\n            val list = mutableListOf<Int>()\r\n            list.addAll(currentList)\r\n            result.add(list)\r\n        }\r\n        for (i in nums.indices) {\r\n            if(usedList[i]) continue\r\n            // 与上一个数相等,并且上一个数使用过，则数据重复,不加入集合（数据相同，只出一个排列结果）\r\n            if (i > 0 && nums[i] == nums[i - 1] && usedList[i - 1]) continue\r\n            usedList[i] = true\r\n            currentList.add(nums[i])\r\n            traceBackPermuteUnique(nums,usedList, currentIndex+1,currentList,result)\r\n            currentList.removeAt(currentList.size - 1)\r\n            usedList[i] = false\r\n        }\r\n    }\r\n```\r\n","区域和检索 - 数组不可变(简单)":"---\r\ntitle: 区域和检索 - 数组不可变(简单)\r\ndate: 2020-03-03 10:10:46\r\n---\r\n## 题目描述\n\n给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。\n\n**示例：**\n\n\n```\n给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()\n\nsumRange(0, 2) -> 1\nsumRange(2, 5) -> -1\nsumRange(0, 5) -> -3\n```\n**说明:**\n\n    1.你可以假设数组不可变。\n    2.会多次调用 sumRange 方法。\n    \n\n## 解题思路\n\n根据题目中的说明，表示会多次调用 **sumRange** 方法，也就是说我们可能需要对计算的结果进行保留，避免每次调用都需要再计算一次\n\n所以这里有个很巧妙的解题方法，假如数组中有5个数字，那么可能会有 4+3+2+1 种 **sumRange** 的结果需要保存，显然这样是不够的。  \n我们可以将其优化为 **sumRange(i,j)** 的值实际上就是 **sumRange(0,j + 1) - sumRange(0, i)** 的值\n\n于是我们可以只需要存储从0到n的n个sumRange结果\n\n## 答案\n\n\n```\nclass NumArray(nums: IntArray) {\n        val sums = IntArray(nums.size + 1)\n\n        init {\n            for (i in nums.indices) sums[i+1] += (sums[i] + nums[i])\n        }\n\n        fun sumRange(i: Int, j: Int): Int {\n            if(i == 0) return sums[j+1]\n            return sums[j+1] - sums[i]\n        }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * var obj = NumArray(nums)\n * var param_1 = obj.sumRange(i,j)\n */\n```\n","只出现一次的数字(简单)":"---\r\ntitle: 只出现一次的数字(简单)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\r\n\r\n**说明：**\r\n\r\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\r\n\r\n**示例 1:**\r\n\r\n\r\n```\r\n输入: [2,2,1]\r\n输出: 1\r\n```\r\n\r\n**示例 2:**\r\n\r\n\r\n```\r\n输入: [4,1,2,1,2]\r\n输出: 4\r\n```\r\n\r\n## 解体思路\r\n\r\n#### 思路一：\r\n\r\n这是常规思路，数组放入Map中，其中key-value不一致的就是那个数字\r\n\r\n\r\n#### 思路二：\r\n\r\n这个才是需要重点说明的，巧妙的解题思路。\r\n\r\n根据“与或非”的特性。使用异或：相同为0，不同为1. 异或同一个数两次，原数不变。\r\n\r\n由此，就可以得出结果\r\n\r\n\r\n## 答案\r\n\r\n#### 常规解法：\r\n\r\n\r\n```\r\nclass Solution {\r\n    fun singleNumber(nums: IntArray): Int {\r\n        val map = mutableMapOf<String,String>()\r\n        for (num in nums) {\r\n            if (!map.keys.contains(num.toString())){\r\n                map[num.toString()] = \"\"\r\n            } else {\r\n                map[num.toString()] = num.toString()\r\n            }\r\n        }\r\n        for (mutableEntry in map) {\r\n            if(mutableEntry.value == \"\") return mutableEntry.key.toInt()\r\n        }\r\n        return 0\r\n    }\r\n}\r\n```\r\n\r\n\r\n#### 巧妙解法\r\n\r\n\r\n```\r\n    fun singleNumber(nums: IntArray): Int {\r\n        var result = 0\r\n        for (num in nums) {\r\n            result = result xor num\r\n        }\r\n        return result\r\n    }\r\n```\r\n","四数之和(中等)":"---\r\ntitle: 四数之和(中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定一个包含 *n* 个整数的数组 ``nums`` 和一个目标值 ``target``，判断 ``nums`` 中是否存在四个元素 *a，b，c* 和 *d* ，使得 *a + b + c + d* 的值与 ``target`` 相等？找出所有满足条件且不重复的四元组。\r\n\r\n**注意：**\r\n\r\n答案中不可以包含重复的四元组。\r\n\r\n**示例：**\r\n\r\n\r\n```\r\n给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。\r\n\r\n满足要求的四元组集合为：\r\n[\r\n  [-1,  0, 0, 1],\r\n  [-2, -1, 1, 2],\r\n  [-2,  0, 0, 2]\r\n]\r\n```\r\n\r\n\r\n## 解题思路\r\n\r\n可以参考 [三数之和](https://github.com/asjqkkkk/leecode-sample/blob/master/leecode-normal/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C(%E4%B8%AD%E7%AD%89).md) 的解法\r\n\r\n四数之和无非是在 **排序** 和 **双指针** 的前提下多加了一次for循环\r\n\r\n## 答案\r\n\r\n\r\n```\r\nclass Solution {\r\n    fun fourSum(nums: IntArray, target: Int): List<List<Int>> {\r\n        nums.sort()\r\n        if(nums.size < 4) return listOf()\r\n        if(nums.size == 4) return if(nums.sum() == target) listOf(nums.toList()) else listOf()\r\n        val resultList = mutableListOf<List<Int>>()\r\n        for (i in 0 until nums.size - 3) {\r\n            for(j in i+1 until nums.size - 2){\r\n                var mid = j + 1\r\n                var right = nums.size - 1\r\n                while (mid < right) {\r\n                    val mv = nums[mid]\r\n                    val rv = nums[right]\r\n                    val lv2 = nums[j]\r\n                    val lv = nums[i]\r\n                    val sum = lv + rv + mv + lv2\r\n                    when {\r\n                        sum == target -> {\r\n                            val list = listOf(lv, mv, rv,lv2)\r\n                            if (!resultList.contains(list)) resultList.add(list)\r\n                            mid++\r\n                            right--\r\n                        }\r\n                        sum < target -> mid++\r\n                        else -> right--\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n        return resultList\r\n    }\r\n}\r\n```\r\n","在排序数组中查找元素的第一个和最后一个位置(中等)":"---\r\ntitle: 在排序数组中查找元素的第一个和最后一个位置(中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定一个按照升序排列的整数数组 ``nums``，和一个目标值 ``target``。找出给定目标值在数组中的开始位置和结束位置。\r\n\r\n你的算法时间复杂度必须是 *O(log n)* 级别。\r\n\r\n如果数组中不存在目标值，返回 ``[-1, -1]``。\r\n\r\n**示例 1:**\r\n\r\n\r\n```\r\n输入: nums = [5,7,7,8,8,10], target = 8\r\n输出: [3,4]\r\n```\r\n\r\n**示例 2:**\r\n\r\n\r\n```\r\n输入: nums = [5,7,7,8,8,10], target = 6\r\n输出: [-1,-1]\r\n```\r\n\r\n## 解题思路\r\n\r\n**二分查找法**\r\n\r\n二分查找法不必多说\r\n\r\n## 答案\r\n\r\n\r\n```\r\nclass Solution {\r\n    fun searchRange(nums: IntArray, target: Int): IntArray {\r\n        var result = intArrayOf(-1,-1)\r\n        val leftIdx = binarySearchLeftIndex(nums,target,true)\r\n        if (leftIdx >= nums.size || nums[leftIdx] != target) {\r\n            return result\r\n        }\r\n        result[0] = leftIdx\r\n        result[1] = binarySearchLeftIndex(nums,target,false)-1\r\n        return result\r\n    }\r\n\r\n    private fun binarySearchLeftIndex(nums: IntArray,tartget: Int,isLeft: Boolean) : Int {\r\n        var start = 0\r\n        var end = nums.size\r\n        while (start < end) {\r\n            var mid = start + (end - start) / 2\r\n            if (nums[mid] > tartget || (isLeft && nums[mid] == tartget)) {\r\n                end = mid\r\n            } else {\r\n                start = mid + 1\r\n            }\r\n        }\r\n        return start\r\n    }\r\n}\r\n```\r\n","子集(中等)":"---\r\ntitle: 子集(中等)\r\ndate: 2020-03-04 05:43:11\r\n---\r\n## 题目描述\n\n给定一组**不含重复元素**的整数数组 *nums*，返回该数组所有可能的子集（幂集）。\n\n**说明：** 解集不能包含重复的子集。\n\n**示例:**\n\n\n```\n输入: nums = [1,2,3]\n输出:\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n```\n\n## 解题思路\n\n很明显，这题可以用 **回溯** 来解决\n\n不过使用回溯的时候需要注意，Kotlin中 **MutableList** 对象不能直接添加到另外一个list中去，因为它改变了，list中的内容也会改变，和java比，有的不太一样\n\n## 答案\n\n\n```\n    fun subsets(nums: IntArray): List<List<Int>> {\n        val result = mutableListOf<List<Int>>()\n        backtraceSubsets(0,nums,result, mutableListOf())\n        return result\n    }\n\n    private fun backtraceSubsets(\n        index: Int,\n        nums: IntArray,\n        results: MutableList<List<Int>>, lastNum: MutableList<Int>) {\n        results.add(lastNum.toList())\n        for (i in index until nums.size) {\n            lastNum.add(nums[i])\n            backtraceSubsets(i + 1, nums, results, lastNum)\n            lastNum.removeAt(lastNum.lastIndex)\n        }\n    }\n```\n","字符串相乘(中等)":"---\r\ntitle: 字符串相乘(中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定两个以字符串形式表示的非负整数 ``num1`` 和 ``num2``，返回 ``num1`` 和 ``num2`` 的乘积，它们的乘积也表示为字符串形式。\r\n\r\n**示例 1:**\r\n\r\n```\r\n输入: num1 = \"2\", num2 = \"3\"\r\n输出: \"6\"\r\n```\r\n**示例 2:**\r\n\r\n\r\n```\r\n输入: num1 = \"123\", num2 = \"456\"\r\n输出: \"56088\"\r\n```\r\n**说明：**\r\n\r\n- ``num1``  和 ``num2`` 的长度小于110。\r\n- ``num1`` 和 ``num2`` 只包含数字 ``0-9``。\r\n- ``num1`` 和 ``num2`` 均不以零开头，除非是数字 ``0`` 本身。\r\n- **不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。**\r\n\r\n\r\n## 解题思路\r\n\r\n可以通过小学学过的，**竖式相乘** 来进行求解\r\n\r\n![image](https://user-images.githubusercontent.com/30992818/72044806-b85e9400-32ef-11ea-8c97-f0e12b4f9c2d.png)\r\n\r\n结合图片来看：\r\n\r\n- 如果乘数 ``num1`` 位数为 ``M``，被乘数 ``num2`` 位数为 ``N``， 那么 ``num1 x num2`` 结果 ``res`` 最大总位数为 **``M+N``**\r\n- 根据上面的信息，如果以字符串的形式表示的话，``num1`` 长度为 ``M``，``num2`` 长度为 ``N``，``res`` 长度为 ``M+N``\r\n- ``num1[i] x num2[j]`` 的结果为 ``tmp``(位数为两位，\"0x\",\"xy\"的形式)，其第一位位于 ``res[i+j]``，第二位位于 ``res[i+j+1]``\r\n\r\n\r\n根据上面的信息，其实就可以写出题解了\r\n\r\n\r\n## 答案\r\n\r\n\r\n```\r\n    fun multiply(num1: String, num2: String): String {\r\n        if(num1 ==\"0\" || num2 == \"0\") return \"0\"\r\n        val array = IntArray(num1.length + num2.length)\r\n        for (i in (num1.length - 1) downTo 0) {\r\n            val n1 = num1[i] - '0'\r\n            for (j in (num2.length - 1) downTo 0){\r\n                val n2 = num2[j] - '0'\r\n                val sum = array[i + j + 1] + n1 * n2\r\n                array[i + j + 1] = sum % 10\r\n                array[i + j] += sum / 10\r\n            }\r\n        }\r\n        val result = StringBuilder()\r\n        for (i in array.indices) {\r\n            if(i == 0 && array[i] == 0) continue\r\n            result.append(array[i])\r\n        }\r\n        return result.toString()\r\n    }\r\n```\r\n","将有序数组转换为二叉搜索树(简单)":"---\r\ntitle: 将有序数组转换为二叉搜索树(简单)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。\r\n\r\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\r\n\r\n**示例:**\r\n\r\n\r\n```\r\n给定有序数组: [-10,-3,0,5,9],\r\n\r\n一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：\r\n\r\n      0\r\n     / \\\r\n   -3   9\r\n   /   /\r\n -10  5\r\n```\r\n\r\n## 解题思路\r\n\r\n> 平衡二叉树的一个特性是：左子节点小于父节点，右子节点大于父节点\r\n\r\n也就是说，根据这个特性，我们可以想象得到，每一颗平衡二叉树，根节点的值，就是一个有序数组最中间的值。\r\n\r\n> 再根据平衡二叉树另外一个特性：每个子节点都可以单独看成一颗新的平衡二叉树的根节点（子树）\r\n\r\n两个特性结合，就可以根据二分法来解题了\r\n\r\n## 答案\r\n\r\n\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode(int x) { val = x; }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode sortedArrayToBST(int[] nums) {\r\n        return sortedArrayToBST(nums, 0, nums.length);\r\n    }\r\n    \r\n    private TreeNode sortedArrayToBST(int[] nums, int start, int end) {\r\n        if (start >= end) {\r\n            return null;\r\n        }\r\n        int mid = start/2 + end / 2;\r\n        TreeNode root = new TreeNode(nums[mid]);\r\n        root.left = sortedArrayToBST(nums, start, mid);\r\n        root.right = sortedArrayToBST(nums, mid + 1, end);\r\n        return root;\r\n    }\r\n}\r\n```\r\n","平衡二叉树(简单)":"---\r\ntitle: 平衡二叉树(简单)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定一个二叉树，判断它是否是高度平衡的二叉树。\r\n\r\n本题中，一棵高度平衡二叉树定义为：\r\n> 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。\r\n\r\n**示例 1:**\r\n\r\n给定二叉树 ``[3,9,20,null,null,15,7]``\r\n\r\n```\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n```\r\n返回 ``true`` 。\r\n\r\n**示例 2:**\r\n\r\n给定二叉树 ``[1,2,2,3,3,null,null,4,4]``\r\n\r\n\r\n```\r\n       1\r\n      / \\\r\n     2   2\r\n    / \\\r\n   3   3\r\n  / \\\r\n 4   4\r\n```\r\n返回 ``false`` 。\r\n\r\n## 解题思路\r\n\r\n由于平衡二叉树**每个节点的左右两个子树**的高度差的绝对值不超过1。\r\n\r\n所以我们根据这个特性来，由底到上来对二叉树进行便利，当遇到有左右子树高度相差超过1时候，停止遍历，并且得到结果。这里，用 **-1** 来表示遍历非平衡二叉树，其他数字则表示正常的高度\r\n\r\n## 答案\r\n\r\n\r\n```\r\n/**\r\n * Example:\r\n * var ti = TreeNode(5)\r\n * var v = ti.`val`\r\n * Definition for a binary tree node.\r\n * class TreeNode(var `val`: Int) {\r\n *     var left: TreeNode? = null\r\n *     var right: TreeNode? = null\r\n * }\r\n */\r\nimport kotlin.math.abs\r\nimport kotlin.math.max\r\nclass Solution {\r\n    fun isBalanced(root: TreeNode?): Boolean {\r\n        return treeDeep(root) != -1   \r\n    }\r\n    \r\n    fun treeDeep(root: TreeNode?): Int{\r\n        if(root == null) return 0\r\n        val left = treeDeep(root.left)\r\n        if(left == -1) return -1\r\n        val right = treeDeep(root.right)\r\n        if(right == -1) return  -1\r\n        return if(abs(left - right) < 2) max(left,right) + 1 else -1\r\n    }\r\n}\r\n```\r\n","括号生成(中等)":"---\r\ntitle: 括号生成(中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给出 *n* 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。\r\n\r\n例如，给出 *n = 3*，生成结果为：\r\n\r\n\r\n```\r\n[\r\n  \"((()))\",\r\n  \"(()())\",\r\n  \"(())()\",\r\n  \"()(())\",\r\n  \"()()()\"\r\n]\r\n```\r\n\r\n## 解题思路\r\n\r\n这种，求多种可能性的。一般都是使用 **回溯** 来解决问题\r\n\r\n不过难点在于，回溯的代码要如何写。\r\n\r\n首先，可以肯定的是，最左边的一定是左括号，最右边的一定是又括号，而且两者的数量是一致的。\r\n\r\n所以，我们可以首先在字符串中放置一个左括号，当右括号数量比左括号数量小时，我们可以放一个右括号。而左括号数量还没达到字符串一半时，我们随时可以放左括号。\r\n\r\n## 答案\r\n\r\n\r\n```\r\nclass Solution {\r\n    fun generateParenthesis(n: Int): List<String> {\r\n        val result = mutableListOf<String>()\r\n        backtraceParenthesis(\"\",0,0,n,result)\r\n        return result\r\n    }\r\n\r\n    private fun backtraceParenthesis(parenthesis: String, leftNum: Int, rightNum: Int, n: Int, result: MutableList<String>){\r\n        if(parenthesis.length == n * 2){\r\n            result.add(parenthesis)\r\n            return\r\n        }\r\n        if(leftNum < n){\r\n            backtraceParenthesis(\"$parenthesis(\",leftNum+1,rightNum,n,result)\r\n        }\r\n        if(rightNum < leftNum){\r\n            backtraceParenthesis(\"$parenthesis)\",leftNum,rightNum+1,n,result)\r\n        }\r\n    }\r\n}\r\n```\r\n","搜索二维矩阵(中等)":"---\r\ntitle: 搜索二维矩阵(中等)\r\ndate: 2020-03-03 11:12:38\r\n---\r\n## 题目描述\n\n编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：\n\n- 每行中的整数从左到右按升序排列。\n- 每行的第一个整数大于前一行的最后一个整数。\n\n**示例 1:**\n\n\n```\n输入:\nmatrix = [\n  [1,   3,  5,  7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n]\ntarget = 3\n输出: true\n```\n\n**示例 2:**\n\n\n```\n输入:\nmatrix = [\n  [1,   3,  5,  7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n]\ntarget = 13\n输出: false\n```\n\n## 解题思路\n\n首先我们需要注意到这个二维矩阵的一些特效，这样有助于我们解题\n\n特性如下：\n\n- **从上到下递增、从左到右递增**\n- **左下角元素**： 为所在列最大元素，所在行最小元素。\n- **右上角元素**： 为所在行最大元素，所在列最小元素。\n\n左下角和右上角都可以作为突破口，我们就以左下角为例吧\n\n**从矩阵 matrix 左下角元素（索引设为 (i, j) ）开始遍历，并与目标值对比：**\n- 当 `matrix[i][j] > target` 时： 行索引向上移动一格（即 **i--**），即消去矩阵第 i 行元素\n- 当 `matrix[i][j] < target` 时： 列索引向右移动一格（即 **j++**），即消去矩阵第 j 列元素\n- 当 `matrix[i][j] == target` 时： 返回 true \n\n\n## 答案\n\n\n```\n    fun searchMatrix(matrix: Array<IntArray>, target: Int): Boolean {\n        var i = matrix.size - 1\n        var j = 0\n        while(i >= 0 && j < matrix[0].size) {\n            if(matrix[i][j] > target) i--\n            else if(matrix[i][j] < target) j++\n            else return true\n        }\n        return false\n    }\n```\n","数字转换为十六进制数(简单)":"---\r\ntitle: 数字转换为十六进制数(简单)\r\ndate: 2020-03-03 10:10:47\r\n---\r\n## 题目描述\n\n给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 ``补码运算`` 方法。\n\n**注意:**\n\n- 十六进制中所有字母(a-f)都必须是小写。\n- 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 \n- 给定的数确保在32位有符号整数范围内。\n- **不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法**。\n\n**示例 1：**\n\n\n```\n输入:\n26\n\n输出:\n\"1a\"\n```\n\n**示例 2：**\n\n```\n输入:\n-1\n\n输出:\n\"ffffffff\"\n```\n\n## 解题思路\n\n可以知道任何数字和 ``0xF`` 相 **与** 的结果为 **4位二进制数字**，类似下面这样：\n\n```\n???????xxxx ^ 1111 = xxxx\n```\n所以，每次计算出结果后，将输入的数右移四位,知道输入的数字为0。就可以了\n\n## 答案\n\n\n```\n    fun toHex(num: Int): String {\n       if (num == 0) return \"0\"\n        var i = num\n        val r = StringBuilder()\n        while( i != 0){\n            val j = i and 0xF\n            val jj = when(j){\n                10 -> \"a\"\n                11 -> \"b\"\n                12 -> \"c\"\n                13 -> \"d\"\n                14 -> \"e\"\n                15 -> \"f\"\n                else -> j.toString()\n            }\n            r.append(jj)\n            i = i.ushr(4)\n        }\n        return r.reverse().toString()\n    }\n```\n","旋转图像(中等)":"---\r\ntitle: 旋转图像(中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定一个 *``n × n``* 的二维矩阵表示一个图像。\r\n\r\n将图像顺时针旋转 90 度。\r\n\r\n**说明：**\r\n\r\n你必须在**原地**旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。\r\n\r\n**示例 1:**\r\n\r\n\r\n```\r\n给定 matrix = \r\n[\r\n  [1,2,3],\r\n  [4,5,6],\r\n  [7,8,9]\r\n],\r\n\r\n原地旋转输入矩阵，使其变为:\r\n[\r\n  [7,4,1],\r\n  [8,5,2],\r\n  [9,6,3]\r\n]\r\n```\r\n**示例 2:**\r\n\r\n\r\n```\r\n给定 matrix =\r\n[\r\n  [ 5, 1, 9,11],\r\n  [ 2, 4, 8,10],\r\n  [13, 3, 6, 7],\r\n  [15,14,12,16]\r\n], \r\n\r\n原地旋转输入矩阵，使其变为:\r\n[\r\n  [15,13, 2, 5],\r\n  [14, 3, 4, 1],\r\n  [12, 6, 8, 9],\r\n  [16, 7,10,11]\r\n]\r\n```\r\n\r\n\r\n## 解题思路\r\n\r\n可以换一个角度来看问题，比如我们不是直接去旋转数组，而是每次先旋转数组的 **上下左右** 四个角。\r\n\r\n接着，旋转数组四个角相邻的元素，直到该层旋转完毕。然后开始里面一层的旋转。\r\n\r\n因为是顺时针旋转，所以旋转方向是 ``左上角 -> 向右``，``右上角 -> 向下``，``右下角 -> 向左``，``左下角 -> 向上``。\r\n\r\n不过理论上是如此，实际写代码的时候还需要仔细一些，因为一不小心可能就会写错元素对应的下标\r\n\r\n## 答案\r\n\r\n\r\n```\r\n    fun rotate(matrix: Array<IntArray>): Unit {\r\n        val n = matrix.size\r\n        for(i in 0 until n / 2){\r\n            for(j in i until (n - i - 1)){\r\n                val start = matrix[i][j]\r\n                matrix[i][j] = matrix[n-j-1][i]\r\n                matrix[n-j-1][i] = matrix[n-i-1][n-j-1]\r\n                matrix[n-i-1][n-j-1] = matrix[j][n-i-1]\r\n                matrix[j][n-i-1] = start\r\n            }\r\n        }\r\n    }\r\n```\r\n","旋转链表(中等)":"---\r\ntitle: 旋转链表(中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定一个链表，旋转链表，将链表每个节点向右移动 *k* 个位置，其中 *k* 是非负数。\r\n\r\n**示例 1:**\r\n\r\n\r\n```\r\n输入: 1->2->3->4->5->NULL, k = 2\r\n输出: 4->5->1->2->3->NULL\r\n解释:\r\n向右旋转 1 步: 5->1->2->3->4->NULL\r\n向右旋转 2 步: 4->5->1->2->3->NULL\r\n```\r\n\r\n**示例 2:**\r\n\r\n\r\n```\r\n输入: 0->1->2->NULL, k = 4\r\n输出: 2->0->1->NULL\r\n解释:\r\n向右旋转 1 步: 2->0->1->NULL\r\n向右旋转 2 步: 1->2->0->NULL\r\n向右旋转 3 步: 0->1->2->NULL\r\n向右旋转 4 步: 2->0->1->NULL\r\n```\r\n\r\n## 解题思路\r\n\r\n这题的难点主要在于，k的大小可能超过链表的长度。所以需要先计算出链表的长度，也就是先遍历一遍链表。\r\n\r\n这题可以在第一次遍历链表后，将链表首尾相连，然后可以在第二次遍历时，将链表旋转\r\n\r\n![image](https://user-images.githubusercontent.com/30992818/72131149-65034900-33b6-11ea-8bd7-e96a1a6a7f99.png)\r\n\r\n\r\n## 答案\r\n\r\n\r\n```\r\n    fun rotateRight(head: ListNode?, k: Int): ListNode? {\r\n        if(head == null || k == 0) return head\r\n        var index = 0\r\n        var temp = head\r\n        while (temp != null){\r\n            index++\r\n            if(temp.next == null){\r\n                temp.next = head\r\n                break\r\n            }\r\n            temp = temp.next\r\n        }\r\n        val realK = k % index\r\n        if(realK == 0 || realK == index) {\r\n            temp?.next = null\r\n            return head\r\n        }\r\n        var temp2 = temp\r\n        var index2 = 0\r\n        var result :ListNode ?= null\r\n        while (temp2!!.next != null){\r\n            index2++\r\n            temp2 = temp2.next\r\n            if(index2 == index - realK){\r\n                result = temp2?.next\r\n                temp2?.next = null\r\n                break\r\n            }\r\n        }\r\n        return result\r\n    }\r\n```\r\n","无重复字符的最长子串(中等)":"---\r\ntitle: 无重复字符的最长子串(中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。\r\n\r\n**示例 1:**\r\n\r\n\r\n```\r\n输入: \"abcabcbb\"\r\n输出: 3 \r\n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\r\n```\r\n\r\n**示例 2:**\r\n\r\n\r\n```\r\n输入: \"bbbbb\"\r\n输出: 1\r\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\r\n```\r\n\r\n**示例 3:**\r\n\r\n```\r\n输入: \"pwwkew\"\r\n输出: 3\r\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\r\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\r\n```\r\n\r\n\r\n## 解题思路\r\n\r\n**滑动窗口**\r\n\r\n先简单用图片看一下滑动窗口的概念\r\n\r\n![image](https://user-images.githubusercontent.com/30992818/68823336-6d991500-06ce-11ea-916f-20f3abfb3f40.png)\r\n\r\n比如上面字符串 ``abcdeabcdfgaee`` 首先进入这个队列， ``abcde`` 是满足题目的，但是再往后 ``abcdea`` 就重复了，所以窗口需要进行移动。\r\n\r\n只需要将窗口最左边的元素移出，然后窗口一直往右边移动，知道找到最长的窗口即可。\r\n\r\n\r\n## 答案\r\n\r\n\r\n```\r\n    fun lengthOfLongestSubstring(s: String): Int {\r\n        val set = mutableSetOf<Char>()\r\n        var right = 0\r\n        var left = 0\r\n        val n = s.length\r\n        var lenght = 0\r\n        while (right < n && left < n){\r\n            if(!set.contains(s[right])){\r\n                set.add(s[right])\r\n                right++\r\n                lenght = maxOf(lenght, right - left)\r\n            } else {\r\n                set.remove(s[left])\r\n                left++\r\n            }\r\n        }\r\n        return lenght\r\n    }\r\n```\r\n","最小路径和(中等)":"---\r\ntitle: 最小路径和(中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定一个包含非负整数的 *m x n* 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\r\n\r\n说明：每次只能向下或者向右移动一步。\r\n\r\n**示例:**\r\n\r\n\r\n```\r\n输入:\r\n[\r\n  [1,3,1],\r\n  [1,5,1],\r\n  [4,2,1]\r\n]\r\n输出: 7\r\n解释: 因为路径 1→3→1→1→1 的总和最小。\r\n```\r\n\r\n\r\n## 解题思路\r\n\r\n还是动态规划\r\n\r\n- 可以用 **d[i][j]** 表示从 **d[0][0]** 到 **d[i][j]** 的最小距离\r\n- 对于每个点，该点的值为左边点和上边点中较小的一个与改点想加。如果是左边界或又边界，则少边界上一个点与当前点想加\r\n\r\n\r\n直接看代码，简洁明了\r\n\r\n\r\n## 答案\r\n\r\n\r\n```\r\n    fun minPathSum(grid: Array<IntArray>): Int {\r\n        val column = grid.size\r\n        val row = grid[0].size\r\n        for(i in 0 until column){\r\n            for(j in 0 until row){\r\n                if(i == 0 && j == 0) continue\r\n                else if(i == 0) grid[i][j] += grid[i][j-1]\r\n                else if(j == 0) grid[i][j] += grid[i-1][j]\r\n                else grid[i][j] += min(grid[i-1][j],grid[i][j-1])\r\n            }\r\n        }\r\n        return grid[column-1][row-1]\r\n    }\r\n```\r\n","最长回文子串(中等)":"---\r\ntitle: 最长回文子串(中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\r\n\r\n**示例 1：**\r\n\r\n\r\n```\r\n输入: \"babad\"\r\n输出: \"bab\"\r\n注意: \"aba\" 也是一个有效答案。\r\n```\r\n\r\n**示例 2：**\r\n\r\n\r\n```\r\n输入: \"cbbd\"\r\n输出: \"bb\"\r\n```\r\n\r\n## 解题思路\r\n\r\n根据回文数的特性。当字符串个数为奇数个，比如 ``a`` 是一个回文数。当字符串个数为偶数个，比如  ``aa`` 也是一个回文数。\r\n\r\n所以我们要着回文数时，要分两种情况来找\r\n\r\n如何找呢？依赖于上面提到的，回文数的特性，通过 由中间向两边扩散的方法来寻找\r\n\r\n## 答案\r\n\r\n\r\n```\r\nclass Solution {\r\n    fun longestPalindrome(s: String): String {\r\n        if(s.length <= 1) return s\r\n        var max = \"\"\r\n        for (i in 0 until (s.length - 1)) {\r\n            val one = getPalindrome(s, i,i)\r\n            val two = getPalindrome(s, i,i+1)\r\n            val bigger = if(one.length > two.length) one else two\r\n            max = if(max.length > bigger.length) max else bigger\r\n        }\r\n        return max\r\n    }\r\n\r\n    private fun getPalindrome(s: String, left: Int, right: Int) : String{\r\n        var l = left\r\n        var r = right\r\n        var isPalindrome = false\r\n        while (l >= 0 && r < s.length && s[l] == s[r]){\r\n            l--\r\n            r++\r\n            isPalindrome = true\r\n        }\r\n        return if(isPalindrome) s.substring(l+1,r) else s.substring(l, l+1)\r\n    }\r\n}\r\n```\r\n","有效的完全平方数(简单)":"---\r\ntitle: 有效的完全平方数(简单)\r\ndate: 2020-03-03 10:10:46\r\n---\r\n## 题目描述\n\n给定一个正整数 *num*，编写一个函数，如果 *num* 是一个完全平方数，则返回 True，否则返回 False。\n\n说明：不要使用任何内置的库函数，如  ``sqrt``。\n\n**示例 1：**\n\n\n```\n输入：16\n输出：True\n```\n\n**示例 2：**\n\n\n```\n输入：14\n输出：False\n```\n\n## 解题思路\n\n这题如果使用递归，让一个数慢慢增加，然后取平方，用于判断是否符合条件。  \n也是可行的，但是显然这样做耗时会非常的高。\n\n所以，可以使用二分查找法，先确定int值上限的开方值为 **46340** ，然后以此去展开计算\n\n## 答案\n\n\n```\n    fun isPerfectSquare(num: Int): Boolean {\n        var left = 0\n        var right = 46340\n        while (left < right){\n            val mid = (left + right) / 2\n            val theSum = mid * mid\n            if(theSum> num){\n                right = mid\n            } else if(theSum < num){\n                left = mid + 1\n            } else {\n                left = mid\n                break\n            }\n        }\n        return left * left == num\n    }\n```\n","求众数(简单)":"---\r\ntitle: 求众数(简单)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ``⌊ n/2 ⌋`` 的元素。\r\n\r\n你可以假设数组是非空的，并且给定的数组总是存在众数。\r\n\r\n**示例 1:**\r\n\r\n\r\n```\r\n输入: [3,2,3]\r\n输出: 3\r\n```\r\n\r\n**示例 2:**\r\n\r\n\r\n```\r\n输入: [2,2,1,1,1,2,2]\r\n输出: 2\r\n```\r\n\r\n## 解题思路\r\n\r\n#### 常规思路\r\n\r\n记录每个数字出现的次数，出现次数超过 n/2 的那个就是\r\n\r\n\r\n#### 偷懒思路\r\n\r\n通过系统提供的api将数组排序，由于众数的个数大于 n/2 ，所以排序后最中间的那个肯定就数众数\r\n\r\n\r\n#### 有意思的思路\r\n\r\n因为众数的个数是大于 n/2的，所以数组众数最多。于是我们可以从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个众数\r\n\r\n\r\n## 答案\r\n\r\n#### 常规答案\r\n\r\n\r\n```\r\n    fun majorityElement(nums: IntArray): Int {\r\n        val map = mutableMapOf<Int,Int>()\r\n        for (num in nums) {\r\n            val value = map[num]\r\n            if(value == null){\r\n                map[num] = 1\r\n            } else {\r\n                map[num] = value+1\r\n            }\r\n        }\r\n        for (mutableEntry in map) {\r\n            if(mutableEntry.value > nums.size / 2) return mutableEntry.key\r\n        }\r\n        return 0\r\n    }\r\n```\r\n\r\n\r\n#### 偷懒答案\r\n\r\n\r\n```\r\n    fun majorityElement(nums: IntArray): Int {\r\n        nums.sort()\r\n        return nums[nums.size / 2]\r\n    }\r\n```\r\n\r\n\r\n#### 有意思的答案\r\n\r\n\r\n```\r\n    fun majorityElement(nums: IntArray): Int {\r\n        var number = nums[0]\r\n        var counter = 1\r\n        for (index in 1 until nums.size - 1) {\r\n            if(nums[index] == number){\r\n                counter++\r\n            } else {\r\n                counter--\r\n                if(counter == 0) number = nums[index + 1]\r\n            }\r\n        }\r\n        return number\r\n    }\r\n```\r\n","电话号码的字母组合(中等)":"---\r\ntitle: 电话号码的字母组合(中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\r\n\r\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\r\n\r\n![17_telephone_keypad](https://user-images.githubusercontent.com/30992818/69221490-5cf70c00-0bb2-11ea-8db6-d26e80434f31.png)\r\n\r\n\r\n**示例:**\r\n\r\n\r\n```\r\n输入：\"23\"\r\n输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\r\n```\r\n\r\n**说明:**  \r\n尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。\r\n\r\n\r\n\r\n## 解题思路\r\n\r\n#### 回溯\r\n\r\n这个题目算是我第一次遇到回溯。关于“回溯”，概念如下：\r\n\r\n> 回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。\r\n\r\n和递归的不同之处在于，递归会有一个明显的退出条件，用于结束递归循环。而回溯虽然也是一种循环，但是不需要结束条件，走到最后自然就结束了\r\n\r\n## 答案\r\n\r\n\r\n```\r\nclass Solution {\r\n    fun letterCombinations(digits: String): List<String> {\r\n        if (digits.isEmpty()) return listOf()\r\n        val map = mapOf(\r\n            \"2\" to \"abc\", \"3\" to \"def\",\r\n            \"4\" to \"ghi\", \"5\" to \"jkl\", \"6\" to \"mno\",\r\n            \"7\" to \"pqrs\", \"8\" to \"tuv\", \"9\" to \"wxyz\"\r\n        )\r\n        val result = mutableListOf<String>()\r\n        backtrackLetter(\"\", digits, result,map)\r\n        return result\r\n    }\r\n\r\n    private fun backtrackLetter(\r\n        combination: String,\r\n        nextDigit: String,\r\n        result: MutableList<String>,\r\n        map: Map<String, String>\r\n    ) {\r\n        if (nextDigit.isEmpty()) {\r\n            result.add(combination)\r\n        } else {\r\n            val digit = nextDigit[0].toString()\r\n            val letters = map[digit] ?: \"\"\r\n            for (letter in letters) {\r\n                backtrackLetter(combination + letter, nextDigit.substring(1), result, map)\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n","盛最多水的容器(中等)":"---\r\ntitle: 盛最多水的容器(中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定 *n* 个非负整数 *a1，a2，...，an*，每个数代表坐标中的一个点 *(i, ai) *。在坐标内画 *n* 条垂直线，垂直线 *i* 的两个端点分别为 *(i, ai)* 和 *(i, 0)*。找出其中的两条线，使得它们与 *x* 轴共同构成的容器可以容纳最多的水。\r\n\r\n说明：你不能倾斜容器，且 *n* 的值至少为 2。\r\n\r\n![image](https://user-images.githubusercontent.com/30992818/69030923-d60c2d00-0a13-11ea-8924-cb7038f9e194.jpg)\r\n\r\n图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\r\n \r\n \r\n\r\n\r\n**示例:**\r\n\r\n\r\n```\r\n输入: [1,8,6,2,5,4,8,3,7]\r\n输出: 49\r\n```\r\n\r\n\r\n## 解题思路\r\n\r\n\r\n#### 常规思路\r\n\r\n直接使用两个for循环，完全遍历，求出最大面积\r\n\r\n\r\n#### 优化思路\r\n\r\n**双指针**\r\n\r\n直接同时从数组两端开始进行查询。其中值较小的指针向另外一方进行移动。\r\n\r\n因为决定面积的除了和两指针中最小的一个值有关，还与两指针的距离有关。\r\n\r\n如果移动的是数值更大的指针，那样面积是否增加就无法确定了，而移动数值较小的那个指针可以保证面积是有机会增加的。\r\n\r\n## 答案\r\n\r\n#### 常规答案\r\n\r\n\r\n```\r\nclass Solution {\r\n    fun maxArea(height: IntArray): Int {\r\n        var maxArea = 0\r\n        for(i in 0 until height.size - 1){\r\n            for(j in i+1 until  height.size){\r\n                val area = minOf(height[i],height[j]) * (j - i)\r\n                if(maxArea < area){\r\n                    maxArea = area\r\n                }\r\n            }\r\n        }\r\n        return maxArea\r\n    }\r\n}\r\n```\r\n\r\n\r\n#### 优化答案\r\n\r\n\r\n```\r\nclass Solution {\r\n    fun maxArea(height: IntArray): Int {\r\n        var left = 0\r\n        var right = height.size - 1\r\n        var maxArea = 0\r\n        while (left < right){\r\n            val area = minOf(height[left],height[right]) * (right - left)\r\n            if(maxArea < area){\r\n                maxArea = area\r\n            }\r\n            if(height[left] < height[right]){\r\n                left++\r\n            } else {\r\n                right--\r\n            }\r\n        }\r\n        return maxArea\r\n    }\r\n}\r\n```\r\n\r\n\r\n","矩阵置零(中等)":"---\r\ntitle: 矩阵置零(中等)\r\ndate: 2020-03-03 10:51:16\r\n---\r\n## 题目描述\n\n给定一个 *m x n* 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用**原地**算法。\n\n**示例 1:**\n\n\n```\n输入: \n[\n  [1,1,1],\n  [1,0,1],\n  [1,1,1]\n]\n输出: \n[\n  [1,0,1],\n  [0,0,0],\n  [1,0,1]\n]\n```\n\n**示例 2:**\n\n\n```\n输入: \n[\n  [0,1,2,0],\n  [3,4,5,2],\n  [1,3,1,5]\n]\n输出: \n[\n  [0,0,0,0],\n  [0,4,5,0],\n  [0,3,1,0]\n]\n```\n**\n进阶:**\n\n- 一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。\n- 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。\n- 你能想出一个常数空间的解决方案吗？\n\n\n## 解题思路\n\n如果一个元素为0，则其所在行和列都置零，听起来是不是很像炸弹人游戏里面的那个炸弹效果？\n\n### 思路一\n\n维护两个Set，遍历所有元素，然后分别记录有零的行和列。接下来通过遍历Set的方式，分别将对应的行和列全部置零。\n\n这样做的复杂度如下：\n- 时间复杂度：*O(M × N)*，其中 *M* 和 *N* 分别对应行数和列数。\n- 空间复杂度：*O(M + N)*。\n\n\n### 思路二\n\n这个思路属于特殊题目特殊解法，此题就有特解\n\n通过题目的要求，可以发现下面的特性：\n\n```\nif cell[i][j] == 0 {\n    cell[i][0] = 0\n    cell[0][j] = 0\n}\n```\n> 所以我们可以用每行和每列的第一个元素作为标记，这个标记用来表示这一行或者这一列是否需要赋零。这意味着对于每个节点不需要访问 M+N 个格子而是只需要对标记点的两个格子赋值。\n\n接下来，怎么做就很明显了，不过操作起来可能会有一点麻烦：\n\n- 遍历整个矩阵，如果 cell[i][j] == 0 就将第 i 行和第 j 列的第一个元素标记。\n- 第一行和第一列的标记是相同的，都是 cell[0][0]，所以需要一个额外的变量告知第一列是否被标记，同时用 cell[0][0] 继续表示第一行的标记。\n- 然后，从第二行第二列的元素开始遍历，如果第 r 行或者第 c 列被标记了，那么就将 cell[r][c] 设为 0。这里第一行和第一列的作用就相当于方法一中的 row_set 和 column_set 。\n- 然后我们检查是否 cell[0][0] == 0 ，如果是则赋值第一行的元素为零。\n- 然后检查第一列是否被标记，如果是则赋值第一列的元素为零。\n\n\n复杂度如下：\n- 时间复杂度：O(M \\times N)O(M×N)\n- 空间复杂度：O(1)O(1)\n\n\n## 答案\n\n### 解法一：\n\n\n```\n    fun setZeroes(matrix: Array<IntArray>): Unit {\n        val rowMap = mutableSetOf<Int>()\n        val columnMap = mutableSetOf<Int>()\n        for (i in matrix.indices) {\n            for (j in matrix[i].indices) {\n                val element = matrix[i][j]\n                if(element == 0){\n                    rowMap.add(i)\n                    columnMap.add(j)\n                }\n            }\n        }\n        for (row in rowMap) {\n            for (i in matrix[0].indices) {\n                matrix[row][i] = 0\n            }\n        }\n        for (column in columnMap) {\n            for (i in matrix.indices) {\n                matrix[i][column] = 0\n            }\n        }\n    }\n```\n\n\n### 解法二\n\n\n```\n    fun setZeroes(matrix: Array<IntArray>): Unit {\n        //利用第一行和第一列保存改行或者该列是否应该被置零\n        //由于第一个元素会重合，所以用firstRow、firstLine保存第一行和第一列的数据\n        val length = matrix.size\n        val row = matrix[0].size\n        var firstLine = 1\n        var firstRow = 1\n        for (i in 0 until length) {\n            for (j in 0 until row) {\n                if (matrix[i][j] == 0) {\n                    if (i == 0) {\n                        firstLine = 0\n                    } else {\n                        matrix[i][0] = 0\n                    }\n                    if (j == 0) {\n                        firstRow = 0\n                    } else {\n                        matrix[0][j] = 0\n                    }\n                }\n            }\n        }\n        //处理除了第一行和第一列外的其他行列 置为零\n        //处理行\n        for (i in 1 until length) {\n            if (matrix[i][0] == 0) {\n                for (j in 1 until row) {\n                    matrix[i][j] = 0\n                }\n            }\n        }\n        //处理列\n        for (i in 1 until row) {\n            if (matrix[0][i] == 0) {\n                for (j in 1 until length) {\n                    matrix[j][i] = 0\n                }\n            }\n        }\n        // 处理第一行和第一列\n        if (firstLine == 0) {\n            for (i in 0 until row) {\n                matrix[0][i] = 0\n            }  \n        }\n        if (firstRow == 0) {\n            for (i in 0 until length) {\n                matrix[i][0] = 0\n            }\n        }\n    }\n```\n","移动零(简单)":"---\r\ntitle: 移动零(简单)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定一个数组 ``nums``，编写一个函数将所有 ``0`` 移动到数组的末尾，同时保持非零元素的相对顺序。\r\n\r\n**示例:**\r\n\r\n\r\n```\r\n输入: [0,1,0,3,12]\r\n输出: [1,3,12,0,0]\r\n```\r\n\r\n**说明:**\r\n\r\n    1.必须在原数组上操作，不能拷贝额外的数组。 \r\n    2.尽量减少操作次数。\r\n    \r\n    \r\n    \r\n## 解题思路\r\n\r\n#### 一般思路\r\n\r\n将移动后元素放入一个列表中，然后根据列表去移动数组\r\n\r\n#### 优化思路\r\n\r\n根据题目的要求，不可以拷贝额外的数组，所以上面的思路虽然可以解出题目，但是还是不符合要求。\r\n\r\n\r\n我们可以先将所有的非0元素移动到最前面，然后将后面的所有元素置0即可。虽然看起来比较简单，但是实际的操作还是非常精妙的，所以这里记录下来。\r\n\r\n\r\n## 答案\r\n\r\n#### 一般答案\r\n\r\n\r\n```\r\n    fun moveZeroes(nums: IntArray): Unit {\r\n        if (nums.size < 2) return\r\n        val list = nums.toMutableList()\r\n        var index = 0\r\n        var zeroNum = 0\r\n        while (index < list.size - 1 - zeroNum){\r\n            val num = list[index]\r\n            if(num == 0){\r\n                list.removeAt(index)\r\n                list.add(0)\r\n                zeroNum++\r\n            } else {\r\n                index++\r\n            }\r\n        }\r\n        for (i in nums.indices) {\r\n            nums[i] = list[i]\r\n        }\r\n    }\r\n```\r\n\r\n\r\n#### 优化答案\r\n\r\n\r\n```\r\n    fun moveZeroes(nums: IntArray): Unit {\r\n        var index = 0\r\n        nums.forEach {\r\n            if (it != 0) {\r\n                nums[index] = it\r\n                index++\r\n            }\r\n        }\r\n        while (index < nums.size) {\r\n            nums[index] = 0\r\n            index++\r\n        }\r\n    }\r\n```\r\n","第三大的数(简单)":"---\r\ntitle: 第三大的数(简单)\r\ndate: 2020-03-03 10:10:47\r\n---\r\n## 题目描述\n\n给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。\n\n**示例 1:**\n\n\n```\n输入: [3, 2, 1]\n\n输出: 1\n\n解释: 第三大的数是 1.\n```\n\n**示例 2:**\n\n```\n输入: [1, 2]\n\n输出: 2\n\n解释: 第三大的数不存在, 所以返回最大的数 2 .\n```\n\n**示例 3:**\n\n\n```\n输入: [2, 2, 3, 1]\n\n输出: 1\n\n解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。\n存在两个值为2的数，它们都排第二。\n```\n\n\n## 解题思路\n\n#### 一般思路\n\n直接将数组排序，然后从后到前找到第三个不相等的数，虽然能得到结果，不过不符合时间复杂为O(n)的要求\n\n#### 优化思路\n\n可以维护一个只有三个元素的 TreeSet \n\n## 答案\n\n#### 一般答案\n\n\n```\n    fun thirdMax(nums: IntArray): Int {\n        if(nums.isEmpty()) return 0\n        nums.sort()\n        val size = nums.size\n        if(nums.size <= 2) return nums[size - 1]\n        var end = size - 1\n        var num = 1\n        while (end >= 1 && num < 3){\n            if(nums[end] != nums[end - 1]){\n                num++\n                end--\n            } else {\n                end--\n            }\n        }\n        return if(num >= 3) nums[end] else nums[size - 1]\n    }\n```\n\n\n#### 优化答案\n\n\n```\n    fun thirdMax(nums: IntArray): Int {\n        val set = sortedSetOf<Int>()\n        for (elem in nums) {\n            set.add(elem)\n            if (set.size > 3) set.remove(set.first())\n        }\n        return if (set.size < 3) set.last() else set.first()\n    }\n```\n\n\n话说，优化后耗时反而增加了...","螺旋矩阵(中等)":"---\r\ntitle: 螺旋矩阵(中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定一个包含 *m x n* 个元素的矩阵（*m* 行, *n* 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。\r\n\r\n**示例 1:**\r\n\r\n\r\n```\r\n输入:\r\n[\r\n [ 1, 2, 3 ],\r\n [ 4, 5, 6 ],\r\n [ 7, 8, 9 ]\r\n]\r\n输出: [1,2,3,6,9,8,7,4,5]\r\n```\r\n\r\n**示例 2:**\r\n\r\n\r\n```\r\n输入:\r\n[\r\n  [1, 2, 3, 4],\r\n  [5, 6, 7, 8],\r\n  [9,10,11,12]\r\n]\r\n输出: [1,2,3,4,8,12,11,10,9,5,6,7]\r\n```\r\n\r\n## 解题思路\r\n\r\n直接按层模拟\r\n\r\n![image](https://user-images.githubusercontent.com/30992818/72047846-6a00c380-32f6-11ea-9f99-cd266565ad32.png)\r\n\r\n\r\n顺时针来进行输出，一层输出完后进入里层继续输出，知道全部输出完毕\r\n\r\n## 答案\r\n\r\n\r\n```\r\n    fun spiralOrder(matrix: Array<IntArray>): List<Int> {\r\n        val result = mutableListOf<Int>()\r\n        if (matrix.isEmpty()) return result\r\n        var left = 0\r\n        var right = matrix[0].size - 1\r\n        var top = 0\r\n        var bottom = matrix.size - 1\r\n        while (left <= right && top <= bottom) {\r\n            for(i in left..right){\r\n                result.add(matrix[top][i])\r\n            }\r\n            for(i in top+1..bottom){\r\n                result.add(matrix[i][right])\r\n            }\r\n            if (left < right && top < bottom) {\r\n                for(i in right-1 downTo left+1){\r\n                    result.add(matrix[bottom][i])\r\n                }\r\n                for(i in bottom downTo top+1){\r\n                    result.add(matrix[i][left])\r\n                }\r\n            }\r\n            left++\r\n            right--\r\n            top++\r\n            bottom--\r\n        }\r\n        return result\r\n    }\r\n```\r\n","路径总和(简单)":"---\r\ntitle: 路径总和(简单)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。\r\n\r\n**说明:** 叶子节点是指没有子节点的节点。\r\n\r\n**示例:**  \r\n给定如下二叉树，以及目标和 ``sum = 22``，\r\n\r\n\r\n```\r\n              5\r\n             / \\\r\n            4   8\r\n           /   / \\\r\n          11  13  4\r\n         /  \\      \\\r\n        7    2      1\r\n\r\n```\r\n返回 ``true``, 因为存在目标和为 22 的根节点到叶子节点的路径 ``5->4->11->2``。\r\n\r\n\r\n## 解题思路\r\n\r\n很容易可以看出，这是一个需要遍历二叉树，然后求出每条路径节点值的和。\r\n\r\n转换一下思路，如果我们不是求和，而是每经过一个节点，减去该节点的值，直到最后一个节点的时候，得到的值恰好为0。不也正好说明这条路径节点值的和与所给数值相等吗？\r\n\r\n## 答案\r\n\r\n\r\n```\r\n/**\r\n * Example:\r\n * var ti = TreeNode(5)\r\n * var v = ti.`val`\r\n * Definition for a binary tree node.\r\n * class TreeNode(var `val`: Int) {\r\n *     var left: TreeNode? = null\r\n *     var right: TreeNode? = null\r\n * }\r\n */\r\nclass Solution {\r\n    fun hasPathSum(root: TreeNode?, sum: Int): Boolean {\r\n        if(root == null) return false\r\n        val resetSum = sum - root.`val`\r\n        if(root.left == null && root.right == null) return resetSum == 0\r\n        return hasPathSum(root.left, resetSum) || hasPathSum(root.right, resetSum)\r\n    }\r\n}\r\n```\r\n","跳跃游戏(中等)":"---\r\ntitle: 跳跃游戏(中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定一个非负整数数组，你最初位于数组的第一个位置。\r\n\r\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\r\n\r\n判断你是否能够到达最后一个位置。\r\n\r\n**示例 1:**\r\n\r\n\r\n```\r\n输入: [2,3,1,1,4]\r\n输出: true\r\n解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。\r\n```\r\n\r\n**示例 2:**\r\n\r\n\r\n```\r\n输入: [3,2,1,0,4]\r\n输出: false\r\n解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。\r\n```\r\n\r\n## 解题思路\r\n\r\n\r\n- 如果某一个作为 起跳点 的格子可以跳跃的距离是3，那么表示后面3个格子都可以作为 起跳点。\r\n- 可以对每一个能作为 起跳点 的格子都尝试跳一次，把能跳到最远的距离不断更新。\r\n- 如果可以一直跳到最后，就成功了。\r\n\r\n## 答案\r\n\r\n\r\n```\r\n    fun canJump(nums: IntArray): Boolean {\r\n        var maxStep = 0\r\n        for (i in nums.indices) {\r\n            if(i > maxStep) return false\r\n            maxStep = max(maxStep, nums[i] + i)\r\n        }\r\n        return true\r\n    }\r\n```\r\n","链表随机节点(中等)":"---\r\ntitle: 链表随机节点(中等)\r\ndate: 2020-03-08 06:14:30\r\n---\r\n## 题目描述\r\n\r\n给定一个单链表，随机选择链表的一个节点，并返回相应的节点值。保证每个节点**被选的概率一样**。\r\n\r\n**进阶:**\r\n如果链表十分大且长度未知，如何解决这个问题？你能否使用常数级空间复杂度实现？\r\n\r\n**示例:**\r\n\r\n\r\n```\r\n// 初始化一个单链表 [1,2,3].\r\nListNode head = new ListNode(1);\r\nhead.next = new ListNode(2);\r\nhead.next.next = new ListNode(3);\r\nSolution solution = new Solution(head);\r\n\r\n// getRandom()方法应随机返回1,2,3中的一个，保证每个元素被返回的概率相等。\r\nsolution.getRandom();\r\n```\r\n\r\n## 解题思路\r\n\r\n这题是一道 **蓄水池抽样** 算法题\r\n\r\n关于蓄水池抽样，简单介绍几个例子：\r\n\r\n### 问题示例\r\n\r\n采样问题经常会被遇到，比如：\r\n\r\n- 从 100000 份调查报告中抽取 1000 份进行统计。\r\n- 从一本很厚的电话簿中抽取 1000 人进行姓氏统计。\r\n- 从 Google 搜索 \"Ken Thompson\"，从中抽取 100 个结果查看哪些是今年的。\r\n\r\n像这样的，**对于输入数据的规模不确定**，但是要求所抽样的对象被抽取的概率一样，这就涉及到了 **蓄水池采样** 算法\r\n\r\n### 算法过程\r\n终于要讲到**蓄水池采样算法**(Reservoir Sampling)了。先说一下算法的过程：\r\n\r\n假设数据序列的规模为 *n* ， 需要采样的数量的为 *k* \r\n\r\n首先构建一个可容纳 *k* 个元素的数组，将序列的前 *k* 个元素放入数组中\r\n\r\n然后从第 *k+1* 个元素开始，以 *k/n* 的概率来决定该元素是否被替换到数组中（数组中的元素被替换的概率是相同的）。当遍历完所有元素之后，数组中剩下的元素即为所需采取的样本。\r\n\r\n### 证明过程\r\n\r\n对于第 *i* 个数(*i <= k*)。在 *k* 步之前，被选中的概率为 1。走到第 *k+1* 步时，第 *i* 个数被第 *k+1* 个数替换的概率为：\r\n\r\n    【第 k+1 个数被选中的概率】 * 【第 i 个数被选中然后替换的概率】\r\n\r\n也就是 *k*/(*k+1*) * *1/k* = *1*/(*k+1*)。则第 *i* 个数被保留的概率为 *1* - *1*/(*k+1*) = *k*/(*k+1*)\r\n\r\n依此类推，第 *i* 个数不被第 *k+2* 个数替换掉的概率为 1 - *k*/(*k+2*) * *1/k* = *k+1*/(*k+2*)。则走到第 *n* 步时，第 *i* 个数被保留的概率为：\r\n![image](https://user-images.githubusercontent.com/30992818/72140924-c3d3bd00-33cc-11ea-8e87-0e7a554ba8c4.png)\r\n\r\n所以对于其中每个元素，被保留的概率都为 *k/n*\r\n\r\n到这里，蓄水池抽样算是证明完毕，接下来，就可以直接使用在代码中了\r\n\r\n## 答案\r\n\r\n\r\n```\r\nimport kotlin.random.Random\r\n\r\nclass Solution(head: ListNode?) {\r\n    \r\n        private val theHead = head\r\n        private val random = Random(1)\r\n\r\n        fun getRandom(): Int {\r\n            var num = 1\r\n            var value = theHead?.`val` ?: 0\r\n            var next = theHead\r\n            while (next?.next != null){\r\n                num++\r\n                next = next.next\r\n                val nextValue = next?.`val` ?: 0\r\n                val randomRate = random.nextDouble()\r\n                val rate = 1.0 / num\r\n                val needChanged = randomRate <= rate\r\n                if(needChanged) value = nextValue\r\n            }\r\n            return value\r\n        }\r\n\r\n}\r\n```\r\n","颜色分类(中等)":"---\r\ntitle: 颜色分类(中等)\r\ndate: 2020-03-03 12:24:38\r\n---\r\n## 题目描述\n\n给定一个包含红色、白色和蓝色，一共 *n* 个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n**注意:**\n不能使用代码库中的排序函数来解决这道题。\n\n**示例:**\n\n\n```\n输入: [2,0,2,1,1,0]\n输出: [0,0,1,1,2,2]\n```\n\n**进阶：**\n\n- 一个直观的解决方案是使用计数排序的两趟扫描算法。\n首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。\n- 你能想出一个仅使用常数空间的一趟扫描算法吗？\n\n\n## 解题思路\n\n如果没有要求原地排序的话，其实可以通过哈希表的方法去排序\n\n这里就参照官方的解法吧：\n\n我们用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。\n\n本解法的思路是沿着数组移动 `curr` 指针，若 `nums[curr] = 0`，则将其与 `nums[p0]` 互换；若 `nums[curr] = 2` ，则与 `nums[p2]` 互换。\n\n**算法**\n\n- 初始化0的最右边界：`p0 = 0`。在整个算法执行过程中 `nums[idx < p0]` = 0.\n\n- 初始化2的最左边界 ：`p2 = n - 1`。在整个算法执行过程中 `nums[idx > p2] = 2`.\n\n- 初始化当前考虑的元素序号 ：`curr = 0`.\n\n- While `curr <= p2` :\n\n    - 若 `nums[curr] = 0` ：交换第 `curr` 个 和 第 `p0` 个 元素，并将指针都向右移。\n\n    - 若 `nums[curr] = 2` ：交换第 `curr` 个和第 `p2` 个元素，并将 `p2` 指针左移 。\n\n    - 若 `nums[curr] = 1` ：将指针 `curr` 右移。\n\n## 答案\n\n\n```\n  public void sortColors(int[] nums) {\n    int p0 = 0, curr = 0;\n    int p2 = nums.length - 1;\n    int tmp;\n    while (curr <= p2) {\n      if (nums[curr] == 0) {\n        tmp = nums[p0];\n        nums[p0++] = nums[curr];\n        nums[curr++] = tmp;\n      }\n      else if (nums[curr] == 2) {\n        tmp = nums[curr];\n        nums[curr] = nums[p2];\n        nums[p2--] = tmp;\n      }\n      else curr++;\n    }\n  }\n```\n","2019年总结":"---\r\ntitle: 2019年总结\r\ndate: 2019-12-31 22:16:06\r\nindex_img: /img/zongjie_2019.png\r\ntags: 总结\r\n---\r\n\r\n\r\n\r\n# 开头\r\n\r\n第一次写总结，没有经验，不知道从哪里入手。\r\n\r\n同时，以我懒惰的天性来看，我本来是没有写这个的打算的。\r\n\r\n但是今年的我确实是有一些明显的变化，并且其中大部分都是正面的变化，所以想想还是准备在今年的最后一天记录下来这些东西。\r\n\r\n期待日后回首往事的时候，能有一番别样的感受。\r\n\r\n# 身体与健康\r\n\r\n这一年来，我每周都有三次锻炼，身体还算健康吧，除了偶发的感冒、上火。\r\n\r\n关于“身体健康”这个概念，我觉得不仅是对未来的自己负责，也是对自己的家人负责吧。\r\n\r\n所以经常锻炼，是非常有必要的，长期的锻炼下来，变化还算明显。\r\n\r\n具体的变化，可以看一下下面的对比\r\n\r\n![image](https://oldchen-blog-1256696029.cos.ap-guangzhou.myqcloud.com/zongjie_2019/001.jpg)\r\n\r\n\r\n![image](https://oldchen-blog-1256696029.cos.ap-guangzhou.myqcloud.com/zongjie_2019/002.jpg)\r\n\r\n\r\n# 工作与生活\r\n\r\n这一年，换了一家新的公司。于我个人而言，成长是比较明显的。不仅了解到了各种各样的规范，也在这一年从从侧面和经历体会到了资本的温度。而这个算是我心态上最大的改变了，起码在我的认知中多了一项“工作与生活”的平衡。\r\n\r\n接下来，在工作上，我希望能更进一步。\r\n\r\n在生活上，我只希望可以继续保持健康，并且能常常感受快乐就好。\r\n\r\n# 技术与学习\r\n\r\n2019年，另外一个对于我最明显的变化，就是我开源了一个flutter项目 [flutter-todos](https://github.com/asjqkkkk/flutter-todos)\r\n\r\n并且截止到今天，已经有了超越1K的star数量，这对于我来说是一种莫大的鼓励，起码证明2018年学习了flutter后辞职换工作不是一个错误的决定。\r\n\r\n同时，这也是我学习路上一份成长的见证\r\n\r\n![image](https://oldchen-blog-1256696029.cos.ap-guangzhou.myqcloud.com/zongjie_2019/003.png)\r\n\r\n当然了，英语我也有学，不过效果看起来还不够明显，也许是时间还不够吧\r\n\r\n![image](https://oldchen-blog-1256696029.cos.ap-guangzhou.myqcloud.com/zongjie_2019/004.png)\r\n\r\n\r\n# 情感与恋爱\r\n\r\n无\r\n\r\n\r\n# 尾\r\n\r\n总结就到这里吧，希望来年更好！","国庆-2019":"---\r\ntitle: 国庆-2019\r\ndate: 2019-10-07 21:49:47\r\nindex_img: /img/guoqing_2019.png\r\ntags: 逢年过节\r\n---\r\n\r\n去年国庆，没有回家，宅在出租屋里，每天打游戏，过的浑浑噩噩。\r\n\r\n今年国庆，终于是决定回家了。回家确实满怀期待，毕竟和家人在一起还是蛮轻松的。\r\n\r\n下面就简单的介绍这七天是如何过的吧\r\n\r\n\r\n## 10月1号\r\n\r\n节假日的火车票似乎都特别难抢，而我抢到的火车票是 **10月2号** 发车的，所以这一天我还待在广州。\r\n\r\n由于前几日新换了住处，宽带的事情尚未办妥，并且旧住处的宽带套餐还未取消，于是一大早就坐公交去了营业厅准备取消业务，等到10点营业厅才正式营业。\r\n\r\n因为是国庆当天，貌似各个地方都在播放北京天安门举行的“中国成立70周年庆典”，举国上下一片欢快景象，在营业厅看了一会儿庆典后终于解决了旧宽带的问题。接下来坐公交车回去，剪了头发，在没有网络的情况下煎熬着无所事事过完了这一天。\r\n\r\n![image](https://oldchen-blog-1256696029.cos.ap-guangzhou.myqcloud.com/guoqing_2019/001.png)\r\n\r\n## 10月2号\r\n\r\n早上5点30就匆匆忙忙起来，洗漱、**如厕**完毕后过了6点，就开始去赶公交车，为了能提前赶上8点多开动的火车。\r\n\r\n车票是卧铺下铺，在火车上百无聊赖的度过10个小时后，终于到了岳阳，然后看着我爸在出口处接我。开车一个半小时左右到了荆州，一群长辈等着吃饭，勉为其难的还要去敬酒，我太讨厌酒的味道了，不过菜吃的还是很多的。\r\n\r\n<video src=\"https://oldchen-blog-1256696029.cos.ap-guangzhou.myqcloud.com/guoqing_2019/002.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://oldchen-blog-1256696029.cos.ap-guangzhou.myqcloud.com/guoqing_2019/003.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n\r\n## 10月3号\r\n\r\n**回老家**\r\n\r\n因为爷爷是去年过世的，老家就奶奶独自一人待着，正好过节有时间回来一趟就去看一下她老人家，顺便带一点吃的喝的。\r\n\r\n八点多吃完炒拉面后就动身了，十点左右到了老家，在一旁听我爸与奶奶交谈，之后顺便帮忙锄了锄地，到了接近12点就回去了。\r\n\r\n这期间听说我爸在老家的一个医生朋友，因为打牌被抓了，我深感诧异，后来听说也是**国庆节指标**的缘故。\r\n\r\n中午在家吃了些非常简单的菜，基本是素菜，味道非常平淡，只吃了一碗饭。\r\n\r\n上一晚是我的一位亲戚请客吃饭，这天晚上是我们家请客，虽然人和昨天的一样，但是今天我没去敬酒了，照样是大吃了一顿。\r\n\r\n![image](https://oldchen-blog-1256696029.cos.ap-guangzhou.myqcloud.com/guoqing_2019/004.png)\r\n\r\n<video src=\"https://oldchen-blog-1256696029.cos.ap-guangzhou.myqcloud.com/guoqing_2019/005.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n\r\n## 10月4号\r\n\r\n\r\n既然是国庆，总是想着要出去玩一下的，毕竟是个假期，总觉得不出去玩就可惜了。\r\n\r\n于是今天一大早便跑去岳阳看了看**岳阳楼**，大人门票价70一位，小孩不要钱。\r\n\r\n进去后花了差不多一个小时左右的时间就将岳阳楼看完了，由于游客稍多，所以也没有排队上景区中的“岳阳楼”。看完后觉得大失所望，一是因为游客较多显得景点过小，二是可看的东西确实不多，感觉这个景点就是一篇“岳阳楼记”的衍生周边产物，还不如旁边的**洞庭湖**来的壮阔\r\n\r\n然后在景点附近吃完一顿二百左右的午饭后就回去了\r\n\r\n晚饭本来打算在家里吃，突然得知原定10月5号一起玩的小伙伴今天晚上就得开车回上海了。于是晚饭就跑出去和小伙伴一起吃，小伙伴请客。\r\n\r\n![image](https://oldchen-blog-1256696029.cos.ap-guangzhou.myqcloud.com/guoqing_2019/006.png)\r\n\r\n![image](https://oldchen-blog-1256696029.cos.ap-guangzhou.myqcloud.com/guoqing_2019/007.png)\r\n\r\n![image](https://oldchen-blog-1256696029.cos.ap-guangzhou.myqcloud.com/guoqing_2019/008.png)\r\n\r\n\r\n## 10月5号\r\n\r\n这天没有什么多余的想法，就想宅在家里打游戏。\r\n\r\n不过早上还是陪同老爸一起去养老院看了一下，也是为了奶奶后面的生活考虑。\r\n\r\n今天的天气气温骤降，和昨天顶着太阳外出的情况截然相反，在养老院穿梭的时候，还下起了蒙蒙细雨。院中的老人有的三五成群围在一起打牌，有的形单影只在轮椅上静坐。\r\n\r\n最后询问了工作人员，养老院的名额目前已经满了，只能等后面看看会不会空出一些位置。于是拿了养老院的宣传单便回家了。\r\n\r\n因为懒得出去，中午我就一个人在外面解决了伙食问题，吃的7元的炒面，加了鸡蛋和火腿。开始觉得挺好吃的，吃着吃着就没了胃口，然后放下筷子和还剩一小半的炒面就走了。\r\n\r\n\r\n到了晚上，老爸的朋友请客，于是我也过去吃了顿好的，坐席中还发现了老爸之前谈到过的因为国庆节打牌被抓了去的朋友，由于在座的都是老爸年轻时玩到现在的朋友，相较于之前陪同其他亲戚长辈们一起吃饭，基本上没有什么压力。\r\n\r\n## 10月6号\r\n\r\n早上7点半起床，准备到岳阳搭乘返回广州的火车。\r\n\r\n这次依旧是卧铺，不过这次变成了中铺，并且火车的环境相较于来时的要脏乱一些。\r\n\r\n在火车上狭窄的中铺内煎熬到了广州，下车时已是晚上9点。坐了公交车抵达住处，洗完睡觉。这一天算是过去了。\r\n\r\n## 10月7号\r\n\r\n起床后称了称体重，重了六斤多，看着体重秤的数字，我不禁陷入沉思。好在后来再次确认时发现是自己算错了，只重了两斤多。我应该高兴吗？\r\n\r\n早上去了营业厅，办理了百兆宽带的业务。终于不用忍受没有网络的环境了。\r\n\r\n下午宽带就可以正常使用了，又是玩了一下午的游戏，只想做个无忧无虑的sb。之后还是一如既往的进行锻炼、洗澡、睡觉。\r\n\r\n我的2019年的国庆节就这样过去了。\r\n\r\n\r\n## 最后\r\n\r\n国庆期间，看着朋友圈里面的美景展览大赛，不禁心痒难耐，想着要去一个好看好玩的地方，结果岳阳的岳阳楼打破的我的幻想。但是能出去玩，我依旧蛮开心的，虽然游玩并不是一件看起来很轻松的事情。\r\n\r\n期待下次和家人出去玩的地点是黄鹤楼，或者张家界吧。\r\n\r\n在此之前，我一直都是一个宅在家里讨厌出门的死宅，但是现在对于旅游没有了抗拒的情绪。想来还得感谢那帮经常约我出去玩的朋友，我不仅变得愿意去旅游，我还变得更黑了。\r\n\r\n也希望自己能一直处于轻松的状态，一边感受生活，一边在生活中自得其乐。\r\n\r\n那么，今年的国庆播客就到此结束啦！","奇思妙想":"---\r\ntitle: 奇思妙想\r\ndate: 2019-09-08 22:30:58\r\nindex_img: /img/my_idea.png\r\ntags: 奇思妙想\r\n---\r\n\r\n# 一闪而过的念头\r\n\r\n由于人类无法控制自己的思想，所以在日常生活里，我的脑袋中经常会冒出一些惊为天人(夸张手法)、莫名其妙、难以琢磨的想法。有的时候，想法的出现是由原因的，比如下雨天忘记带伞我就会想——“如果有传送工具直接避开户外行走就好了”；而有的时候，想法的出现可能是突如其来的，比如说突然想找女朋友然后谈一场说来就来的恋爱???\r\n\r\n\r\n现在，无论是什么想法，只要是我觉得有意思的，我都会将它们记录于此。并且保持长期更新。\r\n\r\n# 脑洞脑洞脑洞\r\n\r\n\r\n让这些想法公之于众吧\r\n\r\n## 马赛克去除工具\r\n\r\n由于常年关注社会新闻的缘故。经常能看到案发视频中，被打上马赛克的“坏人”，而在我的三观中，我是不希望这样的人被打码可，所以去码工具还是有必要的（当然不是用于某些两三个人就演完的电影，想错的小伙伴请自动面壁）\r\n\r\n## 气味记录与气味释放\r\n\r\n因为经常观看美食视频，所以我对美食有着强烈的执念，但是基本上除了卖相以外，我完全无法感受到食物的气味，如果在录视频的时候可以记录气味，在观看视频的时候顺便可以“播放”气味，那样“色香味”的前两者才能被真实感受到吧。\r\n\r\n## 关于5G的猜想\r\n\r\n我希望5G带来的速度，可以让我等游戏玩家非常便捷的玩到游戏。也就是说，云游戏是很有必要的，也许以前玩一款3A大作需要配置高端且笨重的游戏本，那么5G环境下也许只需要一个大屏的平板+蓝牙手柄就可以了。\r\n\r\n期待吧！","开始新的一天吧":"---\r\ntitle: 开始新的一天吧\r\ndate: 2019-09-01 22:15:31\r\nindex_img: /img/new_day.png\r\ntags: 杂谈\r\n---\r\n\r\n# 好久不见\r\n\r\n几个月没有写个人博客了，这次和之前有许多的不同。\r\n\r\n博客的主题被我从 <code>**nexT**</code> 换成了  <code>**Material-T**</code> ,并不是因为 <code>**nexT**</code> 不够好看，恰恰是因为它太简洁出色，用的人实在太多了，所以为了保证一定的“个性”，我选择更换掉主题。正好，现在的主题也是我非常喜欢的。\r\n\r\n<!--more--> \r\n\r\n# 过的好吗\r\n\r\n没有写个人博客的这段时间里，我是有所改变的。\r\n\r\n来到了新的公司，接触了许多非常棒的新同事。也许技术上目前公司没有能够提供太多帮助，但是在程序规范、其他软技能等方面，我的提升是非常明显的。\r\n\r\n这段时间，我花了大概一个多月，牺牲掉个人的下班时间与双休日，总算是完成了一由个Flutter编写的开源app。开源后的一个月，github上的star数从0涨到600多，期间我总是时不时的打开github，像是在开奖一样，紧张又期待的看着star的数量是不是又有所增长。时而失望，时而惊喜。\r\n\r\n然后我逐渐开始讨厌自己这样的状态，因为这太耗费我的精力了，好在之后star数到了500，而我也终于放下了，因为我的目标算是达到了。\r\n\r\n\r\n\r\n# 有何打算\r\n\r\n最近公司搬到了一个新的地方，环境有了极大的改善，再也不用承受拥挤的座位了，并且我也可以骑着放置了三个月的自行车去上班，时间上稳定了不少，也减少了不少。\r\n\r\n不过因为公司架构组织的调整，我也不清楚下一步会发生什么。但是不论接下来会有何动作，我都能够以轻松的态度去面对，也算是没有任何后顾之忧吧。\r\n\r\n在技术上，还是一如既往的保持不断学习，之前是往广度上学，之后应该会在深度上再多费些心思。\r\n\r\n接下来，这个博客就不准备再写技术性的文章了，而是写一些心情类的、生活类的文章。技术文章我会全部放在掘金上，而这个博客，就作为真真正正的个人博客吧，不以服务大众为目的，而是服务自己。\r\n\r\n\r\n# 下次再会\r\n\r\n这次的博客就写到这里了。我要开始过新的日子了！再会.","早睡早起身体好":"---\r\ntitle: 早睡早起身体好\r\ndate: 2019-09-03 22:37:57\r\nindex_img: /img/sleep_early.png\r\ntags: 随笔\r\n---\r\n\r\n今天早晨，上完厕所后称体重，刚好70KG整。\r\n\r\n想想，我已经持续每周锻炼三次有快一年了吧。之前65KG左右的时候是看得到腹肌的，现在已经练的九九归一了。按照我对自己的期待值，我觉得我目前的体重已经不需要再增加了，接下来应该要减脂了。所以我决定把自己的生活习惯更改一下。\r\n\r\n之后的日子里，我要强制自己晚上11:00之前开始躺在床上睡觉，这表示我要结束我五年多每天12:00以后才睡觉的习惯，所以其中艰辛是可以预料到的。但是说到这里，我想我的强迫症会在一定程度上帮助我完成这个任务，当然不是说要11:00就要睡着，这是不可能的，躺着去睡觉就行了。\r\n\r\n由于今天锻炼的原因，所以现在写这篇博客的时候已经快要11点了，计划从今天开始，所以原本每天学习英语的计划就无法执行了(还有点小开心呢!)，这也是在所难免的,谁让我“说到做到”呢！\r\n\r\n接下来的目标，就是体重往65KG靠拢，让我的腹肌不再被脂肪掩盖，当我到时候能明显看到轮廓的时候，就可以开始新的增肌计划了。\r\n\r\n\r\n不多说了，准备睡觉吧！好梦...","杂谈-gun & legal":"---\r\ntitle: 杂谈-gun & legal\r\ndate: 2019-04-16 21:49:47\r\nindex_img: /img/chat_something.png\r\ntags: 杂谈\r\n---\r\n\r\n# sequence\r\n\r\n好久都没有写博客了，久到我几乎要忘了markdown的写作格式。\r\n\r\n当初给自己的目标是每个月至少一篇技术博客，如今看来这个目标因为种种原因而被搁置，好在我每周锻炼三次的习惯一直持续了半年之久。\r\n\r\n<!--more--> \r\n\r\n停写博客的这段时间，我又学了许多新的东西，我的技术旅途上也多了一个新的伙伴——Flutter,相较于原来的Android而言，我实在是太喜欢Flutter了，从这种喜新厌旧的表现上来看，也许我是一个渣男吧？\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E6%9D%82%E8%B0%88/001.jpg)\r\n\r\n# leave\r\n\r\n这一个月里，我经历了离职、(因为离职)请朋友吃饭、面试、朋友(后脚离职)请我们吃饭等各种事情。\r\n\r\n关于这群朋友，我感触颇深，和他们在公司的这段日子里我成长了不少，而我特别感谢的就是他们曾经热情地带领一个刚毕业的大学生融入了公司的环境，不然以那个涉世未深且又颇为内向的大学生的能力，想要达到这种效果可得费好大一番功夫。\r\n\r\n也是因为这群朋友，我比以前优秀了！\r\n\r\n\r\n在这里再次默默祝你们——前程似锦，万事可期！\r\n\r\n\r\n# recent\r\n\r\n上周，面试了整整一个星期，除了周一外，每天两场面试。最赶一次，上午面试完回家刚吃完饭，就要开始下一家的面试，而下一家光是往返就花了我近五个小时。这样的奔波劳碌，直接导致我这周不想再去投递简历，除了上周约了今天下午的面试，这周我再没投过简历。\r\n\r\n我打算休息一下。\r\n\r\n写博客对我而言是一种爱好，也是休息方式之一。不过写这篇博客的主要目的还是想写下我心中的一个想法，一个早已根植心底的想法。\r\n\r\n# idea\r\n\r\n这个想法，很久之前就有过了，只是最近社会上又发生的一些事情，导致我的想法更加清晰、具象。\r\n\r\n这段日子里，发生了好多人尽皆知的社会新闻，比如：\r\n\r\n[【女车主称被迫交纳1.5万金融服务费 奔驰发声明回应】](https://news.163.com/19/0414/20/ECOGCK760001899O.html)\r\n\r\n[【一张图赔2万!视觉中国年赚3亿背后每天15.6起官司】](https://news.163.com/19/0413/04/ECK70O1L0001899N.html)\r\n\r\n\r\n以及和我们程序员相关的996事件：\r\n\r\n[【996.ICU】](https://github.com/996icu/996.ICU/blob/master/README_CN.md)\r\n\r\n\r\n[【刘强东朋友圈回应996：\"混日子的人不是我的兄弟\"】](https://tech.163.com/19/0412/18/ECJ6M1PE00097U7R.html)\r\n\r\n[【马云谈\"996\":能做是一种巨大福气 很多人都没机会】](https://news.163.com/19/0412/18/ECJ56LP00001875P.html)\r\n\r\n在我看来，这些新闻都说明了一个问题：我们离“**法制社会**”还有着很长一段距离！\r\n\r\n而我的想法，就是和这相关的。\r\n\r\n\r\n# idea_origin\r\n\r\n在正式说明这个想法之前，我还是想写一下我是怎么产生这样的想法的。\r\n\r\n**大概是有过一段中二且愤世嫉俗的时期吧。**\r\n\r\n当时经常看到XXX村的干部又对XXX村民做了强取豪夺之事这类的新闻,比如这样：\r\n\r\n[【村支书因货车刮到遮阳棚将司机打死 之后继续打牌】](https://news.163.com/19/0415/11/ECQ4K3SH0001899O.html)\r\n\r\n又或者这样：\r\n\r\n[【\"劫后\"谭秦东称今生绝不入蒙 曾吐槽鸿茅药酒被抓】](http://money.163.com/18/0927/11/DSN633T4002580T4.html)\r\n\r\n那时我是这么想的：\r\n    \r\n    如果这种事情发生在美国，会是这样的结果吗？不会，美国人的持枪率导致他们的自卫能力远远强于其他国家没有武器的人们。\r\n\r\n现在看来，当初的想法过于简单粗暴，因为它会造成许多新的问题，在不持有枪支的情况下，你都能看到类似下面这样的新闻：\r\n\r\n[【江西一男子在校门口持刀伤人 砍伤学生辅警等11人】](http://news.163.com/19/0221/10/E8HJIL0B0001899O.html)\r\n\r\n而如果全民持枪的话，不知道又会出现多少起类似美国的枪支伤人事件。这个想法除了简单粗暴以外，还有一点就是天方夜谭，除了小说里面，现实是不可能出现全民持枪的情况的，永远都不会。\r\n\r\n\r\n# idea_transform\r\n\r\n如果有可以替代枪支用于自卫的武器，那么它一定是 **法律** 。\r\n\r\n同时，法律公正、具备执行力、不带有任何情感，相较于枪支而言，它安全的多。\r\n\r\n不过就如同我之前所说，真正意义上的 **法制社会** 我们还是难以企及。脱离了现实基础去谈论法律的使用无异于建造一所空中楼阁。\r\n\r\n目前的法律显然不具备这些特点：普及性、易用性、服务性。\r\n\r\n普通人想去使用法律，成本与难度还是很高的，就连我这种把技术作为代号的程序员，对法律也是一窍不通。\r\n\r\n所以写到这里，我就要说出我真实的想法了。\r\n\r\n\r\n# I have an idea\r\n\r\n**我希望未来有一家公司，可以实现让人们低成本、便捷的去使用法律**\r\n\r\n对，不是一家机构，是一个公司。就像阿里巴巴一样，本来应该交给银行去做的无现金社会，最后还需要靠马云去实现。而真正的无障碍使用法律的实现，也许只能由非官方非机构的某家公司去做。\r\n\r\n我希望未来不管是谁，一定要出现一家这样的公司，实现这样的目的。\r\n\r\n虽然我很想亲自去做这件事，但是目前而言我没有这个胆量，也没有这么坚定的信念，不过目前关于公司的一些构想，已经在我脑海里有了初步的雏形。\r\n\r\n\r\n# idea blueprint\r\n\r\n<!--公司的终极目的：实现 **法治社会** -->\r\n\r\n<!--公司的主要目的：普及法律知识、降低法律使用成本、提高法律作为武器与防具的力量-->\r\n\r\n下面是我脑海中一个模糊的结构：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E6%9D%82%E8%B0%88/002.png)\r\n\r\n项目的名字就叫 **民律**\r\n\r\n虽然我不知道这样对不对，但是我希望未来我或者其他人可以去完成这个事业。\r\n\r\n而我对于它的发展与结局是这样看待的，最理想的情况就是：生于乱世，匿于盛世。\r\n\r\n当真正处于 **法治社会** 的时候，这样的产品自然也就销声匿迹了，这也是我乐于见到的场景。\r\n\r\n**那么，我心中的想法就此写下，以后我睡觉的时候再不用去花时间考虑这个问题了  :D**\r\n\r\n\r\n# about 996\r\n\r\n最后，关于996谈一下我的看法。\r\n\r\n本来马云在我心中是99分的第一类钦佩的存在，现在因为他的996言论，他只有95分了，第一类目前还有雷军、任正非，都是99分。\r\n\r\n关于996这个问题，我觉得它一定是不适合技术人员的，特别是程序员这个种族。\r\n\r\n因为技术人员的技术是会随着自身的积累慢慢增加的，技术越高的人会越讨厌毫无意义的重复性劳动，也会越追崇高效率的工作，同时他们思考的质量也会逐渐上升。\r\n\r\n拿我自身的经历来说，如果让我全神贯注去敲代码，四个小时后我就会宕机，之后再进行这样高强度的脑力活动，我的效率会大幅度下降，并且工作积极性也会因为脑力下降而跌落。这时候加班反而不能起到正面促进的效果，只是把人带入了一个恶循环当中。\r\n\r\n虽然我不提倡996，但是就像人有三急一样，有的时候项目确实会出现很赶的情况，这时候适当的加班也是没问题的。但我理想的情况应该是这样：项目规划的好，任务安排合理，基本上用不着加班，每天在工作时限内就可以很好的完成任务。如果需要加班，一定不能是长期的，并且加班需要有加班费，而这个加班费，我希望永远不会有拿的机会。\r\n\r\n那关于996就是这样了，人们工作是为了更好的生活，就像人们健身也是为了生活而服务的。现在许多人因为健身耽误了正常的生活状态，反而是本末倒置，就像现在的996一样，得不偿失。\r\n\r\n最后，关于我之前的想法，如果有朝一日我能实现这个想法，我一定推己及人，从自身的行业开始，让955成为常态，如果影响力够大的话，甚至是可以去实行10，5，5的。然而这也只是实现想法后的冰山一角，能改善的东西，还有更多！\r\n\r\n","论国庆节的几种过法":"---\r\ntitle: 论国庆节的几种过法\r\ndate: 2018-10-01 21:49:47\r\nindex_img: /img/play_1.png\r\ntags: 逢年过节\r\n---\r\n\r\n>  中秋刚过才一个星期，国庆就来了。这七天小长假可不能就这样寥寥草草，得好好准备准备看看怎么过才行！\r\n\r\n**下面就介绍一下国庆节的几种过法**\r\n\r\n## 一、干粮\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/%E5%B9%B2%E7%B2%AE.jpg)\r\n\r\n干粮是必不可少的一部分，有了这个，你就不必担心饿死了！\r\n\r\n\r\n## 二、游戏\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/%E6%B8%B8%E6%88%8F.jpg)\r\n\r\n所谓饱暖思淫欲，当你不必为了食物而犯愁之后，你就可以思考自身的娱乐需求了。无论是召唤师峡谷，还是艾泽拉斯大陆，都有承载你欢乐的地方，如果这些地方你不满意，还剩下索尼微软任天堂好些游戏平台呢！\r\n\r\n\r\n## 三、阅读\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/%E9%98%85%E8%AF%BB.jpg)\r\n\r\n劳逸结合一直是一种非常良好的生活方式，游戏玩过头了反而会荒废你的大脑，这时候应该静下心来看看书，文学类、科学类、教材类，各式各样，应有尽有。\r\n\r\n## 四、运动\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/%E8%BF%90%E5%8A%A8.jpg)\r\n\r\n一个人身体要是不好，那多少事情都干不了，学习、娱乐之余，可别忘了运动，毕竟90后的年轻人没几个希望中年发福吧！\r\n\r\n\r\n## 五、出行\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/%E9%AA%91%E8%A1%8C.jpg)\r\n\r\n在家待久了会生霉的，所以出去转转还能让自己保持新鲜！\r\n\r\n而且节日出行也是蛮合理的一件事，如果你真有一颗不安分的心，外面的人山人海又怎能拦得住你？\r\n\r\n\r\n---\r\n\r\n\r\n**那么，国庆节的过法就谈到这里！我要开始享受国庆了！**\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/001.jpeg)\r\n\r\n---\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/002.png)","长鹿游":"---\r\ntitle: 长鹿游\r\ndate: 2019-09-22 18:02:37\r\nindex_img: /img/changlu.png\r\ntags: 旅行\r\n---\r\n\r\n话不多说，看视频吧\r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/wx_camera_1569042496250.mp4\" controls=\"controls\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_184216.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_175551.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_161147.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_161001.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_160411.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_160315.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_155908.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_155542.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_155338.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_154611.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_153858.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_153533.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_152751.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_152520.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_152457.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_152215.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_152057.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_152044.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_151943.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_151651.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_151521.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_151202.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/1569145952431.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/1569145947107.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/1569145943919.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/1569145940209.mp4\" controls=\"controls\" width=\"500\"></video> \r\n\r\n<video src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/1569145936738.mp4\" controls=\"controls\" width=\"500\"></video> ","Activity启动流程分析":"---\r\ntitle: Activity启动流程分析\r\ndate: 2020-03-22 11:38:15\r\nindex_img: /img/activity_start.jpg\r\ntags: 源码系列\r\n---\r\n\r\n\r\n# 序\r\n\r\n前面已经写完了三篇android方面的学习文章啦，而这一篇关于 **Activity的启动流程**，它涉及的源码量非常大并且非常广。\r\n\r\n在阅读源码之前，需要先做好准备工作。因为有的时候android sdk中的源码并不一定可以随心所欲的跳转，这时候你就需要替换一下sdk文件了，可以从这里下载：[android-hidden-api](https://github.com/anggrayudi/android-hidden-api)\r\n> ps:替换之前记得备份哦\r\n\r\n# 引子\r\n\r\n对于 **Activity启动的流程**，这里我们很好去选择一个源码的阅读入口\r\n\r\n那就是我们非常熟悉的：`startActivity(...)` 方法\r\n\r\n\r\n\r\n# App内Activity启动流程\r\n\r\n进入 `startActivity()` 康康吧\r\n\r\n## Activity\r\n\r\n### startActivity(...)\r\n\r\n```\r\n    public void startActivity(Intent intent) { this.startActivity(intent, null); }\r\n    \r\n    public void startActivity(Intent intent, @Nullable Bundle options) {\r\n        if (options != null) {\r\n            startActivityForResult(intent, -1, options);\r\n        } else {\r\n            startActivityForResult(intent, -1);\r\n        }\r\n    }\r\n    \r\n    public void startActivityForResult(@RequiresPermission Intent intent, int requestCode) {\r\n        startActivityForResult(intent, requestCode, null);\r\n    }\r\n    \r\n    public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,\r\n            @Nullable Bundle options) {...}\r\n    \r\n```\r\n\r\n可以看到最终 `startActivity()` 方法会进入 `startActivityForResult(...)` 方法\r\n\r\n### startActivityForResult(...)\r\n\r\n\r\n```\r\n    public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,\r\n            @Nullable Bundle options) {\r\n        if (mParent == null) {\r\n            options = transferSpringboardActivityOptions(options);\r\n            Instrumentation.ActivityResult ar =\r\n                mInstrumentation.execStartActivity(\r\n                    this, mMainThread.getApplicationThread(), mToken, this,\r\n                    intent, requestCode, options);\r\n            if (ar != null) {\r\n                mMainThread.sendActivityResult(\r\n                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),\r\n                    ar.getResultData());\r\n            }\r\n            if (requestCode >= 0) {\r\n                mStartedActivity = true;\r\n            }\r\n\r\n            cancelInputsAndStartExitTransition(options);\r\n        } else {\r\n            ...\r\n        }\r\n    }\r\n```\r\n\r\n上面的代码中根据 `mParent` 是否为 **null** 分了两种情况，关于 `mParent` 的来龙去脉，目前查阅资料得出的结果是由 `ActivityGroup` 遗留下来的代码\r\n\r\n> 而我也通过在主Activity启动另一个Activity的方式测试得 getParent() 的方法打印为null， 也就是 ActivityGroup 已经被 Fragment + Activity 代替掉了\r\n\r\n我们只需要注意 `execStartActivity(...)` 方法即可\r\n\r\n## Instrumentation\r\n\r\n关于 `Instrumentation` 这个类，它主要用于应用的自动化测试，可以看一下这里：[插桩测试](https://source.android.google.cn/compatibility/tests/development/instrumentation?hl=zh-cn)\r\n\r\n我们直接看 `execStartActivity(...)` 方法\r\n\r\n### execStartActivity(...)\r\n\r\n\r\n```\r\n    public ActivityResult execStartActivity(\r\n        Context who, IBinder contextThread, IBinder token, String target,\r\n        Intent intent, int requestCode, Bundle options) {\r\n        IApplicationThread whoThread = (IApplicationThread) contextThread;\r\n        ...//监视器相关\r\n        try {\r\n            intent.migrateExtraStreamToClipData();\r\n            intent.prepareToLeaveProcess(who);\r\n            int result = ActivityManager.getService()\r\n                .startActivity(whoThread, who.getBasePackageName(), intent,\r\n                        intent.resolveTypeIfNeeded(who.getContentResolver()),\r\n                        token, target, requestCode, 0, null, options);\r\n            checkStartActivityResult(result, intent);\r\n        } catch (RemoteException e) {\r\n            throw new RuntimeException(\"Failure from system\", e);\r\n        }\r\n        return null;\r\n    }\r\n```\r\n这里主要关注 `startActivity(...)` 方法，不过在此之前可以看一下 `ActivityManager.getService()` 返回的对象是什么\r\n\r\n\r\n```\r\n    public static IActivityManager getService() {\r\n        return IActivityManagerSingleton.get();\r\n    }\r\n    \r\n    private static final Singleton<IActivityManager> IActivityManagerSingleton =\r\n            new Singleton<IActivityManager>() {\r\n                @Override\r\n                protected IActivityManager create() {\r\n                    final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);\r\n                    final IActivityManager am = IActivityManager.Stub.asInterface(b);\r\n                    return am;\r\n                }\r\n            };\r\n```\r\n\r\n上面的写法除了单例以外，是一个很典型的 **AIDL** 写法，返回的对象是通过 IBinder 对象提供的 **IActivityManager** 引用，而通过 `IActivityManager` 对象，就可以和 `ActivityManagerService` 通信了, 因为 `ActivityManagerService` 是服务端的实现：\r\n\r\n```\r\npublic class ActivityManagerService extends IActivityManager.Stub\r\n        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {...}\r\n```\r\n关于 **AIDL** 的使用与介绍，可以看这篇：[Android 接口定义语言 (AIDL)](https://developer.android.google.cn/guide/components/aidl?hl=zh_cn#Implement)\r\n\r\n接下来，我们就进入 `ActivityManagerService` 去寻找 `startActivity(...)` 的实现吧：\r\n\r\n## ActivityManagerService\r\n\r\n`ActivityManagerService` 是 `Activity` 启动流程中非常关键的一个对象，大家经常能看到它的简称：**AMS**\r\n\r\n那么 `Activity` 启动的流程中它都参与了哪些内容？我们继续往下看\r\n\r\n下面就是一系列的方法调用了\r\n\r\n### startActivity(...) -> startActivityAsUser(...)\r\n\r\n\r\n```\r\n    public final int startActivity(IApplicationThread caller, String callingPackage,\r\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\r\n            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {\r\n        return startActivityAsUser(...);\r\n    }\r\n```\r\n⬇\r\n\r\n```\r\n    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,\r\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\r\n            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {\r\n        return startActivityAsUser(...);\r\n    }\r\n```\r\n⬇\r\n\r\n```\r\n    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,\r\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\r\n            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId,\r\n            boolean validateIncomingUser) {\r\n        enforceNotIsolatedCaller(\"startActivity\");\r\n\r\n        userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,\r\n                Binder.getCallingPid(), Binder.getCallingUid(), \"startActivityAsUser\");\r\n\r\n        // TODO: Switch to user app stacks here.\r\n        return mActivityStartController.obtainStarter(intent, \"startActivityAsUser\")\r\n                ...//这里给ActivityStarter设置各种参数\r\n                .setMayWait(userId)\r\n                .execute();\r\n\r\n    }\r\n```\r\n上面的 `checkTargetUser(...)` 用于检测调用方的权限等，这里就涉及到多用户和Linux的一些知识了，此处就不说了(如果以后会研究Linux的话，再做说明吧)\r\n\r\n后面的 `obtainStarter(...)` 返回的是一个 `ActivityStarter` 对象，看这个类的名字，就知道它是干什么的了，我们进入它的 `execute()` 方法看看\r\n\r\n## ActivityStarter\r\n\r\n### execute()\r\n\r\n```\r\n    int execute() {\r\n        try {\r\n            if (mRequest.mayWait) {\r\n                return startActivityMayWait(...);\r\n            } else {\r\n                return startActivity(...);\r\n            }\r\n        } finally {\r\n            onExecutionComplete();\r\n        }\r\n    }\r\n    \r\n    \r\n```\r\n\r\n这里的 `mRequest.mayWait` 标志位是通过 `setMayWait(int userId)` 方法来更改的\r\n\r\n```\r\n    ActivityStarter setMayWait(int userId) {\r\n        mRequest.mayWait = true;\r\n        mRequest.userId = userId;\r\n\r\n        return this;\r\n    }\r\n```\r\n而我们在之前的 `startActivityAsUser(...)` 中，就调用过了 `setMayWait()` 方法，所以我们接下来会走到 `startActivityMayWait(...)` 中去\r\n\r\n### startActivityMayWait(...)\r\n\r\n这个方法的参数，以及方法体中的代码量非常大，我们只看最关键的流程部分\r\n\r\n\r\n```\r\n    private int startActivityMayWait(IApplicationThread caller, int callingUid,\r\n            String callingPackage, Intent intent, String resolvedType,\r\n            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\r\n            IBinder resultTo, String resultWho, int requestCode, int startFlags,\r\n            ProfilerInfo profilerInfo, WaitResult outResult,\r\n            Configuration globalConfig, SafeActivityOptions options, boolean ignoreTargetSecurity,\r\n            int userId, TaskRecord inTask, String reason,\r\n            boolean allowPendingRemoteAnimationRegistryLookup) {\r\n                \r\n            ...    \r\n            int res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,\r\n                    voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,\r\n                    callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,\r\n                    ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,\r\n                    allowPendingRemoteAnimationRegistryLookup);\r\n            ...        \r\n                \r\n                \r\n    }\r\n```\r\n进入 `startActivity(...)`\r\n\r\n### startActivity(...) -> startActivity(...)\r\n\r\n\r\n```\r\n    private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,\r\n            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,\r\n            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\r\n            IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,\r\n            String callingPackage, int realCallingPid, int realCallingUid, int startFlags,\r\n            SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,\r\n            ActivityRecord[] outActivity, TaskRecord inTask, String reason,\r\n            boolean allowPendingRemoteAnimationRegistryLookup) {\r\n            \r\n            ...\r\n        mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,\r\n                aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,\r\n                callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,\r\n                options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,\r\n                inTask, allowPendingRemoteAnimationRegistryLookup);\r\n            ...\r\n                \r\n    }\r\n```\r\n\r\n进入下一个 `startActivity(...)`，依旧是一个行数非常多的方法体\r\n\r\n```\r\n    private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,\r\n            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,\r\n            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\r\n            IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,\r\n            String callingPackage, int realCallingPid, int realCallingUid, int startFlags,\r\n            SafeActivityOptions options,\r\n            boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity,\r\n            TaskRecord inTask, boolean allowPendingRemoteAnimationRegistryLookup) {\r\n                \r\n        ...        \r\n        return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags,\r\n                true /* doResume */, checkedOptions, inTask, outActivity);\r\n    }\r\n```\r\n进入最后的 `startActivity(...)` \r\n```\r\n    private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord,\r\n                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\r\n                int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,\r\n                ActivityRecord[] outActivity) {\r\n        int result = START_CANCELED;\r\n        try {\r\n            ...\r\n            result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,\r\n                    startFlags, doResume, options, inTask, outActivity);\r\n        } finally {\r\n          ...\r\n        }\r\n\r\n        postStartActivityProcessing(r, result, mTargetStack);\r\n\r\n        return result;\r\n    }\r\n```\r\n这里调用了 `startActivityUnchecked(...)`方法，进去看一看\r\n\r\n\r\n\r\n### startActivityUnchecked(...)\r\n\r\n\r\n```\r\n    private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,\r\n            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\r\n            int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,\r\n            ActivityRecord[] outActivity) {\r\n        ...    \r\n        //根据Activity的启动模式来决定如何启动Activity，比如LAUNCH_SINGLE_TOP或LAUNCH_SINGLE_TASK等    \r\n        ...\r\n        mTargetStack.startActivityLocked(mStartActivity, topFocused, newTask, mKeepCurTransition,\r\n                mOptions);\r\n        if (mDoResume) {\r\n        ...\r\n            mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,\r\n                        mOptions);\r\n        ...\r\n        }\r\n        ...\r\n    }\r\n```\r\n上面的方法中有一个 `mTargetStack` 的 `startActivityLocked(...)` 方法，它是一个 `ActivityStack` 对象，这里的方法并不是去启动一个 `Activity`，而是将要启动的 `Activity` 放入 要展示的 `ActivityStack` 中，并且初始化 `WindowManager` ，而让顶层 `Activity` 获取焦点(也就是让用户看到的那个)的方法就是 `resumeFocusedStackTopActivityLocked(...)`\r\n\r\n## ActivityStackSupervisor\r\n\r\n**Supervisor** 有监管员的意思，所以 `ActivityStackSupervisor` 从名字上来看，是用于监控和管理 `ActivityStack` 的\r\n\r\n### resumeFocusedStackTopActivityLocked(...)\r\n\r\n\r\n```\r\n    boolean resumeFocusedStackTopActivityLocked(\r\n            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) {\r\n\r\n        if (!readyToResume()) {\r\n            return false;\r\n        }\r\n\r\n        if (targetStack != null && isFocusedStack(targetStack)) {\r\n            return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);\r\n        }\r\n\r\n        final ActivityRecord r = mFocusedStack.topRunningActivityLocked();\r\n        if (r == null || !r.isState(RESUMED)) {\r\n            mFocusedStack.resumeTopActivityUncheckedLocked(null, null);\r\n        } else if (r.isState(RESUMED)) {\r\n            // Kick off any lingering app transitions form the MoveTaskToFront operation.\r\n            mFocusedStack.executeAppTransition(targetOptions);\r\n        }\r\n\r\n        return false;\r\n    }\r\n```\r\n\r\n接下来，进入 `ActivityStack` 的 `resumeTopActivityUncheckedLocked(...)` 方法\r\n\r\n## ActivityStack\r\n\r\n### resumeTopActivityUncheckedLocked(...)\r\n\r\n```\r\n    boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {\r\n        if (mStackSupervisor.inResumeTopActivity) {\r\n            return false;\r\n        }\r\n\r\n        boolean result = false;\r\n        try {\r\n            mStackSupervisor.inResumeTopActivity = true;\r\n            result = resumeTopActivityInnerLocked(prev, options);\r\n            ...\r\n        } finally {\r\n            mStackSupervisor.inResumeTopActivity = false;\r\n        }\r\n\r\n        return result;\r\n    }\r\n```\r\n\r\n进入 `resumeTopActivityInnerLocked(...)` 方法\r\n\r\n\r\n```\r\n    private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {\r\n        \r\n        ...\r\n        mStackSupervisor.startSpecificActivityLocked(next, true, true);\r\n        ...\r\n        \r\n    }\r\n```\r\n这个方法体行数依旧非常多，主要是将之前正在运行的最顶层 `Activity` 给 **pause** 掉，然后又返回到 `ActivityStackSupervisor`，并调用其 `startSpecificActivityLocked(...)` 方法\r\n\r\n## ActivityStackSupervisor\r\n\r\n### startSpecificActivityLocked(...)\r\n\r\n\r\n```\r\n    void startSpecificActivityLocked(ActivityRecord r,\r\n            boolean andResume, boolean checkConfig) {\r\n        // Is this activity's application already running?\r\n        ProcessRecord app = mService.getProcessRecordLocked(r.processName,\r\n                r.info.applicationInfo.uid, true);\r\n\r\n        getLaunchTimeTracker().setLaunchTime(r);\r\n\r\n        if (app != null && app.thread != null) {\r\n            try {\r\n                ...\r\n                realStartActivityLocked(r, app, andResume, checkConfig);\r\n                return;\r\n            } catch (RemoteException e) {\r\n                ...\r\n            }\r\n\r\n        }\r\n\r\n        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,\r\n                \"activity\", r.intent.getComponent(), false, false, true);\r\n    }\r\n```\r\n上面判断了两种情况：\r\n- 如果app进程存在，则继续进入 `realStartActivityLocked(...)` 进行下一步操作\r\n- 如果不存在，调用 `ActivityManagerService` 的 `startProcessLocked(...)` 方法去创建进程。这里将会是我们后面要分析的 **app启动流程** 中的一部分\r\n\r\n\r\n所以我这里先看第一种情况\r\n\r\n\r\n### realStartActivityLocked(...)\r\n\r\n\r\n```\r\n    final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,\r\n            boolean andResume, boolean checkConfig) throws RemoteException {\r\n            \r\n                ...\r\n                // Create activity launch transaction.\r\n                final ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,\r\n                        r.appToken);\r\n                clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),\r\n                        System.identityHashCode(r), r.info,\r\n                        // TODO: Have this take the merged configuration instead of separate global\r\n                        // and override configs.\r\n                        mergedConfiguration.getGlobalConfiguration(),\r\n                        mergedConfiguration.getOverrideConfiguration(), r.compat,\r\n                        r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,\r\n                        r.persistentState, results, newIntents, mService.isNextTransitionForward(),\r\n                        profilerInfo));\r\n                ...\r\n\r\n                // Schedule transaction.\r\n                mService.getLifecycleManager().scheduleTransaction(clientTransaction);\r\n                ...\r\n                \r\n    }\r\n```\r\n可以看到，这里主要是通过调用`ActivityManagerService` 中 `ClientLifecycleManager`对象 的 `scheduleTransaction(...)`方法去执行 **启动Activity** 的任务 \r\n\r\n上面需要执行的 `transaction` 对象是 `LaunchActivityItem`，在去了解它的内部构造之前，我们可以看一下 `scheduleTransaction(...)`是如何执行这个对象的。\r\n\r\n## ClientLifecycleManager\r\n\r\n### scheduleTransaction(...)\r\n\r\n\r\n```\r\n    void scheduleTransaction(ClientTransaction transaction) throws RemoteException {\r\n        final IApplicationThread client = transaction.getClient();\r\n        transaction.schedule();\r\n        if (!(client instanceof Binder)) {\r\n            transaction.recycle();\r\n        }\r\n    }\r\n    \r\n    //ClientTransaction.java\r\n    private IApplicationThread mClient;\r\n    public void schedule() throws RemoteException {\r\n        mClient.scheduleTransaction(this);\r\n    }\r\n```\r\n\r\n可以看到 `schedule()` 方法就是调用 `IApplicationThread` 对象的 `scheduleTransaction(...)` 方法，显然，`IApplicationThread` 是 `ApplicationThread` 的客户端代理接口(又是AIDL),我们直接找到 `ApplicationThread` 看看它的实现方法\r\n\r\n## ActivityThread.ApplicationThread\r\n\r\n### scheduleTransaction(...)\r\n\r\n```\r\n        public void scheduleTransaction(ClientTransaction transaction) throws RemoteException {\r\n            ActivityThread.this.scheduleTransaction(transaction);\r\n        }\r\n        \r\n```\r\n因为 `ActivityThread` 继承于 `ClientTransactionHandler`，所以会跳转到 `ClientTransactionHandler` 中。\r\n\r\n## ClientTransactionHandler\r\n\r\n### scheduleTransaction(...)\r\n\r\n\r\n```\r\n    void scheduleTransaction(ClientTransaction transaction) {\r\n        transaction.preExecute(this);\r\n        sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);\r\n    }\r\n```\r\n\r\n可以看到，这里调用了一个 `sendMessage(...)` 方法。因为 `ClientTransactionHandler` 中的 `sendMessage(...)` 是抽象方法，所以我们去子类 `ActivityThread` 找它的实现\r\n\r\n## ActivityThread\r\n\r\n### sendMessage(...)\r\n\r\n\r\n```\r\n    final H mH = new H();\r\n    \r\n    class H extends Handler {...}\r\n\r\n    void sendMessage(int what, Object obj) {\r\n        sendMessage(what, obj, 0, 0, false);\r\n    }\r\n\r\n    private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) {\r\n        Message msg = Message.obtain();\r\n        msg.what = what;\r\n        msg.obj = obj;\r\n        msg.arg1 = arg1;\r\n        msg.arg2 = arg2;\r\n        if (async) {\r\n            msg.setAsynchronous(true);\r\n        }\r\n        mH.sendMessage(msg);\r\n    }\r\n```\r\n可以看到，最终就是调用内部的一个名为 **H** 的 **Handler** 对象发送了 **Message**，接下来就需要寻找 `what` 值为 `ActivityThread.H.EXECUTE_TRANSACTION` 的处理逻辑了：\r\n\r\n### case EXECUTE_TRANSACTION:\r\n\r\n\r\n```\r\n\r\n    private final TransactionExecutor mTransactionExecutor = new TransactionExecutor(this);\r\n    \r\n    \r\n                case EXECUTE_TRANSACTION:\r\n                    final ClientTransaction transaction = (ClientTransaction) msg.obj;\r\n                    mTransactionExecutor.execute(transaction);\r\n                    if (isSystem()) {\r\n                        transaction.recycle();\r\n                    }\r\n                    break;\r\n```\r\n接下来，就看一下 `execute(...)` 方法\r\n\r\n## TransactionExecutor\r\n\r\n### execute(...)\r\n\r\n\r\n```\r\n    public void execute(ClientTransaction transaction) {\r\n        final IBinder token = transaction.getActivityToken();\r\n\r\n        executeCallbacks(transaction);\r\n\r\n        executeLifecycleState(transaction);\r\n        mPendingActions.clear();\r\n    }\r\n```\r\n看一看 `executeCallbacks(...)` 方法\r\n\r\n\r\n```\r\n    public void executeCallbacks(ClientTransaction transaction) {\r\n        final List<ClientTransactionItem> callbacks = transaction.getCallbacks();\r\n        ...\r\n\r\n        final int size = callbacks.size();\r\n        for (int i = 0; i < size; ++i) {\r\n            final ClientTransactionItem item = callbacks.get(i);\r\n            ...\r\n\r\n            item.execute(mTransactionHandler, token, mPendingActions);\r\n            item.postExecute(mTransactionHandler, token, mPendingActions);\r\n            ...\r\n        }\r\n    }\r\n```\r\n这么看来，是执行所有 `ClientTransactionItem` 对象的 `execute(...)` 和 `postExecute(...)` 方法。到这里，我们就可以看一下之前在 `realStartActivityLocked(...)` 方法中添加的 `LaunchActivityItem` 对象了。\r\n\r\n\r\n\r\n## LaunchActivityItem\r\n\r\n由于没有在 `LaunchActivityItem` 中找到 `postExecute(...)`，应该是没有重写这个方法。所以我们只用看 `execute(...)` \r\n\r\n\r\n### execute(...)\r\n\r\n```\r\n    public void execute(ClientTransactionHandler client, IBinder token,\r\n            PendingTransactionActions pendingActions) {\r\n        Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\");\r\n        ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo,\r\n                mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,\r\n                mPendingResults, mPendingNewIntents, mIsForward,\r\n                mProfilerInfo, client);\r\n        client.handleLaunchActivity(r, pendingActions, null /* customIntent */);\r\n        Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);\r\n    }\r\n```\r\n可以看到这里新建了一个 `ActivityClientRecord` 对象，接着我们进入 `handleLaunchActivity(...)` 来看一看。很明显，这个方法在 `ClientTransactionHandler` 的子类 `ActivityThread` 中实现\r\n\r\n\r\n\r\n## ActivityThread\r\n\r\n### handleLaunchActivity(...)\r\n\r\n\r\n```\r\n    public Activity handleLaunchActivity(ActivityClientRecord r,\r\n            PendingTransactionActions pendingActions, Intent customIntent) {\r\n        ...    \r\n        final Activity a = performLaunchActivity(r, customIntent);\r\n        ...\r\n        return a;\r\n    }\r\n```\r\n\r\n进入 `performLaunchActivity(...)`\r\n\r\n### performLaunchActivity...)\r\n\r\n```\r\n    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\r\n        ...\r\n        Activity activity = null;\r\n        try {\r\n            java.lang.ClassLoader cl = appContext.getClassLoader();\r\n            activity = mInstrumentation.newActivity(\r\n                    cl, component.getClassName(), r.intent);\r\n            ...\r\n        } catch (Exception e) {\r\n            ...\r\n        }\r\n        ...\r\n        try {\r\n            if (activity != null) {\r\n                ...\r\n                activity.attach(appContext, this, getInstrumentation(), r.token,\r\n                        r.ident, app, r.intent, r.activityInfo, title, r.parent,\r\n                        r.embeddedID, r.lastNonConfigurationInstances, config,\r\n                        r.referrer, r.voiceInteractor, window, r.configCallback);\r\n                ...\r\n                if (r.isPersistable()) {\r\n                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\r\n                } else {\r\n                    mInstrumentation.callActivityOnCreate(activity, r.state);\r\n                }\r\n                ...\r\n            }\r\n        } catch (SuperNotCalledException e) {\r\n            throw e;\r\n\r\n        }\r\n        ...\r\n        return activity;\r\n\r\n    }\r\n```\r\n\r\n可以看到，在这里通过 `Instrumentation.newActivity(...)` 创建了一个新的 **Activity** ，深入其中会发现是调用了 `Class.newInstance()`通过反射的方式来创建。之后就是 **Activity** 初始化时的一些其他初始化，包括生命周期的运行了。这里限于篇幅，我们就放在下一篇再讲吧！\r\n\r\n那么，到这里，这一篇的关于 **Activity的启动流程** 分析就到此结束啦！\r\n\r\n# App启动流程\r\n\r\n来到之前 `ActivityStackSupervisor` 中 `startSpecificActivityLocked(...)` 的分叉点，其实**app启动流程**的前部分和**Activity启动流程**的前部分是重叠的。我们将从这里开始，来分析一下 **app启动流程的后半段** 。接下来我们看一下 `startProcessLocked(...)` 方法\r\n\r\n## ActivityManagerService\r\n\r\n### startProcessLocked(...)\r\n\r\n\r\n```\r\n    final ProcessRecord startProcessLocked(String processName,\r\n            ApplicationInfo info, boolean knownToBeDead, int intentFlags,\r\n            String hostingType, ComponentName hostingName, boolean allowWhileBooting,\r\n            boolean isolated, boolean keepIfLarge) {\r\n        return startProcessLocked(...);\r\n    }\r\n```\r\n进入下一个 `startProcessLocked(...)` 方法\r\n\r\n\r\n```\r\n    final ProcessRecord startProcessLocked(String processName, ApplicationInfo info,\r\n            boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName,\r\n            boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,\r\n            String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) {\r\n        \r\n        if (app == null) {\r\n            checkTime(startTime, \"startProcess: creating new process record\");\r\n            app = newProcessRecordLocked(info, processName, isolated, isolatedUid);\r\n            ...\r\n        }\r\n        ...\r\n        final boolean success = startProcessLocked(app, hostingType, hostingNameStr, abiOverride);\r\n        checkTime(startTime, \"startProcess: done starting proc!\");\r\n        return success ? app : null;\r\n    }\r\n```\r\n可以看到，当 **app** 进程为 **null** 时，会创建一个新的。最后调用了另外一个 `startProcessLocked(...)` 方法\r\n\r\n我们看看另一个 `startProcessLocked(...)`\r\n\r\n```\r\n    private final boolean startProcessLocked(ProcessRecord app,\r\n            String hostingType, String hostingNameStr, String abiOverride) {\r\n        return startProcessLocked(app, hostingType, hostingNameStr,\r\n                false /* disableHiddenApiChecks */, abiOverride);\r\n    }\r\n```\r\n又一个\r\n\r\n\r\n```\r\n    private final boolean startProcessLocked(ProcessRecord app, String hostingType,\r\n            String hostingNameStr, boolean disableHiddenApiChecks, String abiOverride) {\r\n            ...\r\n            final String entryPoint = \"android.app.ActivityThread\";\r\n            \r\n            return startProcessLocked(hostingType, hostingNameStr, entryPoint, app, uid, gids,\r\n                    runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith,\r\n                    startTime);\r\n            ...        \r\n    }\r\n```\r\n注意上面的 **entryPoint** ，它将会是后面程序的入口\r\n\r\n然后继续进入下一个 `startProcessLocked(...)`\r\n\r\n```\r\n    private boolean startProcessLocked(String hostingType, String hostingNameStr, String entryPoint,\r\n            ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,\r\n            String seInfo, String requiredAbi, String instructionSet, String invokeWith,\r\n            long startTime) {\r\n            ...\r\n                    final ProcessStartResult startResult = startProcess(app.hostingType, entryPoint,\r\n                            app, app.startUid, gids, runtimeFlags, mountExternal, app.seInfo,\r\n                            requiredAbi, instructionSet, invokeWith, app.startTime);\r\n            ...\r\n    }\r\n```\r\n现在，进入 `startProcess(...)` 方法\r\n\r\n### startProcess(...)\r\n\r\n\r\n```\r\n    private ProcessStartResult startProcess(String hostingType, String entryPoint,\r\n            ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,\r\n            String seInfo, String requiredAbi, String instructionSet, String invokeWith,\r\n            long startTime) {\r\n        try {\r\n            ...\r\n            final ProcessStartResult startResult;\r\n            if (hostingType.equals(\"webview_service\")) {\r\n                startResult = startWebView(...);\r\n            } else {\r\n                startResult = Process.start(...);\r\n            }\r\n            checkTime(startTime, \"startProcess: returned from zygote!\");\r\n            return startResult;\r\n        } finally {\r\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\r\n        }\r\n    }\r\n```\r\n上面分了两种进程启动，其中就有我们比较熟知的 `WebView` 的进程，这个就暂时不用管了。\r\n\r\n而 **entryPoint** 就是之前所提到的进程入口 `android.app.ActivityThread`\r\n\r\n在之前，我们分析 `Handler` 的时候，发现 **app主线程** 就是在 `ActivityThread` 的 `main()` 中初始化的。所以关于 `ActivityThread` 我们先放一边，解决了 `Process` 的流程再来看\r\n\r\n接下来直接看 `Process.start(...)` 方法\r\n\r\n## Process\r\n\r\n### start(...)\r\n\r\n\r\n```\r\n    public static final ZygoteProcess zygoteProcess =\r\n            new ZygoteProcess(ZYGOTE_SOCKET, SECONDARY_ZYGOTE_SOCKET);\r\n            \r\n    public static final ProcessStartResult start(final String processClass,\r\n                                  final String niceName,\r\n                                  int uid, int gid, int[] gids,\r\n                                  int runtimeFlags, int mountExternal,\r\n                                  int targetSdkVersion,\r\n                                  String seInfo,\r\n                                  String abi,\r\n                                  String instructionSet,\r\n                                  String appDataDir,\r\n                                  String invokeWith,\r\n                                  String[] zygoteArgs) {\r\n        return zygoteProcess.start(processClass, niceName, uid, gid, gids,\r\n                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,\r\n                    abi, instructionSet, appDataDir, invokeWith, zygoteArgs);\r\n    }\r\n```\r\n这里出现了一个 `zygoteProcess` 对象，是不是听说过这个进程很多次了？我们接着往下看\r\n\r\n## ZygoteProcess\r\n\r\n### start(...)\r\n\r\n\r\n```\r\n    public final Process.ProcessStartResult start(final String processClass,\r\n                                                  final String niceName,\r\n                                                  int uid, int gid, int[] gids,\r\n                                                  int runtimeFlags, int mountExternal,\r\n                                                  int targetSdkVersion,\r\n                                                  String seInfo,\r\n                                                  String abi,\r\n                                                  String instructionSet,\r\n                                                  String appDataDir,\r\n                                                  String invokeWith,\r\n                                                  String[] zygoteArgs) {\r\n        try {\r\n            return startViaZygote(processClass, niceName, uid, gid, gids,\r\n                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,\r\n                    abi, instructionSet, appDataDir, invokeWith, false /* startChildZygote */,\r\n                    zygoteArgs);\r\n        } catch (ZygoteStartFailedEx ex) {\r\n            Log.e(LOG_TAG,\r\n                    \"Starting VM process through Zygote failed\");\r\n            throw new RuntimeException(\r\n                    \"Starting VM process through Zygote failed\", ex);\r\n        }\r\n    }\r\n```\r\n\r\n进入 `startViaZygote(...)`\r\n\r\n### `startViaZygote(...)`\r\n\r\n\r\n```\r\n    private Process.ProcessStartResult startViaZygote(final String processClass,\r\n                                                      final String niceName,\r\n                                                      final int uid, final int gid,\r\n                                                      final int[] gids,\r\n                                                      int runtimeFlags, int mountExternal,\r\n                                                      int targetSdkVersion,\r\n                                                      String seInfo,\r\n                                                      String abi,\r\n                                                      String instructionSet,\r\n                                                      String appDataDir,\r\n                                                      String invokeWith,\r\n                                                      boolean startChildZygote,\r\n                                                      String[] extraArgs)\r\n                                                      throws ZygoteStartFailedEx {\r\n                                          \r\n        ...                                              \r\n        argsForZygote.add(processClass);\r\n        ...\r\n        \r\n        synchronized(mLock) {\r\n            return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);\r\n        }                                              \r\n    }\r\n```\r\n\r\n上面的 `processClass` 就是我们之前传入的 `entryPoint`，也就是 `android.app.ActivityThread`\r\n\r\n而 `openZygoteSocketIfNeeded(abi)` 方法会尝试去开启一个 `LocalSocket` 进行通信\r\n\r\n### openZygoteSocketIfNeeded(String abi)\r\n\r\n```\r\n    private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {\r\n        Preconditions.checkState(Thread.holdsLock(mLock), \"ZygoteProcess lock not held\");\r\n        ...\r\n        secondaryZygoteState = ZygoteState.connect(mSecondarySocket);\r\n        ...\r\n    }\r\n    \r\n        public static ZygoteState connect(LocalSocketAddress address) throws IOException {\r\n            DataInputStream zygoteInputStream = null;\r\n            BufferedWriter zygoteWriter = null;\r\n            final LocalSocket zygoteSocket = new LocalSocket();\r\n\r\n            try {\r\n                zygoteSocket.connect(address);\r\n\r\n                zygoteInputStream = new DataInputStream(zygoteSocket.getInputStream());\r\n\r\n                zygoteWriter = new BufferedWriter(new OutputStreamWriter(\r\n                        zygoteSocket.getOutputStream()), 256);\r\n            } catch (IOException ex) {\r\n                try {\r\n                    zygoteSocket.close();\r\n                } catch (IOException ignore) {\r\n                }\r\n\r\n                throw ex;\r\n            }\r\n\r\n            String abiListString = getAbiList(zygoteWriter, zygoteInputStream);\r\n\r\n            return new ZygoteState(zygoteSocket, zygoteInputStream, zygoteWriter,\r\n                    Arrays.asList(abiListString.split(\",\")));\r\n        }\r\n```\r\n可以看到，数据都被保存在了 `ZygoteState` 中了\r\n\r\n上面关于 `Socket` 的部分就先放下，主要为下面的内容做铺垫。 接下来，进入之前的 `zygoteSendArgsAndGetResult(...)`\r\n\r\n### zygoteSendArgsAndGetResult(...)\r\n\r\n\r\n```\r\n    private static Process.ProcessStartResult zygoteSendArgsAndGetResult(\r\n            ZygoteState zygoteState, ArrayList<String> args)\r\n            throws ZygoteStartFailedEx {\r\n            \r\n            ...\r\n            /**\r\n             * See com.android.internal.os.SystemZygoteInit.readArgumentList()\r\n             * Presently the wire format to the zygote process is:\r\n             * a) a count of arguments (argc, in essence)\r\n             * b) a number of newline-separated argument strings equal to count\r\n             *\r\n             * After the zygote process reads these it will write the pid of\r\n             * the child or -1 on failure, followed by boolean to\r\n             * indicate whether a wrapper process was used.\r\n             */\r\n            final BufferedWriter writer = zygoteState.writer;\r\n            final DataInputStream inputStream = zygoteState.inputStream;\r\n\r\n            writer.write(Integer.toString(args.size()));\r\n            writer.newLine();\r\n\r\n            for (int i = 0; i < sz; i++) {\r\n                String arg = args.get(i);\r\n                writer.write(arg);\r\n                writer.newLine();\r\n            }\r\n\r\n            writer.flush();\r\n\r\n            // Should there be a timeout on this?\r\n            Process.ProcessStartResult result = new Process.ProcessStartResult();\r\n\r\n            result.pid = inputStream.readInt();\r\n            result.usingWrapper = inputStream.readBoolean();\r\n\r\n            if (result.pid < 0) {\r\n                throw new ZygoteStartFailedEx(\"fork() failed\");\r\n            }\r\n            return result;\r\n            ...\r\n    }\r\n```\r\n从上面的逻辑来看，`zygoteSendArgsAndGetResult(...)` 方法是通过 **Socket** 通信的方式将数据传到了接收方，那么这个接收方在哪里呢？\r\n\r\n上面的注释中，提示是在 `com.android.internal.os.SystemZygoteInit` 中的 `readArgumentList()` 方法，但是一番寻找后，并没有发现这个类。不过倒是在同目录下找到了 `ZygoteInit` 类，想必这里是注释错误？（后来查阅相关资料，发现的确如此）\r\n\r\n那么，我们就先进入 `ZygoteInit` 一探究竟吧，看看它到底在哪里\r\n\r\n## ZygoteInit\r\n\r\n先从 `main(...)` 方法开始看起\r\n\r\n### main(...)\r\n\r\n```\r\n    public static void main(String argv[]) {\r\n        ZygoteServer zygoteServer = new ZygoteServer();\r\n        ...\r\n        zygoteServer.registerServerSocketFromEnv(socketName);\r\n        ...\r\n        try {\r\n            ...\r\n            if (startSystemServer) {\r\n                Runnable r = forkSystemServer(abiList, socketName, zygoteServer);\r\n                if (r != null) {\r\n                    r.run();\r\n                    return;\r\n                }\r\n            }\r\n            caller = zygoteServer.runSelectLoop(abiList);\r\n        } catch (Throwable ex) {\r\n    \r\n            throw ex;\r\n        }\r\n        ...\r\n    }\r\n```\r\n上面我们主要关注 `runSelectLoop(...)` 方法\r\n\r\n## ZygoteServer\r\n\r\n### runSelectLoop(String abiList)\r\n\r\n\r\n```\r\n    Runnable runSelectLoop(String abiList) {\r\n        \r\n        ...\r\n        while (true) {\r\n            ...\r\n            for (int i = pollFds.length - 1; i >= 0; --i) {\r\n                ...\r\n                        ZygoteConnection connection = peers.get(i);\r\n                        final Runnable command = connection.processOneCommand(this);\r\n                ...\r\n            }\r\n            \r\n        }\r\n        ...\r\n        \r\n    }\r\n```\r\n我们看一下 `ZygoteConnection` 的 `processOneCommand(...)` 方法\r\n\r\n## ZygoteConnection\r\n\r\n### processOneCommand(ZygoteServer zygoteServer)\r\n\r\n\r\n```\r\n    Runnable processOneCommand(ZygoteServer zygoteServer) {\r\n        String args[];\r\n        ...\r\n        try {\r\n            args = readArgumentList();\r\n            descriptors = mSocket.getAncillaryFileDescriptors();\r\n        } catch (IOException ex) {\r\n            throw new IllegalStateException(\"IOException on command socket\", ex);\r\n        }\r\n        ...\r\n        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,\r\n                parsedArgs.runtimeFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,\r\n                parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.startChildZygote,\r\n                parsedArgs.instructionSet, parsedArgs.appDataDir);\r\n\r\n        try {\r\n            if (pid == 0) {\r\n                ...\r\n                return handleChildProc(parsedArgs, descriptors, childPipeFd,\r\n                        parsedArgs.startChildZygote);\r\n            } else {\r\n                ...\r\n                handleParentProc(pid, descriptors, serverPipeFd);\r\n                return null;\r\n            }\r\n        } finally {\r\n            ...\r\n        }\r\n        ...\r\n    }\r\n```\r\n上面有一个 `readArgumentList()` 方法，和之前在 `zygoteSendArgsAndGetResult(...)` 中的注释一样，我们来看一看：\r\n\r\n\r\n```\r\n    private String[] readArgumentList()\r\n            throws IOException {\r\n\r\n        /**\r\n         * See android.os.Process.zygoteSendArgsAndGetPid()\r\n         * Presently the wire format to the zygote process is:\r\n         * a) a count of arguments (argc, in essence)\r\n         * b) a number of newline-separated argument strings equal to count\r\n         *\r\n         * After the zygote process reads these it will write the pid of\r\n         * the child or -1 on failure.\r\n         */\r\n\r\n        int argc;\r\n\r\n        try {\r\n            String s = mSocketReader.readLine();\r\n\r\n            if (s == null) {\r\n                // EOF reached.\r\n                return null;\r\n            }\r\n            argc = Integer.parseInt(s);\r\n        } catch (NumberFormatException ex) {\r\n            Log.e(TAG, \"invalid Zygote wire format: non-int at argc\");\r\n            throw new IOException(\"invalid wire format\");\r\n        }\r\n        ...\r\n\r\n        String[] result = new String[argc];\r\n        for (int i = 0; i < argc; i++) {\r\n            result[i] = mSocketReader.readLine();\r\n            if (result[i] == null) {\r\n                // We got an unexpected EOF.\r\n                throw new IOException(\"truncated request\");\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n```\r\n可以看到，上面明显也是一个 **Socket** 通信的方式，并且注释中的内容和之前的是对应的。所以可以确定这里对之前传递过来的信息进行了处理，其中就包含 `ActivityThread.main` 入口\r\n\r\n接下来，继续看 `processOneCommand(...)` 剩下的内容：\r\n\r\n当 `forkAndSpecialize(...)` 方法返回的pid为0时，表示是fork出来的子进程；如果是父进程，会返回-1或是报错\r\n\r\n我们看一下 `handleChildProc(...)`\r\n\r\n### handleChildProc(...)\r\n\r\n\r\n```\r\n    private Runnable handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors,\r\n            FileDescriptor pipeFd, boolean isZygote) {\r\n        ...\r\n        if (parsedArgs.invokeWith != null) {\r\n            WrapperInit.execApplication(parsedArgs.invokeWith,\r\n                    parsedArgs.niceName, parsedArgs.targetSdkVersion,\r\n                    VMRuntime.getCurrentInstructionSet(),\r\n                    pipeFd, parsedArgs.remainingArgs);\r\n\r\n            // Should not get here.\r\n            throw new IllegalStateException(\"WrapperInit.execApplication unexpectedly returned\");\r\n        } else {\r\n            if (!isZygote) {\r\n                return ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs,\r\n                        null /* classLoader */);\r\n            } else {\r\n                return ZygoteInit.childZygoteInit(parsedArgs.targetSdkVersion,\r\n                        parsedArgs.remainingArgs, null /* classLoader */);\r\n            }\r\n        }\r\n    }\r\n```\r\n关于 `invokeWith` 这个参数，它是在 `ActivityManagerService` 的 `startProcessLocked(...)` 方法被赋值的：\r\n\r\n```\r\n            String invokeWith = null;\r\n            if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {\r\n                // Debuggable apps may include a wrapper script with their library directory.\r\n                String wrapperFileName = app.info.nativeLibraryDir + \"/wrap.sh\";\r\n                StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();\r\n                try {\r\n                    if (new File(wrapperFileName).exists()) {\r\n                        invokeWith = \"/system/bin/logwrapper \" + wrapperFileName;\r\n                    }\r\n                } finally {\r\n                    StrictMode.setThreadPolicy(oldPolicy);\r\n                }\r\n            }\r\n```\r\n也就是只有当调试的app目录中包含一个脚本程序时，才会给它赋值。所以我就不考虑这个情况了\r\n\r\n还剩下 `isZygote` 参数，它是 `ZygoteConnection.Arguments` 中的 `startChildZygote` 变量，在 `ZygoteProcess` 的 `start(...)` 方法中被赋值\r\n\r\n\r\n```\r\n          return startViaZygote(processClass, niceName, uid, gid, gids,\r\n                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,\r\n                    abi, instructionSet, appDataDir, invokeWith, false /* startChildZygote */,\r\n                    zygoteArgs);\r\n```\r\n其中的 **false** 就是。所以 `handleChildProc(...)` 中，我们只关注 `ZygoteInit.zygoteInit(...)` 方法就行了\r\n\r\n又来到 `ZygoteInit`\r\n\r\n## ZygoteInit\r\n\r\n### zygoteInit(...)\r\n\r\n\r\n```\r\n    public static final Runnable zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) {\r\n        ...\r\n        ZygoteInit.nativeZygoteInit();\r\n        return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);\r\n    }\r\n```\r\n看一下 `RuntimeInit.applicationInit(...)` 方法\r\n\r\n## RuntimeInit\r\n\r\n### applicationInit(...)\r\n\r\n\r\n```\r\n    protected static Runnable applicationInit(int targetSdkVersion, String[] argv,\r\n            ClassLoader classLoader) {\r\n        ...\r\n\r\n        final Arguments args = new Arguments(argv);\r\n\r\n        // The end of of the RuntimeInit event (see #zygoteInit).\r\n        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\r\n\r\n        // Remaining arguments are passed to the start class's static main\r\n        return findStaticMain(args.startClass, args.startArgs, classLoader);\r\n    }\r\n```\r\n看起来 `findStaticMain(...)` 就是 `main` 方法的入口了\r\n\r\n### findStaticMain(...)\r\n\r\n```\r\n    protected static Runnable findStaticMain(String className, String[] argv,\r\n            ClassLoader classLoader) {\r\n        Class<?> cl;\r\n\r\n        try {\r\n            cl = Class.forName(className, true, classLoader);\r\n        } catch (ClassNotFoundException ex) {\r\n            ...\r\n        }\r\n\r\n        Method m;\r\n        try {\r\n            m = cl.getMethod(\"main\", new Class[] { String[].class });\r\n        } catch (NoSuchMethodException ex) {\r\n            ...\r\n        } catch (SecurityException ex) {\r\n            ...\r\n        }\r\n\r\n        int modifiers = m.getModifiers();\r\n        ...\r\n\r\n        return new MethodAndArgsCaller(m, argv);\r\n    }\r\n    \r\n    static class MethodAndArgsCaller implements Runnable {\r\n        /** method to call */\r\n        private final Method mMethod;\r\n\r\n        /** argument array */\r\n        private final String[] mArgs;\r\n\r\n        public MethodAndArgsCaller(Method method, String[] args) {\r\n            mMethod = method;\r\n            mArgs = args;\r\n        }\r\n\r\n        public void run() {\r\n            try {\r\n                mMethod.invoke(null, new Object[] { mArgs });\r\n            } catch (IllegalAccessException ex) {\r\n                throw new RuntimeException(ex);\r\n            } catch (InvocationTargetException ex) {\r\n                ...\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n显然，这里是通过反射的方式，来调用 `main()` 方法，从而启动 `ActivityThread` ，那么至此 **Zygote** 相关的内容就分析到这里了。\r\n\r\n接下来，我们看一下 `ActivityThread` 中，是在哪里启动 **首个Activity** 的\r\n\r\n## ActivityThread\r\n\r\n### main(...)\r\n\r\n```\r\n    public static void main(String[] args) {\r\n        ...\r\n        Looper.prepareMainLooper();\r\n        ...\r\n        ActivityThread thread = new ActivityThread();\r\n        thread.attach(false, startSeq);\r\n        ...\r\n        Looper.loop();\r\n    }\r\n```\r\n`Looper` 相关的内容，之前已在 **Handler源码分析** 中已经分析过，这里就不再赘述了。我们进入 `attach(...)` 方法一探究竟\r\n\r\n### attach(...)\r\n\r\n```\r\n    final ApplicationThread mAppThread = new ApplicationThread();\r\n\r\n    private void attach(boolean system, long startSeq) {\r\n        ...\r\n        if (!system) {\r\n            ...\r\n            RuntimeInit.setApplicationObject(mAppThread.asBinder());\r\n            final IActivityManager mgr = ActivityManager.getService();\r\n            try {\r\n                mgr.attachApplication(mAppThread, startSeq);\r\n            } catch (RemoteException ex) {\r\n                throw ex.rethrowFromSystemServer();\r\n            }\r\n            ...\r\n        } else {\r\n            ...\r\n        }\r\n        ...\r\n    }\r\n```\r\n因为传过来的 `system` 为 **false**，所以这里只考虑第一个 **if** 逻辑\r\n\r\n进入 `attachApplication(...)` 看一看，因为是 `ActivityManagerService` 的代理，所以直接 `ActivityManagerService` 找对应的方法\r\n\r\n## ActivityManagerService\r\n\r\n### attachApplication(...)\r\n\r\n\r\n```\r\n    @Override\r\n    public final void attachApplication(IApplicationThread thread, long startSeq) {\r\n        synchronized (this) {\r\n            int callingPid = Binder.getCallingPid();\r\n            final int callingUid = Binder.getCallingUid();\r\n            final long origId = Binder.clearCallingIdentity();\r\n            attachApplicationLocked(thread, callingPid, callingUid, startSeq);\r\n            Binder.restoreCallingIdentity(origId);\r\n        }\r\n    }\r\n```\r\n然后看一下 `attachApplicationLocked(...)`\r\n\r\n### attachApplicationLocked(...)\r\n\r\n又是一个超长的方法体\r\n\r\n```\r\n    private final boolean attachApplicationLocked(IApplicationThread thread,\r\n            int pid, int callingUid, long startSeq) {\r\n        ...\r\n                thread.bindApplication(processName, appInfo, providers,\r\n                        app.instr.mClass,\r\n                        profilerInfo, app.instr.mArguments,\r\n                        app.instr.mWatcher,\r\n                        app.instr.mUiAutomationConnection, testMode,\r\n                        mBinderTransactionTrackingEnabled, enableTrackAllocation,\r\n                        isRestrictedBackupMode || !normalMode, app.persistent,\r\n                        new Configuration(getGlobalConfiguration()), app.compat,\r\n                        getCommonServicesLocked(app.isolated),\r\n                        mCoreSettingsObserver.getCoreSettingsLocked(),\r\n                        buildSerial, isAutofillCompatEnabled);\r\n        ...\r\n       // See if the top visible activity is waiting to run in this process...\r\n        if (normalMode) {\r\n            try {\r\n                if (mStackSupervisor.attachApplicationLocked(app)) {\r\n                    didSomething = true;\r\n                }\r\n            } catch (Exception e) {\r\n                Slog.wtf(TAG, \"Exception thrown launching activities in \" + app, e);\r\n                badApp = true;\r\n            }\r\n        }\r\n    }\r\n```\r\n上面的第一个部分是 `bindApplication(...)` 方法，显然和 **Application** 有关，因为 `IApplicationThread` 是 `ActivityThread` 中 `ApplicationThread` 的代理，所以我们直接在里面寻找相关方法\r\n\r\n## ActivityThread.ApplicationThread\r\n\r\n### bindApplication(...)\r\n\r\n\r\n```\r\n        public final void bindApplication(String processName, ApplicationInfo appInfo,\r\n                List<ProviderInfo> providers, ComponentName instrumentationName,\r\n                ProfilerInfo profilerInfo, Bundle instrumentationArgs,\r\n                IInstrumentationWatcher instrumentationWatcher,\r\n                IUiAutomationConnection instrumentationUiConnection, int debugMode,\r\n                boolean enableBinderTracking, boolean trackAllocation,\r\n                boolean isRestrictedBackupMode, boolean persistent, Configuration config,\r\n                CompatibilityInfo compatInfo, Map services, Bundle coreSettings,\r\n                String buildSerial, boolean autofillCompatibilityEnabled) {\r\n            ...\r\n            sendMessage(H.BIND_APPLICATION, data);\r\n        }\r\n```\r\n\r\n根据这个 `BIND_APPLICATION` 继续下一步\r\n\r\n\r\n```\r\n                case BIND_APPLICATION:\r\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\");\r\n                    AppBindData data = (AppBindData)msg.obj;\r\n                    handleBindApplication(data);\r\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\r\n                    break;\r\n```\r\n得到 `handleBindApplication(...)` 方法\r\n\r\n### handleBindApplication(...)\r\n\r\n\r\n```\r\n    private void handleBindApplication(AppBindData data) {\r\n        ...\r\n        final InstrumentationInfo ii;\r\n        ...\r\n        if (ii != null) {\r\n            ...\r\n                mInstrumentation = (Instrumentation)\r\n                    cl.loadClass(data.instrumentationName.getClassName()).newInstance();\r\n            ...\r\n        } else {\r\n            mInstrumentation = new Instrumentation();\r\n            mInstrumentation.basicInit(this);\r\n        }\r\n        ...\r\n        Application app;\r\n        ...\r\n            app = data.info.makeApplication(data.restrictedBackupMode, null);\r\n        ...\r\n                mInstrumentation.onCreate(data.instrumentationArgs);\r\n        ...\r\n                mInstrumentation.callApplicationOnCreate(app);\r\n        ...\r\n    }\r\n```\r\n上面创建了 `Application` 实例，以及 `Instrumentation` 实例。关于绑定 `Application` 就看到这里\r\n\r\n\r\n接着我们来看一下之前 `attachApplicationLocked` 中的 `attachApplicationLocked(...)` 方法，显然这和 `Activity` 启动有关\r\n\r\n## ActivityStackSupervisor\r\n\r\n### attachApplicationLocked(...)\r\n\r\n\r\n```\r\n    boolean attachApplicationLocked(ProcessRecord app) throws RemoteException {\r\n        ...\r\n                final int size = mTmpActivityList.size();\r\n                for (int i = 0; i < size; i++) {\r\n                    final ActivityRecord activity = mTmpActivityList.get(i);\r\n                    if (activity.app == null && app.uid == activity.info.applicationInfo.uid\r\n                            && processName.equals(activity.processName)) {\r\n                        try {\r\n                            if (realStartActivityLocked(activity, app,\r\n                                    top == activity /* andResume */, true /* checkConfig */)) {\r\n                                didSomething = true;\r\n                            }\r\n                        } catch (RemoteException e) {\r\n                            ...\r\n                        }\r\n                    }\r\n                }\r\n        ...\r\n        return didSomething;\r\n    }\r\n```\r\n显然， 这里调用了 `realStartActivityLocked(...)` 方法，也就是说从这里开始，又回到了前面分析 **Activity启动流程** 的环节中，我们所有的分析已经形成一个环了！\r\n\r\n那么这篇文章的分析部分，就到这里结束啦！\r\n\r\n\r\n\r\n# 总结\r\n\r\n一开始只想了解一下 **Activity的启动流程**，可是看到中途又不知不觉进入了 **app启动流程** 的坑。看源码就是这样，千丝万缕的关系，最后汇成一个大的体系。\r\n\r\n下面做个简单的总结吧：\r\n\r\n- 流程中的几处跳转，都是通过AIDL来实现的。分别是 `IApplicationThread` 和 `IActivityManager`。\r\n    - `IApplicationThread` 是AMS请求app进程的接口，它的实现是在 `ActivityThread` 中的 `ApplicationThread`\r\n    - `IActivityManager` 是app进程请求AMS的接口，它的实现就是AMS：`ActivityManagerService` 啦\r\n- 在app的启动流程中，通过 **Socket通信** 传递启动相关信息，来启动 `ActivityThread` \r\n\r\n文字总结大概就是这样，剩下的就看图片吧，方便多了\r\n\r\n## Activity 启动流程\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/activity_start/activity_start.png)\r\n\r\n## App启动流程\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/activity_start/app_start.png)","Android Studio自定义模板实现一键创建MVP结构":"---\ntitle: Android Studio自定义模板实现一键创建MVP结构\ndate: 2018-12-02 21:49:47\nindex_img: /img/create_mvp.png\ntags: Android\n---\n\n# 前言\r\n\r\n之前有写过关于如何使用 DataBinding 的两篇文章，不仅仅是为了消灭掉一部分重复代码，更是为了提高开发效率。详情可以点击下方的传送门  \r\n[DataBinding——从路人到好友（一）：初遇](https://oldchen.top/2018/10/17/DataBinding%E2%80%94%E2%80%94%E4%BB%8E%E8%B7%AF%E4%BA%BA%E5%88%B0%E5%A5%BD%E5%8F%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%88%9D%E9%81%87/)  \r\n[DataBinding——从相识到相知（二）：互酌](https://oldchen.top/2018/10/20/DataBinding%E2%80%94%E2%80%94%E4%BB%8E%E7%9B%B8%E8%AF%86%E5%88%B0%E7%9B%B8%E7%9F%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BA%92%E9%85%8C/)\r\n\r\n<!--more--> \r\n\r\n而这篇文章主要介绍的就是如何通过 Android Studio 提供的模版功能去自定义模版结构，从而实现类似于一键创建整个MVP代码的功能。可以说在提高效率的道路上，又向前走了一大步\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/001.jpg)\r\n\r\n下面可以来看一看具体效果：\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/002.gif)\r\n\r\n# 介绍\r\n\r\n在 Android Studio 中，创建一个 Activity 可以直接通过 **File -> New -> Activity** 来进行选择创建\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/003.png)\r\n\r\n通过这种方式创建的 Activity 会自动在 AndroidManifest.xml 中完成注册，创建其他组件也可以通过这种方式。\r\n\r\n不过，如果你正在使用某种开发模式，譬如 **MVP、MVVM** 等，你每创建一个 Activity 就意味着需要同时创建一系列其他相关的类。\r\n\r\n为了避免这种毫无意义的重复性劳动，我们可以编写模板代码去实现一键创建重复代码。\r\n\r\n# 开始\r\n\r\n下面我们就来开始模版的编写吧。\r\n\r\n首先，找到你的 **Android Studio** 的安装目录，然后根据这个目录找到 **...\\templates** 目录：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/004.png)\r\n\r\n然后进入 **activityes** 目录，我们将要编写的各种模版就在这个目录内：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/005.png)\r\n\r\n要说如何去编写模版代码，一开始我也是一无所知的，不过好在 Android Studio 已经为我们提供了这些例子，我们直接参考例子去写。\r\n\r\n就拿最简单的 **Empty Activity** 来开始吧\r\n\r\n进入到 **EmptyActivity** 目录\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/006.png)\r\n\r\n## globals.xml.ftl\r\n\r\n打开 **globals.xml.ftl** 文件，下面是它的内容：\r\n\r\n```\r\n<?xml version=\"1.0\"?>\r\n<globals>\r\n    <global id=\"hasNoActionBar\" type=\"boolean\" value=\"false\" />\r\n    <global id=\"parentActivityClass\" value=\"\" />\r\n    <global id=\"simpleLayoutName\" value=\"${layoutName}\" />\r\n    <global id=\"excludeMenu\" type=\"boolean\" value=\"true\" />\r\n    <global id=\"generateActivityTitle\" type=\"boolean\" value=\"false\" />\r\n    <#include \"../common/common_globals.xml.ftl\" />\r\n</globals>\r\n\r\n```\r\n\r\n根据文件名来看， **globals.xml.ftl** 的作用是用来控制一些全局变量，比如是否显示 **ActionBar** 等，暂且先不用管它\r\n\r\n## recipe.xml.ftl\r\n\r\n **recipe.xml.ftl** 文件内容如下：\r\n \r\n```\r\n<?xml version=\"1.0\"?>\r\n<#import \"root://activities/common/kotlin_macros.ftl\" as kt>\r\n<recipe>\r\n    <#include \"../common/recipe_manifest.xml.ftl\" />\r\n    <@kt.addAllKotlinDependencies />\r\n\r\n<#if generateLayout>\r\n    <#include \"../common/recipe_simple.xml.ftl\" />\r\n    <open file=\"${escapeXmlAttribute(resOut)}/layout/${layoutName}.xml\" />\r\n</#if>\r\n\r\n    <instantiate from=\"root/src/app_package/SimpleActivity.${ktOrJavaExt}.ftl\"\r\n                   to=\"${escapeXmlAttribute(srcOut)}/${activityClass}.${ktOrJavaExt}\" />\r\n    <open file=\"${escapeXmlAttribute(srcOut)}/${activityClass}.${ktOrJavaExt}\" />\r\n\r\n</recipe>\r\n\r\n```\r\n\r\n第一段\r\n\r\n        <#import \"root://activities/common/kotlin_macros.ftl\" as kt>\r\n\r\n就是用于导入Kotlin的相关命令，同时它的别名为 **kt**\r\n\r\n主要还是注意 **instantiate** 代码块中的相关信息， 其中 **${ktOrJavaExt}** 表示当你创建模版的时候，创建的 **.java** 文件还是 **.kt** 文件，而相对应的，你需要在编写模版例子的时候分别写上对应的两份 **Java** 与 **Kotlin** 代码\r\n\r\n**open** 代码块就是创建模版后，默认打开的文件\r\n\r\n# template.xml\r\n\r\n**template.xml** 代码略长，这里只是贴出了大致代码\r\n\r\n```\r\n<?xml version=\"1.0\"?>\r\n<template\r\n    format=\"5\"\r\n    revision=\"5\"\r\n    name=\"Empty Activity\"\r\n    minApi=\"9\"\r\n    minBuildApi=\"14\"\r\n    description=\"Creates a new empty activity\">\r\n\r\n    <category value=\"Activity\" />\r\n    <formfactor value=\"Mobile\" />\r\n\r\n    <parameter\r\n        id=\"activityClass\"\r\n        name=\"Activity Name\"\r\n        type=\"string\"\r\n        constraints=\"class|unique|nonempty\"\r\n        suggest=\"${layoutToActivity(layoutName)}\"\r\n        default=\"MainActivity\"\r\n        help=\"The name of the activity class to create\" />\r\n        \r\n        \r\n        ...\r\n\r\n    <!-- 128x128 thumbnails relative to template.xml -->\r\n    <thumbs>\r\n        <!-- default thumbnail is required -->\r\n        <thumb>template_blank_activity.png</thumb>\r\n    </thumbs>\r\n\r\n    <globals file=\"globals.xml.ftl\" />\r\n    <execute file=\"recipe.xml.ftl\" />\r\n\r\n</template>\r\n\r\n```\r\n我们挑出其中的重点来说\r\n\r\n```\r\n<category value=\"Activity\" />\r\n```\r\n表示当前的这个模版的分类，当前的 **Value** 是 **Activity** ，就表示它会出现在 **File -> New -> Activity** 中，这个是可以自定义的.\r\n\r\n```\r\n        <thumbs>\r\n        <!-- default thumbnail is required -->\r\n        <thumb>template_blank_activity.png</thumb>\r\n        </thumbs>\r\n```\r\n**thumbs** 用于指定创建模版时所展示出来的图片\r\n\r\n而最重要的，还是 **parameter** 代码块的内容了，在这之中，我们只需要关注以下几个，其他的顾名思义即可。\r\n\r\n\r\n```\r\n    <parameter\r\n        id=\"activityClass\"\r\n        name=\"Activity Name\"\r\n        type=\"string\"\r\n        constraints=\"class|unique|nonempty\"\r\n        suggest=\"${layoutToActivity(layoutName)}\"\r\n        default=\"MainActivity\"\r\n        help=\"The name of the activity class to create\" />\r\n\r\n```\r\n**activityClass** 表示所要创建的 Activity ，其中 **default** 为默认名。\r\n\r\n\r\n```\r\n    <parameter\r\n        id=\"generateLayout\"\r\n        name=\"Generate Layout File\"\r\n        type=\"boolean\"\r\n        default=\"true\"\r\n        help=\"If true, a layout file will be generated\" />\r\n```\r\n上面的代码块表示是否同时自动创建一个Activity对应的布局\r\n\r\n\r\n```\r\n  <parameter\r\n        id=\"layoutName\"\r\n        name=\"Layout Name\"\r\n        type=\"string\"\r\n        constraints=\"layout|unique|nonempty\"\r\n        suggest=\"${activityToLayout(activityClass)}\"\r\n        default=\"activity_main\"\r\n        visibility=\"generateLayout\"\r\n        help=\"The name of the layout to create for the activity\" />\r\n```\r\n **layoutName** 则表示布局的名字，这里的 **suggest** 属性所填写的内容即为布局名，**${activityToLayout(activityClass)}**则为跟随Activity的名字，其中 **activityClass** 是Activity名字的引用\r\n \r\n 剩下的不用再作说明，基本上可以见名知意。\r\n \r\n# 模版代码\r\n\r\n接下来我们从 **EmptyActivity** 中的 **root** 目录一直进入，直到看到下面两个文件\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/007.png)\r\n\r\n可以看到，一个后缀是 **java.ftl** 另外一个后缀是 **kt.ftl**，他们分别用于创建 Java模版与Kotlin模版，如果你暂时不使用Kotlin的话，可以不用去关心 Kotlin模版，当你完成了Java模版的编写，也可以使用 Android Studio自带的转换功能，还是蛮方便的。\r\n\r\n下面来看一下Java的模版代码：\r\n\r\n```\r\npackage ${packageName};\r\n\r\nimport ${superClassFqcn};\r\nimport android.os.Bundle;\r\n<#if (includeCppSupport!false) && generateLayout>\r\nimport android.widget.TextView;\r\n</#if>\r\n\r\npublic class ${activityClass} extends ${superClass} {\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n<#if generateLayout>\r\n        setContentView(R.layout.${layoutName});\r\n       <#include \"../../../../common/jni_code_usage.java.ftl\">\r\n<#elseif includeCppSupport!false>\r\n\r\n        // Example of a call to a native method\r\n        android.util.Log.d(\"${activityClass}\", stringFromJNI());\r\n</#if>\r\n    }\r\n<#include \"../../../../common/jni_code_snippet.java.ftl\">\r\n}\r\n\r\n```\r\n- ${packageName}：表示当前包名\r\n- ${activityClass}：表示当前的Activity名字\r\n- ${superClass}：表示继承的Activity，同时为了让这个父类生效，需要在import中加入${superClassFqcn}\r\n- ${layoutName}：当前Activity所对应的布局名\r\n\r\n目前我们只需要关注上面这部分，接下来可以看一下我们实际想要创建的MVP结构：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/008.png)\r\n\r\n编写模版代码前，最好的方式是先写一遍例子，然后对照例子去替换关键名部分，这样做是最轻松的。\r\n\r\n下面就来看一看具体的实现吧：\r\n\r\n# 样例代码\r\n\r\n\r\n## 接口部分：TestActivityContact\r\n\r\n\r\n```\r\npackage com.example.testcustomtemplates.contact;\r\n\r\npublic interface TestActivityContact {\r\n    interface Presenter<T> {\r\n        void succeed(T t);\r\n        void failed(T t);\r\n        void error(Throwable e);\r\n        void subscribe();\r\n        void unSubscribe();\r\n    }\r\n\r\n    interface View<T> {\r\n        void setPresenter(Presenter presenter);\r\n        void succeed(T t);\r\n        void failed(T t);\r\n        void error(Throwable e);\r\n    }\r\n    \r\n    interface Model {\r\n        void setPresenter(Presenter presenter);\r\n    }\r\n}\r\n```\r\n为了方便测试，这里并没有另外创建一些基类接口，可以看到上面代码中分别对应 MVP 结构中三个模块的接口，写的是最基本的需求方法，不过 MVP 也不都是完全一样的，这里你可以定义自己想写的方法。\r\n\r\n## Model层：TestActivityModel\r\n\r\n\r\n```\r\npackage com.example.testcustomtemplates.model;\r\n\r\nimport android.content.Context;\r\nimport com.example.testcustomtemplates.contact.TestActivityContact;\r\n\r\npublic class TestActivityModel implements TestActivityContact.Model {\r\n\r\n    private Context context;\r\n    private TestActivityContact.Presenter mPresenter;\r\n\r\n    public TestActivityModel(Context context) {\r\n        this.context = context;\r\n    }\r\n\r\n    @Override\r\n    public void setPresenter(TestActivityContact.Presenter presenter) {\r\n        this.mPresenter = presenter;\r\n    }\r\n}\r\n```\r\nModel层主要就是做一些网络请求，存储之类的数据相关操作，不可以持有对View的引用，他是通过Presenter去和View进行交互的。\r\n\r\n## Presenter层：TestActivityPresenter\r\n\r\n\r\n```\r\npackage com.example.testcustomtemplates.presenter;\r\n\r\nimport android.content.Context;\r\nimport com.example.testcustomtemplates.contact.TestActivityContact;\r\nimport com.example.testcustomtemplates.model.TestActivityModel;\r\n\r\npublic class TestActivityPresenter<T> implements TestActivityContact.Presenter<T> {\r\n\r\n    private TestActivityContact.View mView;\r\n    private TestActivityModel mModel;\r\n    private Context context;\r\n\r\n    public TestActivityPresenter(TestActivityContact.View mView, Context context) {\r\n        this.mView = mView;\r\n        this.context = context;\r\n        mModel = new TestActivityModel(context);\r\n\r\n    }\r\n    @Override\r\n    public void succeed(T t) {\r\n\r\n    }\r\n    @Override\r\n    public void failed(T t) {\r\n\r\n    }\r\n    @Override\r\n    public void error(Throwable e) {\r\n\r\n    }\r\n    @Override\r\n    public void subscribe() {\r\n\r\n    }\r\n    @Override\r\n    public void unSubscribe() {\r\n\r\n    }\r\n}\r\n```\r\nPresenter层自然不必多说，他最好是不要持有View控件的引用，大部分的逻辑操作需要他来完成，不过不可避免的，如果业务逻辑复杂了，Presenter层也会变得臃肿，这也是MVP结构的一个短处。\r\n\r\n## View层：TestActivity\r\n\r\n```\r\npackage com.example.testcustomtemplates.activity;\r\n\r\nimport android.support.v7.app.AppCompatActivity;\r\nimport android.os.Bundle;\r\nimport com.example.testcustomtemplates.R;\r\nimport com.example.testcustomtemplates.contact.TestActivityContact;\r\nimport com.example.testcustomtemplates.presenter.TestActivityPresenter;\r\n\r\npublic class TestActivity<T> extends AppCompatActivity implements TestActivityContact.View<T> {\r\n\r\n    private TestActivityContact.Presenter mPresenter;\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_test);\r\n        new TestActivityPresenter<T>(this, this);\r\n    }\r\n\r\n    @Override\r\n    public void setPresenter(TestActivityContact.Presenter presenter) {\r\n        this.mPresenter = presenter;\r\n    }\r\n\r\n    @Override\r\n    public void succeed(T t) {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void failed(T t) {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void error(Throwable e) {\r\n\r\n    }\r\n}\r\n\r\n```\r\nActivity或者Fragment都可以用作View层，这层主要是对一些视图控件的状态进行切换，不做复杂的逻辑操作。\r\n\r\n看完上面的这些代码后，其实就可以开始直接编写我们的模版代码了。\r\n\r\n# 模版编写\r\n\r\n首先，可以Copy一份 **EmptyActivity** 整个模版的文件，然后改一下名字，随便什么都可以，这里我将其改成 **MvpDemoActivity**\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/009.png)\r\n\r\n然后我们首先对 **template.xml** 文件进行修改，主要修改下面这个部分：\r\n\r\n\r\n```\r\n<category value=\"Activity\" />\r\n```\r\n然后是对 **recipe.xml.ftl** 文件进行修改，修改后如下：\r\n\r\n\r\n```\r\n<?xml version=\"1.0\"?>\r\n<#import \"root://activities/common/kotlin_macros.ftl\" as kt>\r\n<recipe>\r\n    <#include \"../common/recipe_manifest.xml.ftl\" />\r\n    <@kt.addAllKotlinDependencies />\r\n\r\n<#if generateLayout>\r\n    <#include \"../common/recipe_simple.xml.ftl\" />\r\n    <open file=\"${escapeXmlAttribute(resOut)}/layout/${layoutName}.xml\" />\r\n</#if>\r\n\r\n\t<!--View-activity-->\r\n    <instantiate from=\"root/src/app_package/MvpActivity.java.ftl\"\r\n                   to=\"${escapeXmlAttribute(srcOut)}/activity/${activityClass}.java\" />\r\n\t<!--Model-->\r\n\t<instantiate from=\"root/src/app_package/MvpModel.java.ftl\"\r\n                   to=\"${escapeXmlAttribute(srcOut)}/model/${activityClass}Model.java\" />\t\r\n\t<!--Contact-->\r\n\t<instantiate from=\"root/src/app_package/MvpContact.java.ftl\"\r\n                   to=\"${escapeXmlAttribute(srcOut)}/contact/${activityClass}Contact.java\" />\r\n\t<!--Presenter-->\r\n\t<instantiate from=\"root/src/app_package/MvpPresenter.java.ftl\"\r\n                   to=\"${escapeXmlAttribute(srcOut)}/presenter/${activityClass}Presenter.java\" />\t   \r\n    <open file=\"${escapeXmlAttribute(srcOut)}/activity/${activityClass}.java\" />\r\n\r\n</recipe>\r\n\r\n```\r\n\r\n上面的代码表示只编写了Java版，当然你在修改这个文件之前还是需要创建相对应的几个类的模版代码的。这里出于篇幅考虑暂时就不贴出实际的模版代码了，下面会给出github地址，编写了Java版和Kotlin版的，大家可以拿去参考\r\n\r\n[Github项目链接](https://github.com/asjqkkkk/TemplatesTest)\r\n\r\n当然，有好的模版也可以一起分享一下\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/010.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","Android开发者编写自己的API接口：从零开始（一）":"---\r\ntitle: Android开发者编写自己的API接口：从零开始（一）\r\ndate: 2018-08-05 21:49:47\r\nindex_img: /img/api_1.png\r\ntags: Android\r\n---\r\n\r\n## 序\r\n\r\n作为一名Android开发人员，想要实现对一些数据的操作和展示，可以通过一些提供Api接口的网站去获取，虽然Api市场上种类繁多，不过别人提供的接口未必就是自己想要的，到最后，还是得自己去实现Api接口。\r\n\r\n毕竟，最了解自己需求的人，还得是自己。\r\n\r\n## 准备\r\n\r\n很多小伙伴应该都会有着类似的需求，不过想去做的时候，常常无从下手。\r\n\r\n所以这里做了一个整合，关于如何搭建开发环境，以及所需工具的下载等。\r\n\r\n\r\n参考文章：\r\n\r\n- [Android程序员搭建一个属于自己的服务器，不再求各种公共API](https://www.jianshu.com/p/4a0d40806ea2)\r\n- [JAVA后台搭建(springboot+mybatis+mysql)项目搭建](https://www.jianshu.com/p/f91ca5814bcf)\r\n\r\n## 步骤\r\n\r\n一套开发环境下来，需要下面这些步骤：\r\n\r\n- 1：搭建开发环境，IntelliJ + spring-boot + mybatis\r\n- 2：搭建数据库，mysql + navicat\r\n- 3：搭建运行环境，tomcat + 腾讯云（或者阿里云）\r\n\r\n\r\n## 开始\r\n\r\n### 一、搭建开发环境\r\n\r\n\r\n#### 1.1 IntelliJ IDEA的安装\r\n\r\nAndroid开发者所使用的Android studio是基于这个IDEA开发的，所以两者的界面非常非常相似。\r\n\r\n而且现在比较流行的Android开发语言Kotlin也是由IntelliJ IDEA的开发公司JetBrains所开发的。\r\n\r\n##### 下载 IntelliJ IDEA\r\n\r\n首先，下载安装包——[【IntelliJ下载地址】](https://www.jetbrains.com/idea/download/#section=windows)\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001.png)\r\n\r\n##### 安装 IntelliJ IDEA\r\n\r\n下载完成后，就开始安装了\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-001.png)\r\n\r\nNext到下面的界面，可以自行选择\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-002.png)\r\n\r\n\r\n然后一直下一步，到可以运行IDEA，然后你应该会遇到需要购买的提示，破解的教程请看：\r\n\r\n[Windows7下安装与破解IntelliJ IDEA2017](https://blog.csdn.net/yangying496875002/article/details/73603303)\r\n\r\nwin10也是适用的。\r\n\r\n\r\n#### 1.2 MySQL的安装\r\n\r\n##### 下载MySQL\r\n\r\n这里使用的是mysql-5.7.17.msi，下载地址是：\r\n\r\n[MYSQL下载地址](https://downloads.mysql.com/archives/installer/)\r\n\r\n\r\n##### 安装MySQL\r\n\r\n下载完成后进行安装：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-006.png)\r\n\r\n这里只选择了Server\r\n\r\n然后一直下一步\r\n\r\n到了设置密码这里，我设置的密码是【oldchen】,后面项目配置的密码也是这个，这里你可以随便设置自己的密码，不过后面配置的时候要保证密码输入一致就是：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-007.png)\r\n\r\n\r\n然后一直下一步，直到安装成功，接下来就是如何去操作数据库。\r\n\r\n\r\n#### 1.3 Navicat的安装\r\n\r\nNavicat用来对数据库进行操作，也是需要付费购买的，破解地址：\r\n[Navicat for MySQL 安装和破解（完美）](https://blog.csdn.net/wypersist/article/details/79834490)\r\n\r\n\r\n可以使用之后，来到如下界面：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-008.png)\r\n\r\n然后创建MYSQL连接：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-009.png)\r\n\r\n输入相关信息：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-010.png)\r\n\r\n然后就可以看到创建的连接了，右键→新建数据库：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-011.png)\r\n\r\n\r\n新建的数据库名字设置为oldchen,接下来双击这个数据库，新建一个user表,表中包含account,password,username以及自增主键id，具体操作如图所示：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/gif/001.gif)\r\n\r\n\r\n创建这个表后，我们可以添加一条数据：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-012.png)\r\n\r\n\r\n然后，开始配置IntelliJ IDEA\r\n\r\n#### 1.4 IntelliJ IDEA的配置\r\n\r\n\r\n##### 搭建SpringBoot项目\r\n\r\n打开IntelliJ，左上角 File → New → Project，创建新项目：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-013.png)\r\n\r\n\r\n然后\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-004.png)\r\n\r\n\r\n接下来是选择依赖的界面，选中图中的全部依赖\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-005.png)\r\n\r\n下一步\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-019.png)\r\n\r\n\r\n开始项目构建，需要等待一定的时间，构建完成后的项目结构是这样的：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-015.png)\r\n\r\n\r\n结合之前新建的数据库，在resources目录下的application.properties中进行配置：\r\n\r\n\r\n```\r\n#oldchen为创建的数据库名字\r\nspring.datasource.url =jdbc:mysql://localhost:3306/oldchen\r\nmybatis.type-aliases-package = com.example.demo\r\n# 数据库用户名\r\nspring.datasource.username = root\r\n# 数据库密码\r\nspring.datasource.password = oldchen\r\n\r\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\r\n\r\n#端口号\r\nspring.session.store-type=none\r\nspring.http.encoding.charset=UTF-8\r\n```\r\n\r\n接下来就开始写接口啦\r\n\r\n\r\n#### 1.5 接口的编写\r\n\r\n\r\n由于我们之前在操作名为【oldchen】的数据库时，还新建了一个【user】表，所以这里先创建一个User类：\r\n\r\n\r\n```\r\npublic class User {\r\n    private Integer id;\r\n    private String account;\r\n    private String password;\r\n    private String userName;\r\n\r\n    public Integer getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(Integer id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getAccount() {\r\n        return account;\r\n    }\r\n\r\n    public void setAccount(String account) {\r\n        this.account = account;\r\n    }\r\n\r\n    public String getPassword() {\r\n        return password;\r\n    }\r\n\r\n    public void setPassword(String password) {\r\n        this.password = password;\r\n    }\r\n\r\n    public String getUserName() {\r\n        return userName;\r\n    }\r\n\r\n    public void setUserName(String userName) {\r\n        this.userName = userName;\r\n    }\r\n}\r\n```\r\n\r\n\r\n然后创建UserMapper，用于查询（根据字段account查询）\r\n\r\n\r\n```\r\n@Mapper\r\npublic interface UserMapper {\r\n\r\n    @Select(\"select * from user where account = #{account}\")\r\n    User findByAccount(String account);\r\n\r\n}\r\n```\r\n\r\n\r\n接着创建UserController，用于对数据的处理：\r\n\r\n\r\n```\r\n@RestController\r\n@RequestMapping({\"/user\"})\r\npublic class UserController {\r\n\r\n    @Autowired\r\n    private UserMapper userMapper;\r\n\r\n    @RequestMapping(value=\"/user\")\r\n    @ResponseBody\r\n    public String getUserInfoByName(String account) {\r\n        User user = userMapper.findByAccount(account);\r\n        if (user == null){\r\n            return \"用户名保不存在\";\r\n        } else {\r\n            return \"用户名存在——\" + user.getUserName();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n最后项目结构如下：\r\n\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-016.png)\r\n\r\n\r\n### 二、测试接口\r\n\r\n首先，运行项目\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-017.png)\r\n\r\n\r\n当项目正常运行后，测试下面的地址：\r\n\r\nhttp://localhost:8080/user/user?account=oldchen\r\n\r\n结果：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-018.png)\r\n\r\n测试成功啦！\r\n\r\n\r\n## 后续\r\n\r\n\r\n关于Api接口的学习，先到这里。\r\n\r\n后面还会写关于如何将项目放在TomCat上，最后放在云服务器上，通过外网地址访问接口\r\n\r\n那么，未完待续...\r\n\r\n\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%A1%A8%E6%83%85%E5%8C%85/%E5%91%8A%E8%BE%9E.jpg)\r\n\r\n\r\n\r\n\r\n","Android开发者编写自己的API接口：从零开始（二）":"---\r\ntitle: Android开发者编写自己的API接口：从零开始（二）\r\ndate: 2018-08-14 21:49:47\r\nindex_img: /img/api_2.png\r\ntags: Android\r\n---\r\n\r\n## 前言\r\n\r\n\r\n\r\n在上一篇[Android开发者编写自己的API接口（上）](https://oldchen.top/2018/08/05/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/)中，已经介绍了如何搭建一个基本的开发环境，以及接口的编写，最后是能够成功运行的。\r\n\r\n这一篇将更进一步，主要解决下面两个问题：\r\n\r\n- ①：如何让后台项目运行在TomCat上\r\n- ②：如何在云服务器上部署自己的项目\r\n    \r\n## Start\r\n\r\n#### 一、本地Tomcat的使用\r\n\r\n##### 1.1、安装Tomcat\r\n使用TomCat，自然是要TomCat的安装包咯\r\n\r\n[安装包下载地址](https://tomcat.apache.org/download-90.cgi)\r\n\r\n![image](\r\nhttps://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/001.png)\r\n\r\n由于我们本地应该都是已经安装配置过JDK了的，所以安装Tomcat的时候一路Next就行了\r\n\r\n\r\n##### 1.2、配置Gradle\r\n首先，在项目的gradle所在的目录下创建gradle.properties，然后在里面添加：\r\n```\r\n# true就去打包War，否则不打包\r\nBUILD_WAR=true\r\n```\r\n![image](\r\nhttps://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/002.png)\r\n\r\n接着在build.gradle中添加：\r\n\r\n\r\n```\r\nif (BUILD_WAR.toBoolean()) {\r\n    apply plugin: 'war'\r\n}\r\n\r\ndependencies {\r\n    ...\r\n    if (BUILD_WAR.toBoolean()) {\r\n        providedRuntime('org.springframework.boot:spring-boot-starter-tomcat')\r\n    }\r\n}\r\n```\r\n![image](\r\nhttps://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/003.png)\r\n\r\n同时，不要忘了创建一个ServletInitializer类，用于SpringBoot的初始化\r\n\r\n```\r\npublic class ServletInitializer extends SpringBootServletInitializer {\r\n\r\n\t@Override\r\n\tprotected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\r\n\t\treturn application.sources(TestForDemoApplication.class);\r\n\t}\r\n\r\n}\r\n```\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/008.png)\r\n\r\n\r\n这些都完成后，在Terminal控制台输入：\r\n\r\n```\r\ngradlew assemble\r\n```\r\n\r\n等待结果，然后就可以看到一个war包了\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/004.png)\r\n\r\n##### 1.3、配置Tomcat\r\n\r\n找到demo-0.0.1-SNAPSHOT.war所在目录，然后将其更名为oldchen.war\r\n\r\n    注意，这里修改后的名字将会与部署到Tomcat上的网络请求地址有关哦\r\n\r\n![image](\r\nhttps://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/005.png)\r\n\r\n然后找到Tomcat的安装目录下的webapps目录，将里面的其他文件和文件夹删除，把oldchen.war复制到该目录\r\n\r\n接下来，在Tomcat目录下的bin目录中运行Tomcat9w.exe\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/006.png)\r\n\r\n然后你会发现，webapps目录下多了一个文件\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/007.png)\r\n\r\n\r\n##### 1.4、测试本地Tomcat\r\n\r\n接下来，访问地址：\r\n\r\nhttp://localhost:8080/oldchen/user/user?account=oldchen\r\n\r\n结果：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/009.png)\r\n\r\n可以看到，本地的Tomcat已经部署成功，接下来就是云服务器上部署Tomcat了。\r\n\r\n\r\n#### 二、云服务器上Tomcat的部署\r\n\r\n##### 2.1、购买云服务器\r\n\r\n想在云服务器上部署Tomcat，首先需要购买一个服务器，我买的是腾讯云的服务器，初次接触的同学建议去使用试用的云服务器，等操作成功后再买也不迟\r\n\r\n\r\n出于对初学者的人文关怀（没错，Is me），这里我使用的是Windows版的服务器：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/010.png)\r\n\r\n\r\n为了能够正常访问服务器的地址，需要给服务器配置一下安全组，安全组中需要添加这样一项规则：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/011.png)\r\n\r\n然后，使用远程连接，连接到云服务器，具体操作是：\r\n    \r\n    一、win+R\r\n    二、输入mstsc\r\n    三、输入云服务器的Ip地址，用户名以及密码，连接\r\n\r\n如果你使用的是windows2016版的服务器，同时遇到了\"身份验证错误，要求的函数不支持\"，而且你恰好是win10家庭版，那么下面有解决办法：\r\n[windows10家庭版 远程桌面报错](https://jingyan.baidu.com/album/67508eb47ae5499ccb1ce410.html?picindex=3)\r\n\r\n\r\n成功登录后，整个界面只有一个孤伶伶的回收站，到了这步，就准备开始配置吧。\r\n\r\n\r\n##### 2.2、配置云服务器\r\n\r\n云服务器上面运行项目只需要Tomcat+Mysql+Navicat+JDK，配置方法和之前在本地配置是一样的，不过这里不建议使用上传的方法，因为上传实际上和下载是一样的，有时候还会受限于你自己宽带的上行速度。\r\n\r\n\r\n\r\n重新下载安装JDK是很头疼的，下面是详细教程：\r\n\r\n[非常详细图文JDK和Tomcat安装和配置的图文教程](https://blog.csdn.net/qq_32519693/article/details/71330930)\r\n\r\n\r\n全部需要准备的文件如下：\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/012.png)\r\n\r\n其中，**PatchNavicat** 用于Navicat的破解，在上一篇的链接中已经说明。\r\n\r\n而**oldchen.sql**则是通过本地Navicat生成Mysql文件，具体操作是：右键你选中的数据库，选择【转储SQL文件】→【结构和数据】，然后就可以生成了。使用方法就是在云服务器上创建一个数据库后选择【运行SQL文件】即可。\r\n\r\n这样，本地数据库的迁移就完成了。剩下的操作与之前介绍的基本一致，不过有一点需要注意，为了开启外网连接，需要在Tomcat安装目录下找到conf目录，修改其中的server.xml文件：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/013.png)\r\n\r\n将port由8080修改为80\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/014.png)\r\n\r\n\r\n当你完成全部的操作后，就可以测试接口了。\r\n\r\n##### 2.3、测试云服务器接口\r\n\r\n\r\n只要你的步骤是ok的，那么云服务器不会有什么问题。\r\n\r\n由于在写这篇文章期间，我又多写了个登录接口，所以这里的测试例子用的是新的接口，仅供参考：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/015.png)\r\n\r\n\r\n请求地址是：http://111.230.251.115/oldchen/user/login\r\n\r\n\r\n\r\n## 后语\r\n\r\n那么，编写接口的学习就到此为止了。\r\n\r\n虽然有待完善的地方还不少，比如通过数据库指令对数据库进行增删改查、数据库之间相互关联等等，许多知识都需要慢慢学的。\r\n\r\n此文章权当入门之径，剩下的还得靠大家自己多多钻研啦，毕竟作者本人需要学的地方也太多了，如有错误之处，还望指出，互相学习，岂不乐哉。\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%A1%A8%E6%83%85%E5%8C%85/%E5%91%8A%E8%BE%9E2.jpg)\r\n\r\n\r\n\r\n\r\n\r\n","Bugly热修复使用及多渠道打包":"---\r\ntitle: Bugly热修复使用及多渠道打包\r\ndate: 2018-09-26 21:49:47\r\nindex_img: /img/bugly.png\r\ntags: Android\r\n---\r\n\r\n## <font color=\"#7FFF00\">头\r\n\r\n不知道你是否遇到过这个情况，项目上线后或者开始给别人使用的时候，冷不丁的冒出个Bug，这时候首先要干嘛？\r\n\r\n**先看崩溃日志啊**\r\n\r\n看完崩溃日志你知道了造成崩溃的原因，然后干嘛？\r\n\r\n**开始甩锅啊**\r\n\r\n当查明了是谁造成的这个崩溃后，你发现不是你的问题，于是你心中一乐，长舒一口气，仰天大笑：码海沉浮又几载，我辈岂是蓬蒿人；笑完便准备躺床上睡觉去——秋豆麻袋，是不是忘了什么东西？\r\n\r\n是的，即使你发现了问题，并且找到了问题的来源，这时候还差一步：解决问题的办法！如何解决？\r\n\r\n**发布新版本？**\r\n\r\n这样不觉得很麻烦吗？特别是如果一个项目处于初期阶段，Bug是想甩都甩不掉的，如果每发现一次崩溃，都需要靠发布一个新版本去解决的话，那未免就太麻烦了。不光是开发者麻烦，使用者也会因为频繁的升级而不耐烦（just like me），那问题又回来了，如何解决？\r\n\r\n**热修复啊**\r\n\r\n通过线上修复Bug，让用户在神不知鬼不觉的情况下就进行了一次应用更新，麻麻再也不用担心App崩溃啦！（不存在的）\r\n\r\n热修复还有个隐藏的好处，那就是在测试人员不够（开发兼测试），测试机型不够的情况下可以显著改善App的崩溃率。好吧，准备开始使用吧。\r\n\r\n## <font color=\"#000066\">身\r\n\r\n### 一、为什么要用Bugly\r\n\r\n市面上关于热修复和崩溃日志监测的相关技术和SDK种类各不相同，为什么偏偏要用Bugly呢？\r\n\r\n- 可以获取到App崩溃日志\r\n- 可以集成Think热修复\r\n- 界面好看，方便管理版本\r\n- 免费\r\n- （凑巧就用了这一款，其他的都没有用过）\r\n\r\n基于以上原因，最后就使用了Bugly去解决上面提到过的问题；\r\n\r\n### 二、Bugly热更新接入流程\r\n\r\n其实关于Bugly热更新的详细接入流程，官方的文档介绍的非常详细，对新手比较友好，我第一次使用也是直接参照的文档，下面是官方文档的地址：\r\n\r\n[【Bugly Android热更新使用指南】](https://bugly.qq.com/docs/user-guide/instruction-manual-android-hotfix/?v=20180709165613)\r\n\r\n虽然官方有例子，这里还是写了一个简化版，也方便以后哪天自己忘记了依旧能快速使用：\r\n\r\n#### 第一步：添加依赖插件\r\n\r\n在你的项目更目录下的“build.gradle”中添加：\r\n\r\n```\r\nbuildscript {\r\n    repositories {\r\n        jcenter()\r\n    }\r\n    dependencies {\r\n        // tinkersupport插件, 其中lastest.release指拉取最新版本，也可以指定明确版本号，例如1.0.4\r\n        classpath \"com.tencent.bugly:tinker-support:1.1.2\"\r\n    }\r\n}\r\n```\r\n在写这篇文章的时候，最新的版本就是1.1.2\r\n\r\n#### 第二步：配置依赖插件\r\n\r\n##### gradle配置\r\n\r\n在app module的“build.gradle”文件中添加（示例配置）：\r\n\r\n\r\n```\r\n...\r\n// 依赖插件脚本\r\napply from: 'tinker-support.gradle'\r\n\r\nandroid {\r\n        defaultConfig {\r\n          ndk {\r\n            //设置支持的SO库架构\r\n            abiFilters 'armeabi' //, 'x86', 'armeabi-v7a', 'x86_64', 'arm64-v8a'\r\n          }\r\n        }\r\n      }\r\n      dependencies {\r\n         implementation 'com.android.support:multidex:1.0.1'\r\n        // 多dex配置\r\n        //注释掉原有bugly的仓库\r\n        //compile 'com.tencent.bugly:crashreport:latest.release'//其中latest.release指代最新版本号，也可以指定明确的版本号，例如1.3.4\r\n        implementation 'com.tencent.bugly:crashreport_upgrade:1.3.5'\r\n        // 指定tinker依赖版本（注：应用升级1.3.5版本起，不再内置tinker）\r\n        implementation 'com.tencent.tinker:tinker-android-lib:1.9.6'\r\n        implementation 'com.tencent.bugly:nativecrashreport:latest.release'\r\n        //其中latest.release指代最新版本号，也可以指定明确的版本号，例如2.2.0\r\n      }\r\n```\r\n在这个版本的SDK里面，已经集成了崩溃日志上传的功能哦！\r\n\r\n##### tinker-support.gradle的配置\r\n\r\n接下来，你要在app module目录下创建另外一个gradle文件，命名为“tinker-support.gradle”，然后对它进行配置：\r\n\r\n```\r\napply plugin: 'com.tencent.bugly.tinker-support'\r\n\r\ndef bakPath = file(\"${buildDir}/bakApk/\")\r\n\r\n/**\r\n * 此处填写每次构建生成的基准包目录\r\n */\r\ndef baseApkDir = \"app-0921-14-52-06\"\r\n\r\n/**\r\n * 对于插件各参数的详细解析请参考\r\n */\r\ntinkerSupport {\r\n\r\n    // 开启tinker-support插件，默认值true\r\n    enable = true\r\n\r\n    // 指定归档目录，默认值当前module的子目录tinker\r\n    autoBackupApkDir = \"${bakPath}\"\r\n\r\n    // 是否启用覆盖tinkerPatch配置功能，默认值false\r\n    // 开启后tinkerPatch配置不生效，即无需添加tinkerPatch\r\n    overrideTinkerPatchConfiguration = true\r\n\r\n    // 编译补丁包时，必需指定基线版本的apk，默认值为空\r\n    // 如果为空，则表示不是进行补丁包的编译\r\n    // @{link tinkerPatch.oldApk }\r\n    baseApk = \"${bakPath}/${baseApkDir}/app-release.apk\"\r\n\r\n    // 对应tinker插件applyMapping\r\n    baseApkProguardMapping = \"${bakPath}/${baseApkDir}/app-release-mapping.txt\"\r\n\r\n    // 对应tinker插件applyResourceMapping\r\n    baseApkResourceMapping = \"${bakPath}/${baseApkDir}/app-release-R.txt\"\r\n\r\n    // 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性\r\n    tinkerId = \"1.0.1-patch\"                //tinkerId = \"1.0.1-patch\"            tinkerId = \"1.0.1-base\"\r\n\r\n    // 构建多渠道补丁时使用\r\n    // buildAllFlavorsDir = \"${bakPath}/${baseApkDir}\"\r\n\r\n    // 是否启用加固模式，默认为false.(tinker-spport 1.0.7起支持）\r\n    // isProtectedApp = true\r\n\r\n    // 是否开启反射Application模式\r\n    enableProxyApplication = false\r\n\r\n    // 是否支持新增非export的Activity（注意：设置为true才能修改AndroidManifest文件）\r\n    supportHotplugComponent = true\r\n\r\n}\r\n\r\n/**\r\n * 一般来说,我们无需对下面的参数做任何的修改\r\n * 对于各参数的详细介绍请参考:\r\n * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97\r\n */\r\ntinkerPatch {\r\n    //oldApk =\"${bakPath}/${appName}/app-release.apk\"\r\n    ignoreWarning = false\r\n    useSign = true\r\n    dex {\r\n        dexMode = \"jar\"\r\n        pattern = [\"classes*.dex\"]\r\n        loader = []\r\n    }\r\n    lib {\r\n        pattern = [\"lib/*/*.so\"]\r\n    }\r\n\r\n    res {\r\n        pattern = [\"res/*\", \"r/*\", \"assets/*\", \"resources.arsc\", \"AndroidManifest.xml\"]\r\n        ignoreChange = []\r\n        largeModSize = 100\r\n    }\r\n\r\n    packageConfig {\r\n    }\r\n    sevenZip {\r\n        zipArtifact = \"com.tencent.mm:SevenZip:1.1.10\"\r\n//        path = \"/usr/local/bin/7za\"\r\n    }\r\n    buildConfig {\r\n        keepDexApply = false\r\n        //tinkerId = \"1.0.1-base\"\r\n        //applyMapping = \"${bakPath}/${appName}/app-release-mapping.txt\" //  可选，设置mapping文件，建议保持旧apk的proguard混淆方式\r\n        //applyResourceMapping = \"${bakPath}/${appName}/app-release-R.txt\" // 可选，设置R.txt文件，通过旧apk文件保持ResId的分配\r\n    }\r\n}\r\n\r\n```\r\n这里面的配置比较多，一开始看还是有点儿眼花缭乱的，所以得慢慢来；\r\n\r\n这里对其中的几点进行说明：\r\n\r\n - *baseApkDir* ： 这里填写每次构建生成的基准包目录，每次打包的时候，都会有新的目录和新的基准包生成，但是只有你打算发布的那一个的目录才是有效的。\r\n - *tinkerId* ： 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性。比如你的第一个基准包打包的时候可以把这个id设置为“1.0.0-base”，当你想打包热修复补丁包的时候，需要把这个id换成1.0.0-patch。\r\n\r\n\r\n更详细的配置项参考：[tinker-support配置说明](https://bugly.qq.com/docs/utility-tools/plugin-gradle-hotfix/)\r\n\r\n#### 第三步：初始化SDK\r\n\r\n\r\n上面的“tinker-support.gradle”中的enableProxyApplication属性设置的是false，是Tinker推荐的接入方式。\r\n\r\n##### 自定义Application，当enableProxyApplication为false的情况\r\n\r\n```\r\npublic class SampleApplication extends TinkerApplication {\r\n    public SampleApplication() {\r\n        super(ShareConstants.TINKER_ENABLE_ALL, \"xxx.xxx.SampleApplicationLike\",\r\n                \"com.tencent.tinker.loader.TinkerLoader\", false);\r\n    }\r\n}\r\n```\r\n**SampleApplicationLike**需要是自定义的继承**DefaultApplicationLike**的类，不要忘了在**AndroidManifest.xml**中声名上面的这个Application哦。\r\n\r\n\r\n```\r\npublic class SampleApplicationLike extends DefaultApplicationLike {\r\n\r\n\r\n    public static final String TAG = \"Tinker.SampleApplicationLike\";\r\n\r\n    public SampleApplicationLike(Application application, int tinkerFlags,\r\n                                 boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime,\r\n                                 long applicationStartMillisTime, Intent tinkerResultIntent) {\r\n        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);\r\n    }\r\n\r\n\r\n    @Override\r\n    public void onCreate() {\r\n        super.onCreate();\r\n        // 这里实现SDK初始化，appId替换成你的在Bugly平台申请的appId\r\n        // 调试时，将第三个参数改为true\r\n        Bugly.init(getApplication(), \"900029763\", false);\r\n    }\r\n\r\n\r\n    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)\r\n    @Override\r\n    public void onBaseContextAttached(Context base) {\r\n        super.onBaseContextAttached(base);\r\n        // you must install multiDex whatever tinker is installed!\r\n        MultiDex.install(base);\r\n\r\n        // 安装tinker\r\n        // TinkerManager.installTinker(this); 替换成下面Bugly提供的方法\r\n        Beta.installTinker(this);\r\n    }\r\n\r\n    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)\r\n    public void registerActivityLifecycleCallback(Application.ActivityLifecycleCallbacks callbacks) {\r\n        getApplication().registerActivityLifecycleCallbacks(callbacks);\r\n    }\r\n}\r\n```\r\n\r\n上面需要注意的是在“onCreate()”方法中进行初始化的时候，填入的appId是你在Bugly创建的项目的Appid，其他地方基本上不用改了\r\n\r\n\r\n##### 自定义Application，当enableProxyApplication为true的情况\r\n\r\n这种的接入方式要简单许多，无须你改造Application\r\n\r\n```\r\npublic class MyApplication extends Application {\r\n\r\n    @Override\r\n    public void onCreate() {\r\n        super.onCreate();\r\n        // 这里实现SDK初始化，appId替换成你的在Bugly平台申请的appId\r\n        // 调试时，将第三个参数改为true\r\n        Bugly.init(this, \"900029763\", false);\r\n    }\r\n\r\n    @Override\r\n    protected void attachBaseContext(Context base) {\r\n        super.attachBaseContext(base);\r\n        // you must install multiDex whatever tinker is installed!\r\n        MultiDex.install(base);\r\n\r\n\r\n        // 安装tinker\r\n        Beta.installTinker();\r\n    }\r\n\r\n}\r\n```\r\n\r\n#### 第四步：AndroidManifest.xml配置\r\n\r\n##### 1.权限配置：\r\n\r\n```\r\n<uses-permission android:name=\"android.permission.READ_PHONE_STATE\" />\r\n<uses-permission android:name=\"android.permission.INTERNET\" />\r\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\r\n<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\r\n<uses-permission android:name=\"android.permission.READ_LOGS\" />\r\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\r\n```\r\n##### 2.Activity配置：\r\n\r\n```\r\n<activity\r\n    android:name=\"com.tencent.bugly.beta.ui.BetaActivity\"\r\n    android:configChanges=\"keyboardHidden|orientation|screenSize|locale\"\r\n    android:theme=\"@android:style/Theme.Translucent\" />\r\n```\r\n##### 3.配置FileProvider\r\n\r\n    注意：如果您想兼容Android N或者以上的设备，必须要在AndroidManifest.xml文件中配置FileProvider来访问共享路径的文件。\r\n\r\n\r\n```\r\n        <!--热更新需要的Provider-->\r\n        <provider\r\n            android:name=\"android.support.v4.content.FileProvider\"\r\n            android:authorities=\"${applicationId}.fileProvider\"\r\n            android:exported=\"false\"\r\n            android:grantUriPermissions=\"true\">\r\n            <meta-data\r\n                android:name=\"android.support.FILE_PROVIDER_PATHS\"\r\n                android:resource=\"@xml/provider_paths\"/>\r\n        </provider>\r\n```\r\n在res目录新建xml文件夹，创建provider_paths.xml文件如下：\r\n```\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<paths xmlns:android=\"http://schemas.android.com/apk/res/android\">\r\n    <!-- /storage/emulated/0/Download/${applicationId}/.beta/apk-->\r\n    <external-path name=\"beta_external_path\" path=\"Download/\"/>\r\n    <!--/storage/emulated/0/Android/data/${applicationId}/files/apk/-->\r\n    <external-path name=\"beta_external_files_path\" path=\"Android/data/\"/>\r\n</paths>\r\n```\r\n#### 第五步：混淆配置\r\n\r\n为了避免混淆SDK，在Proguard混淆文件中增加以下配置：\r\n```\r\n-dontwarn com.tencent.bugly.**\r\n-keep public class com.tencent.bugly.**{*;}\r\n# tinker混淆规则\r\n-dontwarn com.tencent.tinker.**\r\n-keep class com.tencent.tinker.** { *; }\r\n```\r\n\r\n### 三、打包\r\n\r\n当上面的环境配置都没有问题之后，就可以进行打包了。\r\n\r\n打包之前，你还得配置一下编译正式版apk所需要的**keystore.jks**文件，这个文件怎么创建的就不介绍了，这里主要介绍一下如何配置：\r\n\r\n在app moudle目录下的“build.gradle”中配置：\r\n\r\n```\r\nandroid {\r\n    signingConfigs {\r\n        release {\r\n            keyAlias 'xxxxxxxx'\r\n            keyPassword 'xxxxxxxx'\r\n            storeFile file('../keystore.jks')\r\n            storePassword 'xxxxxxxx'\r\n        }\r\n    }\r\n    ...\r\n    buildTypes {\r\n        release {\r\n            minifyEnabled true\r\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\r\n            signingConfig signingConfigs.release\r\n        }\r\n    }\r\n}\r\n```\r\n其中的各项参数就不必做说明了\r\n\r\n\r\n\r\n然后就是打包过程![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/bugly-001.png)\r\n\r\n**打包过程中需要注意之前提到过的tinkerId的配置，以及目录的配置，很重要哦！**\r\n\r\n生成的基准包会在这个目录\r\n\r\n![image](https://bugly.qq.com/docs/img/hotfix/android/Snip20170209_2.png?v=20180709165613)\r\n\r\n生成的补丁包会在这个目录\r\n\r\n![image](https://bugly.qq.com/docs/img/hotfix/android/1479216059696.png?v=20180709165613)\r\n\r\n然后就准备开始使用吧\r\n\r\n### 四、使用\r\n\r\n找到你创建的产品，然后进入到下面的界面\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/bugly-002.png)\r\n\r\n接着，发布新补丁吧，看一看效果\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/bugly-003.png)\r\n\r\n具体的效果可以自行尝试一下，不过有时候你会遇到上传不成功的情况，一般下发后要过5到10分钟才会生效（可能是我的网络问题），如果太久没效果，应该是哪里出问题了\r\n\r\n## <font color=\"#660066\">尾\r\n\r\n前面的所有操作都尝试过后，接下来你可能就会面临新的需求了。比如说，多渠道打包的实现，比较旧的办法是通过productFlavors去实现分别打包，不过这样会有一个弊端，即有多少渠道打包流程就执行多少次，这样效率显然是不够的；\r\n\r\n于是乎，新的打包方案出来了：\r\n\r\n### 使用Walle进行多渠道打包\r\n\r\n下面是Walle的github地址：\r\n\r\n[Walle（瓦力）：Android Signature V2 Scheme签名下的新一代渠道包打包神器](https://github.com/Meituan-Dianping/walle)\r\n\r\n它的接入文档写的也十分友好，接下来实际操作一遍：\r\n\r\n\r\n#### Walle的Gradle接入\r\n\r\n在项目根目录的 **build.gradle** 中添加依赖：\r\n\r\n```\r\nbuildscript {\r\n    dependencies {\r\n        classpath 'com.meituan.android.walle:plugin:1.1.6'\r\n    }\r\n}\r\n```\r\n然后在app module中的 **build.gradle** 添加：\r\n\r\n```\r\napply plugin: 'walle'\r\n\r\ndependencies {\r\n    compile 'com.meituan.android.walle:library:1.1.6'\r\n}\r\n```\r\n并进行插件配置\r\n\r\n```\r\nwalle {\r\n    // 指定渠道包的输出路径\r\n    apkOutputFolder = new File(\"${project.buildDir}/outputs/channels\");\r\n    // 定制渠道包的APK的文件名称\r\n    apkFileNameFormat = '${appName}-${packageName}-${channel}-${buildType}-v${versionName}-${versionCode}-${buildTime}.apk';\r\n    // 渠道配置文件\r\n    channelFile = new File(\"${project.getProjectDir()}/channel\")\r\n}\r\n```\r\n接着在app module目录下创建一个文件，和上面配置中要保持一致，就叫 **channel**\r\n```\r\n360\r\nyingyongbao\r\nbaidu\r\nwandoujia\r\nxiaomi\r\noppo\r\nlenovo\r\nhuawei\r\ndefault_channel\r\n# 打包命令 gradlew clean assembleReleaseChannels  或者 gradlew assembleReleaseChannels\r\n```\r\n最后，在你的Application中的**onCreate**方法里添加：\r\n\r\n```\r\n        String channel = WalleChannelReader.getChannel(getApplication());\r\n        Bugly.setAppChannel(getApplication(), channel);\r\n```\r\n如果你实现的是**SampleApplicationLike**，也是在它的**onCreate**方法里添加即可。\r\n\r\n接下来通过运行上面的打包命令或者通过图中的手动操作，都是可以打包的\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/bugly-004.png)\r\n\r\n\r\n## <font color=\"#dddd00\">末\r\n\r\n至此，基本上整个配置流程就到此结束!!!\r\n\r\n不过有一个问题我一直不知道如何解决，就是打包基准包的命名，在 **tinker-support.gradle** 进行配置是不起效果的，试了好久都没效果，看来还得交给其他小伙伴们解决了\r\n\r\n\r\n\r\n*那么*\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/zaihui.png)\r\n","DataBinding——从相识到相知（二）：互酌":"---\r\ntitle: DataBinding——从相识到相知（二）：互酌\r\ndate: 2018-10-20 21:49:47\r\nindex_img: /img/data_binding.png\r\ntags: Android\r\n---\r\n\r\n# 前言\r\n\r\n上一篇里，主要讲了关于Databinding的以下几点：\r\n\r\n- 接入与使用\r\n- 简单的数据绑定\r\n- 点击事件的绑定\r\n\r\n这一篇将会继续上一篇的步伐，对DataBinding的使用更深几分.首先依旧是从数据绑定开始\r\n<!--more--> \r\n\r\n> 之前所介绍的，虽然UI与数据进行了绑定，但是修改数据对象的时候并不会同时更新 **UI** .  \r\n现在有三种不同类型的 **observable** 类：**objects**, **fields**, 还有 **collections**.  \r\n当其中某个 **observable** 数据对象绑定到 **UI** 并且数据对象的属性发生更改时， UI 将自动更新，下面开始介绍.\r\n\r\n\r\n# Observable数据\r\n\r\n如果你的数据类只有几个属性，那么没必要去实现 **Observable** 接口来监听数据的改变，可以使用下面这些字段：\r\n\r\n- [**ObservableBoolean**](https://developer.android.google.cn/reference/android/databinding/ObservableBoolean.html)\r\n- [**ObservableByte**](https://developer.android.google.cn/reference/android/databinding/ObservableByte.html)\r\n- [**ObservableChar**](https://developer.android.google.cn/reference/android/databinding/ObservableChar.html)\r\n- [**ObservableShort**](https://developer.android.google.cn/reference/android/databinding/ObservableShort.html)\r\n- [**ObservableInt**](https://developer.android.google.cn/reference/android/databinding/ObservableInt.html)\r\n- [**ObservableLong**](https://developer.android.google.cn/reference/android/databinding/ObservableLong.html)\r\n- [**ObservableFloat**](https://developer.android.google.cn/reference/android/databinding/ObservableFloat.html)\r\n- [**ObservableDouble**](https://developer.android.google.cn/reference/android/databinding/ObservableDouble.html)\r\n- [**ObservableParcelable**](https://developer.android.google.cn/reference/android/databinding/ObservableParcelable.html)\r\n\r\n现在，我们再创建一个类\r\n```\r\nclass ObservableBean {\r\n    val text = ObservableField<String>()\r\n}\r\n```\r\n布局文件改为：\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\r\n    <data>\r\n        <variable name=\"model\" type=\"com.test.project.testdatabinding.MVP.DataBinding.Bean.ObservableBean\"/>\r\n    </data>\r\n\r\n    <LinearLayout\r\n        android:orientation=\"vertical\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"match_parent\">\r\n\r\n        <EditText\r\n            android:id=\"@+id/et_test\"\r\n            android:text=\"@={model.text}\"\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"wrap_content\" />\r\n\r\n        <TextView\r\n            android:id=\"@+id/tv_test\"\r\n            android:text=\"@{model.text}\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\"/>\r\n        \r\n    </LinearLayout>\r\n</layout>\r\n```\r\n需要注意的是，上面的 **EditText** 的 **text** 属性使用的是 **@={}** 而 **TextView** 使用的是 **@{}** 。当你想要使用双向绑定的时候，可别忘了这个 **=** 号\r\n\r\n\r\n\r\nActivity的代码只改变了绑定对象：\r\n\r\n```\r\nclass DataBindingActivity<T> : AppCompatActivity() {\r\n\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n//        setContentView(R.layout.activity_data_binding)\r\n        val bindingBinding : ActivityDataBindingBinding = DataBindingUtil.setContentView(this, R.layout.activity_data_binding)\r\n        bindingBinding.model = ObservableBean()\r\n    }\r\n}\r\n```\r\n效果如下：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/two/databinding-001.gif)\r\n\r\n可以看到，直接使用 **Observable** 字段去实现双向数据绑定是很轻松的，不过实际项目里面需求各不相同，要将数据都换成 **Observable** 字段还是很麻烦的，所以自定义双向数据绑定非常有必要！\r\n\r\n这时对 **ObservableBean** 进行修改：\r\n\r\n```\r\nclass ObservableBean : BaseObservable() {\r\n    @get:Bindable\r\n    var text: String = \"\"\r\n    set(value) {\r\n        field = value\r\n        notifyPropertyChanged(BR.text)\r\n    }\r\n}\r\n\r\n//相较于Kotlin写法，这里我觉得Java写法更有助于理解：\r\npublic  class ObservableBean extends BaseObservable {\r\n    private String text;\r\n\r\n    @Bindable\r\n    public String getText() {\r\n        return text;\r\n    }\r\n\r\n    public ObservableBean setText(String text) {\r\n        this.text = text;\r\n        notifyPropertyChanged(BR.text);\r\n        return this;\r\n    }\r\n}\r\n\r\n```\r\n修改过后的效果与之前使用 **Observable** 字段的效果一样，上面需要注意的两点：\r\n\r\n-  使用了 **@Bindable** 注解，进行绑定声明\r\n-  使用了 **notifyPropertyChanged()** 方法为数据刷新做准备\r\n\r\n不过在我看来，通过这种继承的方法对于我们原有的数据结构并不过友好，尤其是继承了 **BaseObservable** 类的数据类不能通过  **Gson** 去与 **Json** 相互转换。\r\n\r\n所以使用的时候，我们可以考虑通过某个中介类的方式去进行转换.\r\n\r\n\r\n# 布局的绑定\r\n\r\n第第一篇中，有写到Activity中如何获取自动生成的布局绑定类——xxxBinding，这种类的命名与使用数据绑定的布局文件xml有关，比如说 **activity_main.xml** 就会生成 **ActivityMainBinding** \r\n\r\n这里再详细说明一下，不同类型的布局，应该怎么获取生成的 **Binding绑定类** \r\n\r\n> 事先并不知道绑定类型的对象可以使用 **DataBindingUtil** 去创建绑定\r\n\r\n```\r\nval rootView = LayoutInflater.from(this).inflate(layoutId, parent, attachToParent)\r\nval binding: ViewDataBinding? = DataBindingUtil.bind(viewRoot)\r\n```\r\n\r\n## 获取带 ID 的 View对象\r\n\r\n如果使用的是Kotlin，可以直接在Activity里很方便的使用id获取View对象，不过使用DataBinding后，就有另外一种获取View对象的方式了\r\n\r\n布局里面的 Id 如下：\r\n\r\n```\r\n    ...\r\n        <EditText\r\n            android:id=\"@+id/et_test\"\r\n            android:text=\"@={model.text}\"\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"wrap_content\" />\r\n\r\n    ...\r\n```\r\n\r\n通过 Id 获取 EditText 的方法如下：\r\n\r\n```\r\n        ...\r\n        super.onCreate(savedInstanceState)\r\n        val bindingBinding : ActivityDataBindingBinding = DataBindingUtil.setContentView(this, R.layout.activity_data_binding)\r\n        bindingBinding.model = ObservableBean()\r\n        val editText = bindingBinding.root.rootView.findViewById<EditText>(R.id.et_test)\r\n```\r\n\r\n\r\n> **立即绑定**  \r\n>\r\n> 当变量或可观察对象发生更改时，绑定会在下一帧之前更改。 不过有的时候需要立刻执行绑定.  \r\n>\r\n> 若要强制执行，可以使用 **executePendingBindings()** 方法。\r\n\r\n## 高级绑定\r\n\r\n有时候，特定的绑定类是未知的.  \r\n\r\n例如，针对任意布局操作的 **RecyclerView.Adapter** 不知道特定的绑定类.它仍然必须在调用 **onBindViewHolder()** 方法时分配绑定值.\r\n\r\n在 **RecyclerView** 的  **onBindViewHolder()** 方法里，可以这样写：\r\n\r\n```\r\noverride fun onBindViewHolder(holder: BindingHolder, position: Int) {\r\n    item: T = mItems.get(position)\r\n    holder.binding.setVariable(BR.item, item);\r\n    holder.binding.executePendingBindings();\r\n}\r\n```\r\n\r\n## 使用@BindingAdapter自定义绑定逻辑\r\n\r\nDataBinding为我们提供了一种可以对绑定逻辑进行自定义的方法，比如说我想在xml中对一个ImageView控件加载图片，并且是使用的Glide加载框架，这时候可以这样：\r\n\r\n```\r\n//随便创建一个类，然后在类中定义如下方法\r\n@BindingAdapter(\"imageUrl\")\r\nfun loadImage(view: ImageView, url: String) {\r\n    GlideApp.with(view.getContext())\r\n   .load(url)\r\n   .fitCenter()\r\n   .into(view);\r\n}\r\n```\r\n使用的时候编译器会自动生成对应属性：\r\n\r\n```\r\n<ImageView \r\napp:imageUrl=\"@{model.imageUrl}\"  />\r\n```\r\n使用 **@BindAdapter** 几乎可以完成你想要的各种逻辑，不过我觉得，只有那种使用率特别高的代码，才最适合这个属性.\r\n\r\n## 使用@BindingConversion完成转换功能\r\n\r\n在某些情况下，特定类型之间需要自定义转换。 例如，视图的android:background属性需要Drawable，但指定的颜色值是整数。 \r\n\r\n官方例子中，转换功能的具体用法如下：\r\n\r\n```\r\n@BindingConversion\r\nfun convertColorToDrawable(color: Int) = ColorDrawable(color)\r\n```\r\n使用的时候可以这样：\r\n\r\n```\r\n<View\r\n   android:background=\"@{isError ? @drawable/error : @color/white}\"\r\n   android:layout_width=\"wrap_content\"\r\n   android:layout_height=\"wrap_content\"/>\r\n```\r\n\r\n\r\n\r\n# 暂歇\r\n\r\n本篇关于DataBindin的介绍也就到此结束，不过DataBinding的使用还没有到头，下一篇将会侧重实际上的操作以及DataBinding还可以为我们带来哪些便捷.\r\n\r\n\r\n\r\n---\r\n\r\n# 未完待续\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","DataBinding——从路人到好友（一）：初遇":"---\r\ntitle: DataBinding——从路人到好友（一）：初遇\r\ndate: 2018-10-17 21:49:47\r\nindex_img: /img/data_binding.png\r\ntags: Android\r\n---\r\n\r\n# 杂谈\r\n\r\n\r\n> 在编程领域，对于一名初学者而言，最开始的进阶方式都是不断重复的练习，然后在练习中遇到各种困难，同时也在这个过程里积累了不少的经验。\r\n>\r\n> 一般情况下，我们获取的经验可以有效的减少我们的失误，也可以为我们预防掉许多“隐藏”的Bug。\r\n> \r\n> 但是，随着我们能力的提升，我们逐渐的对于那些重复性非常高、而且意义并不大的代码产生了厌倦感。首当其冲的就是像 **findViewById** 这样的代码！\r\n\r\n大量的 **findViewById** 与全局变量想必是许多初学者都会经历的阶段，不过学的东西越多，对于这类代码的接受力也就越低。所以许多人选择用了 **ButterKnife** 去解决这个问题。\r\n\r\n然鹅当 **Kotlin** 出现后，**ButterKnife** 也可以随之抛弃了，这时候 **DataBinding** 的用处却和 **Kotlin** 并不冲突，相反二者结合使用，反而会让你有意想不到的、久违的、可圈可点的、眼前一亮的、拍手称赞的体验！\r\n\r\n\r\n# 使用\r\n\r\n\r\n使用 **Data-Binding** ，首先需要在 **app moudle** 下的 **build.gradle** 中添加：\r\n\r\n```\r\nandroid {\r\n    ...\r\n    dataBinding {\r\n        enabled = true\r\n    }\r\n    ...\r\n}\r\n```\r\n\r\n然后就可以正常使用了，不过需要注意，最低支持的Android版本是4.0（反正几乎没有比这更低的android设备了），gradle插件版本是1.5.0 （都2018年了，android开发者们肯定不能用比这更低的版本了吧！）\r\n\r\n\r\n接下来，举个最简单的栗子，我们创建一个 **Cartoon** 类：\r\n\r\n```\r\nclass Cartoon(var name:String = \"JOJO的奇妙冒险\" , var series :String = \"黄金之风\",\r\n              var leader : String = \"乔鲁诺·乔巴纳\", var feature : String = \"黄金体验\") {\r\n}\r\n```\r\n然后新建一个Activity，在这个Activity的xml中的根布局下，通过Alt+Enter快捷键创建databinding的布局，同时，导入 **Cartoon** 类：\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/one/databinding-001.png)\r\n\r\n这时候，编译器会自动根据这个布局生成相应的绑定类，这里会生成一个 **ActivityDataBindingBinding** 的类 ，暂时先不用管，我们继续在xml上工作，修改一下布局样式：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/one/databinding-002.png)\r\n\r\n然后，在对应的Activity内对生成的 **ActivityDataBindingBinding** 类进行操作：\r\n\r\n```\r\nclass DataBindingActivity : AppCompatActivity() {\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n//        setContentView(R.layout.activity_data_binding)\r\n        val bindingBinding : ActivityDataBindingBinding = DataBindingUtil.setContentView(this, R.layout.activity_data_binding)\r\n        bindingBinding.cartoon = Cartoon()\r\n    }\r\n}\r\n```\r\n\r\n由于Kotlin创建的Cartoon实体类已经给每个字段都赋予了初始值，这里不用再进行赋值，然后看一下效果：\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/one/databinding-003.png)\r\n\r\n> 如果你使用的是 items 去进行的绑定，例如Fragment、RecyclerView的adapter，可以使用 inflate() 的方法去绑定或者 DataBindingUtil 类，就像下面这样\r\n\r\n```\r\nval listItemBinding = ListItemBinding.inflate(layoutInflater, viewGroup, false)\r\n// or\r\nval listItemBinding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false)\r\n```\r\n\r\n如果这时候你想使用字符串拼接，可以在 **string.xml** 中创建，比如：\r\n\r\n```\r\n    <string name=\"cartoon_name\">动漫名:%s</string>\r\n    <string name=\"cartoon_series\">系列:%s</string>\r\n    <string name=\"cartoon_leader\">主角:</string>\r\n    <string name=\"cartoon_bodyDouble\">替身:</string>\r\n```\r\n使用的时候可以是这样：\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\r\n    <data>\r\n        <variable name=\"cartoon\" type=\"com.test.project.testdatabinding.DataBinding.Cartoon\"/>\r\n    </data>\r\n\r\n    <LinearLayout\r\n        android:orientation=\"vertical\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"match_parent\">\r\n        <TextView\r\n            android:layout_gravity=\"center\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:text=\"@{@string/cartoon_name(cartoon.name)}\"/>\r\n        <TextView\r\n            android:layout_gravity=\"center\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:text=\"@{@string/cartoon_series(cartoon.series)}\"/>\r\n        <TextView\r\n            android:layout_gravity=\"center\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:text=\"@{@string/cartoon_leader + cartoon.leader}\"/>\r\n        <TextView\r\n            android:layout_gravity=\"center\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:text=\"@{@string/cartoon_bodyDouble + cartoon.feature}\"/>\r\n\r\n    </LinearLayout>\r\n</layout>\r\n```\r\n效果如下：\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/one/databinding-004.png)\r\n\r\n至此，我们完成了与DataBinding的初次接触！\r\n\r\n可以看到，相较于往常的通过findViewById去获取控件实例，然后给控件设置数据的方法，这样显然去掉了Activity内许多不必要的代码。\r\n\r\n不过以上只是比较简单的DataBinding用法，下面将会介绍DataBinding的其他功能，这样才能应更复杂的需求。\r\n\r\n\r\n## 集合的使用\r\n\r\n\r\n```\r\n<data>\r\n    <import type=\"android.util.SparseArray\"/>\r\n    <import type=\"java.util.Map\"/>\r\n    <import type=\"java.util.List\"/>\r\n    <variable name=\"list\" type=\"List<String>\"/>\r\n    <variable name=\"sparse\" type=\"SparseArray<String>\"/>\r\n    <variable name=\"map\" type=\"Map<String, String>\"/>\r\n    <variable name=\"index\" type=\"int\"/>\r\n    <variable name=\"key\" type=\"String\"/>\r\n</data>\r\n…\r\nandroid:text=\"@{list[index]}\"\r\n…\r\nandroid:text=\"@{sparse[index]}\"\r\n…\r\nandroid:text=\"@{map[key]}\"  //这里也可以使用 @{map.key}代替\r\n```\r\n\r\n## 点击事件\r\n\r\n点击事件也是可以在xml中绑定的，在 DataBindingActivity 中添加如下方法：\r\n\r\n```\r\n    fun doClick(view: View){\r\n        Toast.makeText(this, \"点击测试\", Toast.LENGTH_SHORT).show()\r\n    }\r\n```\r\n不要忘了在括号中传入View\r\n\r\n然后再xml中写一个button的点击事件\r\n```\r\n <Button\r\n            android:text=\"DataBinding-点击测试\"\r\n            android:onClick=\"doClick\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\" />\r\n```\r\n如果想通过点击事件传入参数的话，可以通过下面这种方法：\r\n\r\n\r\n```\r\n<variable name=\"handler\" type=\"com.test.project.testdatabinding.DataBinding.DataBindingActivity\"/>\r\n\r\n\r\n<Button\r\n            android:text=\"DataBinding-点击测试\"\r\n            android:onClick=\"@{() -> handler.doClick(cartoon.name)}\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\" />\r\n```\r\n从xml中导入 DataBindingActivity 后，再修改代码：\r\n\r\n```\r\nclass DataBindingActivity : AppCompatActivity() {\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n//        setContentView(R.layout.activity_data_binding)\r\n        val bindingBinding : ActivityDataBindingBinding = DataBindingUtil.setContentView(this, R.layout.activity_data_binding)\r\n        bindingBinding.cartoon = Cartoon()\r\n        bindingBinding.handler = this\r\n    }\r\n\r\n    fun doClick(message: String){\r\n        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()\r\n    }\r\n}\r\n```\r\n点击效果如下：\r\n\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/one/databinding-005.png)\r\n\r\n如果有更加复杂的点击事件，可以参考官介绍中的，如带View参数的：\r\n```\r\nclass Presenter {\r\n    fun onSaveClick(view: View, task: Task){}\r\n}\r\n\r\n\r\nandroid:onClick=\"@{(theView) -> presenter.onSaveClick(theView, task)}\"\r\n```\r\n\r\n## import 与 include\r\n\r\n### import\r\n\r\n在xml中，可以通过导入一些工具类进行简单地操作，比如说导入View类：\r\n\r\n```\r\n<data>\r\n    <import type=\"android.view.View\"/>\r\n</data>\r\n```\r\n这样你就可以直接在xml中使用它的一些静态方法或者变量,官方的例子中简单地用法如下：\r\n\r\n```\r\n<TextView\r\n   android:text=\"@{user.lastName}\"\r\n   android:layout_width=\"wrap_content\"\r\n   android:layout_height=\"wrap_content\"\r\n   android:visibility=\"@{user.isAdult ? View.VISIBLE : View.GONE}\"/>\r\n```\r\n不过我觉得xml中不适合做太多逻辑判断的操作，所以使用的时候应该考虑一下某些操作是否真的合适\r\n\r\n\r\n### include\r\n\r\n如果你有在xml中使用到 include ，通过下面例子中的方法就行绑定：\r\n```\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:bind=\"http://schemas.android.com/apk/res-auto\">\r\n    <data>\r\n        <variable name=\"cartoon\" type=\"com.test.project.testdatabinding.DataBinding.Cartoon\"/>\r\n    </data>\r\n\r\n    <LinearLayout\r\n        android:orientation=\"vertical\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"match_parent\">\r\n        \r\n       <include layout=\"@layout/layout_test\"\r\n           bind:cartoon=\"@{cartoon}\"/>\r\n\r\n    </LinearLayout>\r\n</layout>\r\n```\r\nlayout_test 布局：\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\r\n\r\n    <data>\r\n        <variable name=\"cartoon\" type=\"com.test.project.testdatabinding.DataBinding.Cartoon\"/>\r\n    </data>\r\n\r\n    <android.support.constraint.ConstraintLayout\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"match_parent\">\r\n\r\n        <TextView\r\n            android:text=\"@{cartoon.name}\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\" />\r\n\r\n    </android.support.constraint.ConstraintLayout>\r\n</layout>\r\n```\r\n注意，要使用 bind 属性，可别忘了下面的这行代码：\r\n\r\n```\r\nxmlns:bind=\"http://schemas.android.com/apk/res-auto\"\r\n```\r\n\r\n# 暂歇\r\n\r\n出于篇幅考虑，关于 **DataBinding** 的使用，暂且就讲到这里，关于它更详尽的用法，后续再作介绍。\r\n\r\n\r\n\r\n---\r\n\r\n# 未完待续\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","Flutter图文混排原生实现方案":"---\r\ntitle: Flutter图文混排原生实现方案\r\ndate: 2019-04-19 21:49:47\r\nindex_img: /img/pic_text.png\r\ntags: Flutter\r\n---\r\n\r\n# 开头\r\n\r\n图文混排在移动端的实现方案主要有两大种，比如通过HTML去做一个WebView的富文本，或者通过原生的方式去实现。\r\n\r\n使用WebView在性能上自然不及原生实现，同时开发者需要具备一定的前端知识，它最大的优势是跨平台;\r\n\r\n出于性能的考虑，以及我对前端知识的了解程度，这里我只是介绍一下如何通过原生的方式去实现图文混排。\r\n<!--more--> \r\n\r\n# 介绍\r\n\r\n在手机上，你经常能看到这样的图文实现方式，比如贴吧的这种：\r\n\r\n<img src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Flutter%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/001.png\" width = \"600\" height = \"300\" div align=center />\r\n\r\n点进去后是这样的展示：\r\n\r\n\r\n<img src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Flutter%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/002.png\" width = \"400\" height = \"720\" div align=center />\r\n\r\n\r\n这种实现方式比较简单，算是文字与图片分开展示。不过既然我们要实现的是图文混排，那一定会稍稍复杂一点。\r\n\r\n# 示例\r\n\r\n下面是demo的效果：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Flutter%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/003.gif)\r\n\r\n\r\n从上面的demo可以看到，通过原生的图文混排实现了下面这些效果：\r\n\r\n    1.单个图片的插入\r\n    2.多个图片的插入\r\n    3.插入图片时对文字进行切割\r\n    4.删除图片时对文字进行合并\r\n\r\n\r\n其实看到这里，你应该能够看得出来一个大致的实现方法了，接下来我来介绍一下整个图文混排的结构。\r\n\r\n由于是用Flutter实现，所以图文混排用的ListView，如果是android的话则可以使用RecyclerView(ios的话我不太了解所以就不说了)，因为实现图文混排主要是对数据的处理，所以平台的限制不大。\r\n\r\n**既然是ListView，可以看得出来，ListView的内容全部是由Image与TextField组成，每当你插入一个Image的时候，同时会新増一个TextField，而这个TextField的内容则是上个TextField光标后的文字。**\r\n\r\n既然知道了结构，那么下面来看一下是如何实现的吧。\r\n\r\n\r\n# 实现\r\n\r\n图文混排的主要逻辑在于两个：\r\n\r\n    1.插入\r\n    2.删除\r\n\r\n在进行操作之前，先定义一个抽象的结构，用于存储字符串数据，其实只是对MapEntry的一个简单修改：\r\n\r\n\r\n```\r\nclass TextEntry<K, V> {\r\n  K key;\r\n  V value;\r\n  factory TextEntry(K key, V value) = TextEntry<K, V>._;\r\n  TextEntry._(this.key, this.value);\r\n  String toString() => \"TextEntry($key: $value)\";\r\n}\r\n```\r\n\r\n\r\n然后来看一下插入的实现：\r\n\r\n## 插入\r\n\r\n```\r\nclass RichTextList<T>{\r\n\r\n  List<TextEntry<T, String>> _list = [];\r\n\r\n  void insertOne(int currentPosition, String beforeText, String selectText,\r\n      String afterText, T t) {\r\n    _list[currentPosition].value = beforeText;\r\n    _list.insert(currentPosition + 1, TextEntry(t, \"\"));\r\n    _list.insert(currentPosition + 2, new TextEntry(null, afterText));\r\n  }\r\n\r\n}\r\n```\r\n传递的参数中各个的意义如下：\r\n\r\n- currentPosition：当前TextField所在的位置\r\n- beforeText：当前TextField中光标前的文字\r\n- selectText：当前TextField中选中的文字，在这里没有进行处理\r\n- afterText：当前TextField中光标后的文字\r\n- t：你传入的泛型参数\r\n\r\n可以看到，每插入一个数据，还会自动插入一个value为null的TextEntry，而这个Entry则是文字的内容：\r\n\r\n```\r\n_list.insert(currentPosition + 2, new TextEntry(null, afterText));\r\n```\r\n\r\n所以图文混排的关键在于有一个统一的数据结构，后续如果想对这个数据结构进行转换也可以依据这个来，value为空的TextEntry表示文字，其他的则是你传入的泛型参数。\r\n\r\n下面是插入多条的代码：\r\n\r\n\r\n```\r\n  void insert(int currentPosition, String beforeText, String selectText, String afterText, List<T> list){\r\n    _list[currentPosition].value = beforeText;\r\n    for(int i = 0; i < list.length; i++){\r\n      _list.insert(currentPosition + 2*i + 1, TextEntry(list[i], \"\"));\r\n      _list.insert(currentPosition + 2*i + 2, new TextEntry(null, i == list.length - 1?afterText:\"\"));\r\n    }\r\n  }\r\n```\r\n\r\n当然，你可以用插入多个的替代上面插入单个的。\r\n\r\n然后就是删除的逻辑了：\r\n\r\n## 删除\r\n\r\n删除也非常简单：\r\n\r\n\r\n```\r\n  void remove(int currentPosition) {\r\n      String afterText = _list[currentPosition + 1].value;\r\n      _list[currentPosition - 1].value += afterText;\r\n      _list.removeAt(currentPosition + 1);\r\n      _list.removeAt(currentPosition);\r\n  }\r\n```\r\n\r\n删除的主要逻辑在于把下一个TextField中的内容补在上一个TextField中\r\n\r\n\r\n核心的逻辑大概就是这样。\r\n\r\n\r\n其中有点不方便的就是可能会与你的数据结构不太相同，所以转换的工作需要自己另外实现，当然如果你不想使用抽象的结构也可以自己自定义一种，比如说下面这种：\r\n\r\n\r\n```\r\nclass CustomTypeList{\r\n  TypeFlag flag;//默认为文字——0：文字，1：图片，2：视频，3：音乐\r\n  var imageUrl;\r\n  CustomTypeList({this.flag = TypeFlag.text, this.imageUrl = \"\"});\r\n}\r\n\r\nenum TypeFlag{\r\n  text,\r\n  image,\r\n  video,\r\n  music\r\n}\r\n```\r\n实际使用中可以把枚举类型替换成int值，这样配合后端更佳。\r\n\r\n**通过ListView实现图文混排最大的一个优势在于你可以将文字与任何类型的布局混合在一起，可以是图片，可以是视频，也可以是音乐！**\r\n\r\n\r\n# 结尾\r\n\r\n这篇文章没有把全部的代码贴出来，我已经把demo放在仓库里了，小伙伴们有意向可以去下载查看。\r\n\r\n[**项目地址**](https://github.com/asjqkkkk/TextPicList)\r\n\r\n最后的最后，为我用纯Flutter写的一个测试项目打个小广告：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/apk/apk.png)\r\n\r\n如果你对于上面图文混排最后的效果不是特别满意，也可以到上面的app(android版)里面瞧一下,有做过特殊处理哦！","Handler源码分析":"---\r\ntitle: Hanler源码分析\r\ndate: 2020-03-12 09:56:23\r\nindex_img: /img/handler.jpg\r\ntags: 源码系列\r\n---\r\n\r\n# 序\r\n\r\n我到底为什么要分析 `Hanler` 的源码呢？\r\n\r\n在之前，我分析 `HashMap` 的源码是因为面试中有问到这个，我也确实没看过。而 `Handler` 也会是比较常问的一个知识点。考虑过了我稀疏的源码阅读量，以及分析了 `HashMap` 的源码后一种莫名舒畅的感觉，我决定完成一个源码分析的系列，`Handler` 就是其中之一了。\r\n\r\n# 引子\r\n\r\n我们从哪里开始分析好呢？在 `Handler` 的日常使用中，我们肯定会用到它的 `handleMessage(Message msg)` 方法，所以我们可以从这里开始。\r\n\r\n\r\n```\r\n    public void handleMessage(Message msg) {\r\n    }\r\n```\r\n\r\n然后你可以发现，这个方法属实没什么好分析的。\r\n\r\n我们还是从构造函数那里开始入手吧，分析一遍后你会发现， `Handler` 的源码还是蛮简洁清晰的\r\n\r\n# 分析\r\n\r\n在构造函数之前，可以先看一下 `Handler` 中，有哪些对象\r\n\r\n\r\n```\r\npublic class Handler {\r\n    \r\n    ...\r\n    final Looper mLooper;\r\n    final MessageQueue mQueue;\r\n    final Callback mCallback;\r\n    final boolean mAsynchronous;\r\n    IMessenger mMessenger;\r\n    ...\r\n}\r\n```\r\n\r\n可以看到， `Handler` 中存放了 `Looper` 和 `MessageQueue` ，并且没有存储 `Message`对象，后面的几个对象，后面再来看。接下来，看一下构造函数吧\r\n\r\n\r\n## Handler\r\n\r\n### Handler(...)\r\n\r\n `Handler` 的构造函数有好几种\r\n \r\n \r\n```\r\n    ...\r\n    public Handler() { this(null, false); }\r\n    \r\n    public Handler(Callback callback) { this(callback, false); }\r\n    \r\n    public Handler(Looper looper) { this(looper, null, false); }\r\n    \r\n    public Handler(Looper looper, Callback callback) { this(looper, callback, false); }\r\n    \r\n    public Handler(boolean async) { this(null, async); }\r\n    \r\n    public Handler(Looper looper, Callback callback, boolean async) {\r\n        mLooper = looper;\r\n        mQueue = looper.mQueue;\r\n        mCallback = callback;\r\n        mAsynchronous = async;\r\n    }\r\n    \r\n    public Handler(Callback callback, boolean async) { ... }\r\n    ...\r\n```\r\n\r\n上面给出的构造函数，都指向了最后的两个。\r\n\r\n先看第一个，可以知道这个构造函数创建的  `Handler` ，它的 `Looper` 来自于构造函数。并且 `MessageQueue` 是来自于 `Looper` 的\r\n\r\n`Callback` 其实是一个接口，里面有一个 `handleMessage` 方法\r\n\r\n```\r\n    public interface Callback {\r\n        public boolean handleMessage(Message msg);\r\n    }\r\n```\r\n\r\n至于 `mAsynchronous` ,暂时从字面上来看它是用于控制是否异步加载的。不过是不是这样呢？看后面的代码分析就知道了。\r\n\r\n接下来，我们看一下 `Handler` 的另外一个构造函数吧\r\n\r\n```\r\n    public Handler(Callback callback, boolean async) {\r\n        if (FIND_POTENTIAL_LEAKS) {\r\n            ...\r\n            //如果发现有内存泄漏的可能，提示有内存泄漏的风险\r\n        }\r\n\r\n        mLooper = Looper.myLooper();\r\n        if (mLooper == null) {\r\n            //抛出异常\r\n        }\r\n        mQueue = mLooper.mQueue;\r\n        mCallback = callback;\r\n        mAsynchronous = async;\r\n    }\r\n```\r\n上面的代码，我们简化了一下，和之前构造函数不同的是 `Handler` 的 `Looper`是通过 **Looper.myLooper()** 方法传递的，来看一下这个方法\r\n\r\n\r\n```\r\npublic final class Looper {\r\n    ...\r\n    \r\n    static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();\r\n    \r\n    public static @Nullable Looper myLooper() {\r\n        return sThreadLocal.get();\r\n    }\r\n    ...\r\n}\r\n```\r\n\r\n可以看到，这个 `Looper` 是通过 `ThreadLocal` 对象获取的, 这里就先不详细介绍 `ThreadLocal` 了(我还没仔细的看它的源码)，但是我们通过它的说明可以知道， `ThreadLocal` 的作用是：\r\n\r\n> 每一个 Thread 都会持有自己的局部变量，而 ThreadLocal 是一种管理这些变量的结构，它可以让 Thread 使用它自己的局部变量，而不与其他 Thread 分享。\r\n也就是实现了线程之间的资源隔离，达到安全并发的目的\r\n\r\n那么这里的 `Looper` 其实就是获取与当前 `Thread` 关联的  `Looper` 。不过到这里，我就产生了一个疑问，不知道你们有木有：\r\n\r\n    `Looper` 和 `Tread` 是一一对应的关系吗？还是其他的关系？\r\n    \r\n这个我们通过后面的源码来解释。\r\n\r\n接下来，`Handler` 中，有几个比较典型的方法，通过这些方法，我们可以更加清晰的了解 `Handler` 的作用机制\r\n\r\n\r\n```\r\n    ...\r\n    \r\n    public void dispatchMessage(Message msg) {...}\r\n    \r\n    public static Handler getMain() {...}\r\n    \r\n    public final boolean post(Runnable r) {\r\n       return  sendMessageDelayed(getPostMessage(r), 0);\r\n    }\r\n    \r\n    public final boolean postDelayed(Runnable r, long delayMillis) {...}\r\n    \r\n    public final boolean sendMessageDelayed(Message msg, long delayMillis) {...}\r\n    \r\n    public final boolean sendEmptyMessage(int what) { return sendEmptyMessageDelayed(what, 0); }\r\n    \r\n    public final boolean sendEmptyMessageDelayed(int what, long delayMillis) {...}\r\n    \r\n    public final boolean sendMessageDelayed(Message msg, long delayMillis) {...}\r\n    \r\n    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {...}\r\n    \r\n    \r\n    \r\n    public final void removeCallbacksAndMessages(Object token) {\r\n        mQueue.removeCallbacksAndMessages(this, token);\r\n    }\r\n    \r\n    \r\n    ...\r\n```\r\n\r\n其中，`dispatchMessage`、`postXXXX`、`sendXXXX` 都是我们常用的一些方法，我们来逐个解析\r\n\r\n### dispatchMessage(Message msg)\r\n\r\n\r\n```\r\n    public void dispatchMessage(Message msg) {\r\n        if (msg.callback != null) {\r\n            handleCallback(msg);\r\n        } else {\r\n            if (mCallback != null) {\r\n                if (mCallback.handleMessage(msg)) {\r\n                    return;\r\n                }\r\n            }\r\n            handleMessage(msg);\r\n        }\r\n    }\r\n```\r\n显然，这个方法是用来分发 `Message` 的，先看一下 `Message` 中的 `callback`是什么：\r\n\r\n```\r\npublic final class Message implements Parcelable {\r\n    ...\r\n    Runnable callback;\r\n    ...\r\n}\r\n```\r\n原来是 `Runnable`，这里也把大家最熟悉的 `Runnable` 贴出来一下:\r\n\r\n```\r\npublic interface Runnable {\r\n    public abstract void run();\r\n}\r\n```\r\n我们看一下，当 `msg` 中的 `callback`不为空的时候，是怎么处理的\r\n\r\n```\r\n    private static void handleCallback(Message message) {\r\n        message.callback.run();\r\n    }\r\n```\r\n其实看到这里上面的分发流程就清楚了：\r\n\r\n- 如果 `Message` 中的 `callback` 存在，则优先交给它去处理\r\n- 否则，如果 `Handler` 中的 `mCallback` 存在，则交由这个 `mCallback` 处理\r\n- 否则，交给 `handleMessage()` 处理，也就是你实现的 `Handler` 类，重写了这个方法的话\r\n\r\n### getMain()\r\n\r\n```\r\npublic class Handler {\r\n    ...\r\n    public static Handler getMain() {\r\n        if (MAIN_THREAD_HANDLER == null) {\r\n            MAIN_THREAD_HANDLER = new Handler(Looper.getMainLooper());\r\n        }\r\n        return MAIN_THREAD_HANDLER;\r\n    }\r\n    ...\r\n}\r\n\r\n\r\npublic final class Looper {\r\n    ...\r\n    private static Looper sMainLooper; \r\n    \r\n    public static Looper getMainLooper() {\r\n        synchronized (Looper.class) {\r\n            return sMainLooper;\r\n        }\r\n    }\r\n    \r\n    public static void prepareMainLooper() {\r\n        prepare(false);\r\n        synchronized (Looper.class) {\r\n            if (sMainLooper != null) {\r\n                throw new IllegalStateException(\"The main Looper has already been prepared.\");\r\n            }\r\n            sMainLooper = myLooper();\r\n        }\r\n    }\r\n    \r\n    private static void prepare(boolean quitAllowed) {\r\n        if (sThreadLocal.get() != null) {\r\n            throw new RuntimeException(\"Only one Looper may be created per thread\");\r\n        }\r\n        sThreadLocal.set(new Looper(quitAllowed));\r\n    }\r\n    ...\r\n}\r\n\r\n\r\n```\r\n\r\n上面还贴了一段和 `getMain()` 相关的 `Looper` 的方法\r\n\r\n`getMain()` 就是用来获取引用了 **主线程Looper** 的 `Handler`,从这一段代码其实就可以看出，每个 `Handler` 对此方法未做限制，也就是说一个**主线程Looper**是可以对应多个 `Handler` 的\r\n\r\n然后是 `Looper` 中，关于`prepareMainLooper()`方法其实还有一段说明，上面没贴出来，意思是：\r\n> prepareMainLooper()用于初始化主线程的Looper，它是由系统调用的，所以作为开发者，你不应该调用这个方法(ps:那为什么不设置成private的呢，也许是为了方便系统调用？)\r\n\r\n再看一下 `prepare(boolean quitAllowed)` 方法，他是用于给当前线程设置 `Looper` 对象的。从这里就可以看出，一个线程只能有一个 `Looper` 对象，多了的话，就会报错啦！\r\n\r\n接下来，看一下比较常用的 `postXXXX(...)` 、`sendXXXX(...)`相关的方法,我们经常用它去进行通知操作。\r\n\r\n### postXXXX(...) && sendXXXX(...)\r\n\r\n\r\n```\r\n    ...\r\n    public final boolean post(Runnable r) {\r\n       return  sendMessageDelayed(getPostMessage(r), 0);\r\n    }\r\n    \r\n    public final boolean postAtTime(Runnable r, long uptimeMillis) {\r\n        return sendMessageAtTime(getPostMessage(r), uptimeMillis);\r\n    }\r\n    \r\n    public final boolean sendMessageDelayed(Message msg, long delayMillis) {\r\n        if (delayMillis < 0) { delayMillis = 0; }\r\n        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\r\n    }\r\n    \r\n    private static Message getPostMessage(Runnable r) {\r\n        Message m = Message.obtain();\r\n        m.callback = r;\r\n        return m;\r\n    }\r\n    \r\n    public final boolean sendMessage(Message msg) {\r\n        return sendMessageDelayed(msg, 0);\r\n    }\r\n    \r\n    public final boolean sendEmptyMessage(int what) {\r\n        return sendEmptyMessageDelayed(what, 0);\r\n    }\r\n    \r\n    public final boolean sendEmptyMessageDelayed(int what, long delayMillis) {\r\n        Message msg = Message.obtain();\r\n        msg.what = what;\r\n        return sendMessageDelayed(msg, delayMillis);\r\n    }\r\n    \r\n    public final boolean sendMessageDelayed(Message msg, long delayMillis) {\r\n        if (delayMillis < 0) { delayMillis = 0; }\r\n        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\r\n    }\r\n    \r\n```\r\n\r\n`post` 传递的 `Runnable` 会被设置到 `Message` 中去, `send` 传递的 `waht` 也会被设置到 `Message` 中去，`Message.obtain()` 我们后面再看。\r\n\r\n这些方法最终都会走到 `sendMessageAtTime` 的方法中去，所以我们直接看这个吧\r\n\r\n### sendMessageAtTime(...)\r\n\r\n```\r\n    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {\r\n        MessageQueue queue = mQueue;\r\n        if (queue == null) {\r\n            RuntimeException e = new RuntimeException(\r\n                    this + \" sendMessageAtTime() called with no mQueue\");\r\n            Log.w(\"Looper\", e.getMessage(), e);\r\n            return false;\r\n        }\r\n        return enqueueMessage(queue, msg, uptimeMillis);\r\n    }\r\n```\r\n\r\n`sendMessageAtTime` 方法又会调用 `enqueueMessage`\r\n\r\n\r\n```\r\n    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\r\n        msg.target = this;\r\n        if (mAsynchronous) {\r\n            msg.setAsynchronous(true);\r\n        }\r\n        return queue.enqueueMessage(msg, uptimeMillis);\r\n    }\r\n```\r\n\r\n`Message` 中的 `target` 是一个 `Handler` 对象,从这个方法其实可以知道一个 `Message` 对应一个  `Handler` ，但是一个 `Handler` 可以对应多个 `Message` 。因为一个 `Handler` 可以 `post` 多次，但是一个 `Message` 只有一个  `target`\r\n\r\n上面的方法，就是向 `MessageQueue` 中插入一个 `Message`, 到这里Handler的部分大概就结束了。\r\n\r\n接下来, 我们对于 `MessageQueue` 和  `Message`  的分析就要开始啦\r\n\r\n我们先简单分析一下 `Message` 对象\r\n\r\n## Message\r\n\r\n\r\n```\r\npublic final class Message implements Parcelable {\r\n    ...\r\n    public int what;\r\n    public Object obj;\r\n    public long when;\r\n    Handler target;\r\n    Runnable callback;\r\n    Message next;\r\n    \r\n    public static final Object sPoolSync = new Object();\r\n    private static Message sPool;\r\n    private static int sPoolSize = 0;\r\n\r\n    private static final int MAX_POOL_SIZE = 50;\r\n    \r\n}\r\n```\r\n\r\n上面的 `sPoolSync` 的作用是实现 **对象锁**， 它分别在获取 `Message`对象的 `obtain()` 方法以及回收  `Message` 对象的 `recycleUnchecked()` 方法中使用到\r\n\r\n看到上面的 `next` 对象，熟悉的队列结构，所以 `Message` 其实是一个队列\r\n\r\n而 `sPool` 作为一个静态对象，再根据它的命名来看，初步判断它是一个维护多个 `Message` 的队列，最大长度是 **50** ，作用是复用 `Message` 吗？来看一看代码就知道了\r\n\r\n\r\n### obtain()\r\n\r\n\r\n```\r\n    public static Message obtain() {\r\n        synchronized (sPoolSync) {\r\n            if (sPool != null) {\r\n                Message m = sPool;\r\n                sPool = m.next;\r\n                m.next = null;\r\n                m.flags = 0; // clear in-use flag\r\n                sPoolSize--;\r\n                return m;\r\n            }\r\n        }\r\n        return new Message();\r\n    }\r\n```\r\n\r\n可以看到，上面的代码逻辑如下：\r\n- 当 `sPool` 不为空的时候，从 `sPool` 取出队列头对象，并返回这个对象\r\n- `sPool` 为空的话，就直接返回一个新的 `Message` 对象啦！\r\n\r\n我们之前在 `Handler` 中遇到过的各种 `post` 方法，使用的 `Message` 就是这样获得的\r\n\r\n`Message` 还剩下一个 `recycleUnchecked()` 方法需要了解一下，因为剩下的都比较简单，不需要进行分析了\r\n\r\n\r\n\r\n### recycleUnchecked()\r\n\r\n```\r\n    public void recycle() {\r\n        if (isInUse()) {\r\n            ...\r\n            return;\r\n        }\r\n        recycleUnchecked();\r\n    }\r\n    \r\n    void recycleUnchecked() {\r\n        flags = FLAG_IN_USE;\r\n        //这里进行各种置空、状态初始化操作\r\n        ...\r\n        synchronized (sPoolSync) {\r\n            if (sPoolSize < MAX_POOL_SIZE) {\r\n                next = sPool;\r\n                sPool = this;\r\n                sPoolSize++;\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n可以看到，上面的回收操作，其实就是将这个 `Message` 对象 **进行还原**，然后放入 `sPool` 的队列头中，也就是说，我们之前对于 `sPool` 复用的猜想，是正确的。\r\n\r\n接下来，开始康康 `MessageQueue` 吧\r\n\r\n## MessageQueue\r\n\r\n\r\n### MessageQueue(boolean quitAllowed)\r\n先来看构造函数吧\r\n\r\n```\r\n    private final boolean mQuitAllowed;\r\n    private long mPtr;\r\n    \r\n    MessageQueue(boolean quitAllowed) {\r\n        mQuitAllowed = quitAllowed;\r\n        mPtr = nativeInit();\r\n    }\r\n    \r\n    private native static long nativeInit();\r\n```\r\n\r\n在之前，我们看 `Looper` 的 `prepare()` 和 `prepareMainLooper()` 方法中，都会创建一个新的 `Looper` 对象，我们看一下 `Looper` 的构造函数\r\n\r\n```\r\n    private Looper(boolean quitAllowed) {\r\n        mQueue = new MessageQueue(quitAllowed);\r\n        mThread = Thread.currentThread();\r\n    }\r\n```\r\n可以知道，`MessageQueue` 是在 `Looper` 创建的时候，一起创建的。\r\n\r\n同时， `prepareMainLooper()`中的 `quitAllowed` 是 **false**, 这表示，由 `主线程Looper` 创建的 `MessageQueue` 是不允许退出的。至于原因嘛，因为这个 `MessageQueue` 是和当前app共同生存的呀，退出了app也就结束了。具体的逻辑，再看后面的代码吧。\r\n\r\n关于 `mPtr` 对象的作用，因为涉及到 **native** 方法，所以它已经不是java层面的内容了，我查阅了一下\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/handler_sourcecode/001.jpg)\r\n\r\n是调用的 C++ 方法，并且从上面这个方法可以看出来，在 C++ 层面创建了另一个 `NativeMessageQueue` 对象，并且返回的内容看起来是可以用来和 `NativeMessageQueue` 对象进行关联的值\r\n\r\n`MessageQueue` 许多方法都是和 **native** 进行交互的，暂时先不管(主要是也管不了)，我们这里就先看一下之前在 `Handler` 中的 `enqueueMessage` 和 `removeMessages` 方法，它们都调用到了 `MessageQueue` 相对应的方法\r\n\r\n### enqueueMessage(Message msg, long when)\r\n\r\n\r\n```\r\n    boolean enqueueMessage(Message msg, long when) {\r\n        ...\r\n        ///target为空或者isInUse()的话就抛出异常\r\n        ...\r\n        synchronized (this) {\r\n            //如果正在退出，回收当前 msg，并返回false\r\n            ...\r\n            msg.markInUse();\r\n            msg.when = when;\r\n            Message p = mMessages;\r\n            boolean needWake;\r\n            if (p == null || when == 0 || when < p.when) {\r\n                // New head, wake up the event queue if blocked.\r\n                msg.next = p;\r\n                mMessages = msg;\r\n                needWake = mBlocked;\r\n            } else {\r\n                needWake = mBlocked && p.target == null && msg.isAsynchronous();\r\n                Message prev;\r\n                for (;;) {\r\n                    prev = p;\r\n                    p = p.next;\r\n                    if (p == null || when < p.when) {\r\n                        break;\r\n                    }\r\n                    if (needWake && p.isAsynchronous()) {\r\n                        needWake = false;\r\n                    }\r\n                }\r\n                msg.next = p; // invariant: p == prev.next\r\n                prev.next = msg;\r\n            }\r\n\r\n            // We can assume mPtr != 0 because mQuitting is false.\r\n            if (needWake) {\r\n                nativeWake(mPtr);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n```\r\n上面的代码中，可以把第一个 **if** 逻辑简单改一下，看起来更加清晰：\r\n\r\n```\r\n            ...\r\n            Message p = mMessages;\r\n            if (p == null || when == 0 || when < p.when) {\r\n                // New head, wake up the event queue if blocked.\r\n                msg.next = null;\r\n                mMessages = msg;\r\n                needWake = mBlocked;\r\n            } \r\n```\r\n可以看到， `MessageQueue` 中本身就存放了一个 `Message` 对象: `mMessages`\r\n\r\n所以第一个 **if** 的逻辑就是：\r\n- 当 `mMessages` 为 **null** 时，`mMessages` 队列设置成只有一个节点，这个节点就由插入的 `msg` 提供，并且如果此时 `event quene` 处于阻塞状态的话，就唤醒它\r\n\r\n接下来看 **else** 的逻辑：\r\n- 遍历 `mMessages` 队列，根据 `when` 的大小来决定插入的地方，`when` 越小越靠近队列头部。\r\n- 只有当`event quene` 头部阻塞了并且队列中存在很早添加的 **异步** `Message` 对象的时候才去唤醒\r\n\r\n然后是 `removeMessages(...)` 、`removeCallbacksAndMessages(...)`方法，也是遍历 `mMessages` 对  `Message` 对象进行删除。因为都调用到了 `Message` 对象的 `recycleUnchecked()` 方法，所以被 **remove** 掉的对象，会以初始状态存储在 `Message` 的 `sPool` 中方便复用\r\n\r\n `MessageQueue` 还有一个最为关键的方法 `next()`, 在分析这个方法之前, 我们先解决掉 `Looper`是如何分发 `Message` 的，一起来瞧一瞧\r\n\r\n## Looper\r\n\r\n\r\n```\r\npublic final class Looper {\r\n    ...\r\n    static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();\r\n    private static Looper sMainLooper;\r\n    final MessageQueue mQueue;\r\n    final Thread mThread;\r\n    \r\n    private Looper(boolean quitAllowed) {\r\n        mQueue = new MessageQueue(quitAllowed);\r\n        mThread = Thread.currentThread();\r\n    }\r\n    \r\n    public static void prepareMainLooper() {...}\r\n    \r\n    public static Looper getMainLooper() {...}\r\n    \r\n    public static void loop() {...}\r\n    \r\n}\r\n```\r\n除了 `loop()` 方法外，其他的部分在前面已经分析过了，这里直接开始看 `loop()` 吧\r\n\r\n### loop()\r\n\r\n\r\n```\r\n    public static void loop() {\r\n        final Looper me = myLooper();\r\n        if (me == null) {\r\n            throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\r\n        }\r\n        final MessageQueue queue = me.mQueue;\r\n\r\n        // Make sure the identity of this thread is that of the local process,\r\n        // and keep track of what that identity token actually is.\r\n        Binder.clearCallingIdentity();\r\n        final long ident = Binder.clearCallingIdentity();\r\n\r\n        for (;;) {\r\n            Message msg = queue.next(); // might block\r\n            if (msg == null) {\r\n                // No message indicates that the message queue is quitting.\r\n                return;\r\n            }\r\n\r\n            ...\r\n            \r\n            try {\r\n                msg.target.dispatchMessage(msg);\r\n            } finally {\r\n                if (traceTag != 0) {\r\n                    Trace.traceEnd(traceTag);\r\n                }\r\n            }\r\n\r\n            ...\r\n\r\n            msg.recycleUnchecked();\r\n        }\r\n    }\r\n```\r\n\r\n上面选取的是 `loop()` 方法中,和 `Message` 相关的部分.\r\n\r\n可以看到, `loop()` 就是在一个**死循环**中,通过 `MessageQuene` 的 `next()` 方法来获取 `Message`, 然后调用这个 `Message` 持有的 `Handler` 对象的 `dispatchMessage(msg)` 方法来分发 `Message`. \r\n\r\n只有当 `queue.next()` 返回 **null** 的时候,循环才能停止\r\n\r\n关于 **Looper** 就到这里\r\n\r\n\r\n最后,我们再来看 `MessageQueue` 中最关键的一个方法: `next()`\r\n\r\n### MessageQueue -> next()\r\n\r\n`next()` 的逻辑操作比较多,其中还有一部分是关于 `IdelHandler` 的,这里就先不管他们,只看主要的部分\r\n\r\n\r\n```\r\n    Message next() {\r\n        //判断ptr值,为0的话,说明C++那里的NativeMessageQuene已经destory了,直接返回null\r\n        ...\r\n\r\n        int pendingIdleHandlerCount = -1; // -1 only during first iteration\r\n        int nextPollTimeoutMillis = 0;\r\n        for (;;) {\r\n            if (nextPollTimeoutMillis != 0) {\r\n                Binder.flushPendingCommands();\r\n            }\r\n\r\n            nativePollOnce(ptr, nextPollTimeoutMillis);\r\n\r\n            synchronized (this) {\r\n                // Try to retrieve the next message.  Return if found.\r\n                final long now = SystemClock.uptimeMillis();\r\n                Message prevMsg = null;\r\n                Message msg = mMessages;\r\n                if (msg != null && msg.target == null) {\r\n                    // Stalled by a barrier.  Find the next asynchronous message in the queue.\r\n                    do {\r\n                        prevMsg = msg;\r\n                        msg = msg.next;\r\n                    } while (msg != null && !msg.isAsynchronous());\r\n                }\r\n                if (msg != null) {\r\n                    if (now < msg.when) {\r\n                        // Next message is not ready.  Set a timeout to wake up when it is ready.\r\n                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\r\n                    } else {\r\n                        // Got a message.\r\n                        mBlocked = false;\r\n                        if (prevMsg != null) {\r\n                            prevMsg.next = msg.next;\r\n                        } else {\r\n                            mMessages = msg.next;\r\n                        }\r\n                        msg.next = null;\r\n                        if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\r\n                        msg.markInUse();\r\n                        return msg;\r\n                    }\r\n                } else {\r\n                    // No more messages.\r\n                    nextPollTimeoutMillis = -1;\r\n                }\r\n\r\n                // Process the quit message now that all pending messages have been handled.\r\n                if (mQuitting) {\r\n                    dispose();\r\n                    return null;\r\n                }\r\n                \r\n                ...\r\n                //IdelHandler相关操作\r\n                ...\r\n            }\r\n            \r\n            ...\r\n            //IdelHandler相关操作\r\n            ...\r\n\r\n            nextPollTimeoutMillis = 0;\r\n        }\r\n    }\r\n```\r\n\r\n来逐步分析一下上面的代码:\r\n\r\n`pendingIdleHandlerCount` 和 `IdleHandler` 有关,暂时不管\r\n\r\n`nextPollTimeoutMillis` 表示休眠时间,当还没有到达 `Message` 中 `when` 所指定的时间时, 会先去处理 `IdleHandler` ,此时没有 `IdleHandler` 可供处理的话,就会进入休眠时间,并在指定时间唤醒, 对应代码:\r\n\r\n```\r\nif (now < msg.when) {\r\n    // Next message is not ready.  Set a timeout to wake up when it is ready.\r\n    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\r\n} \r\n```\r\n\r\n我们接下来看第一个 **if** 的逻辑:\r\n- 如果 `msg.target` 为 **null**, 表示遇到了一个障碍,因为只有在 `Message` 回收的时候才会将 `target` 置空,所以这里我们需要寻找下一个 **异步的Message**\r\n\r\n然后开始看第二个 **if**:\r\n- 当 `msg` 不为 null时\r\n    - 如果 `now < msg.when`,说明未到这个msg的执行时间,设置休眠时间 `nextPollTimeoutMillis`,之后会去处理 `IdelHandler`,这个循环会持续下去,直到时间可以处理这个 `msg` 为止\r\n    - 否则,返回这个 `msg`,如果`prevMsg` 不为 **null** 的话,就说明这个 `msg` 是之前遇到障碍时,所找到的 **异步Message**; 不然就是常规的 `msg`\r\n- 否则,将 `nextPollTimeoutMillis` 设置为 -1. 此时,表明 `MessageQuene` 已经没有可以消耗的 `Message` 啦. **for** 循环会一直执行,此时就会进入阻塞状态啦.\r\n\r\n当进入阻塞状态的时候,就有很多问题了,比如:  \r\n\r\n**1.“UI线程为什么没有因此卡死?”**  \r\n**2.“没看见哪里有相关代码为这个死循环准备了一个新线程去运转？”**  \r\n**3.“Activity的生命周期这些方法这些都是在主线程里执行的吧，那这些生命周期方法是怎么实现在死循环体外能够执行起来的？”**  \r\n**4.“什么时候会退出阻塞?”**  \r\n\r\n下面,对于这些问题来进行解释(此处Google了不少):\r\n\r\n#### 1.UI线程为什么没有因此卡死?\r\n\r\n这里涉及**线程**，先说说说**进程/线程**.\r\n\r\n**进程**：每个app运行时前首先创建一个进程，该进程是由Zygote fork出来的，用于承载App上运行的各种Activity/Service等组件。进程对于上层应用来说是完全透明的，这也是google有意为之，让App程序都是运行在Android Runtime。大多数情况一个App就运行在一个进程中，除非在AndroidManifest.xml中配置Android:process属性，或通过native代码fork进程。\r\n\r\n**线程**：线程对应用来说非常常见，比如每次new Thread().start都会创建一个新的线程。该线程与App所在进程之间资源共享，从Linux角度来说进程与线程除了是否共享资源外，并没有本质的区别，都是一个task_struct结构体，**在CPU看来进程或线程无非就是一段可执行的代码**，CPU采用CFS调度算法，保证每个task都尽可能公平的享有CPU时间片。\r\n\r\n有了这些准备，再说说**死循环**问题：\r\n\r\n对于线程既然是一段可执行的代码，当可执行代码执行完成后，线程生命周期便该终止了，线程退出。而对于主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？简单做法就是可执行代码是能一直执行下去的，**死循环便能保证不会被退出**，例如，binder线程也是采用死循环的方法，通过循环方式不同与Binder驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。\r\n\r\n真正会卡死主线程的操作是在回调方法onCreate/onStart/onResume等操作时间过长，会导致掉帧，甚至发生ANR，looper.loop本身不会导致应用卡死。\r\n\r\n但这里可能又引发了另一个问题，既然是死循环又如何去处理其他事务呢？通过创建新线程的方式。\r\n\r\n#### 2.没看见哪里有相关代码为这个死循环准备了一个新线程去运转？\r\n\r\n事实上，会在进入死循环之前便创建了新 `Binder` 线程，在代码 `ActivityThread.main()` 中：\r\n\r\n\r\n```\r\npublic static void main(String[] args) { \r\n      .... \r\n      //创建Looper和MessageQueue对象，用于处理主线程的消息 \r\n      Looper.prepareMainLooper(); \r\n      //创建ActivityThread对象 \r\n      ActivityThread thread = new ActivityThread(); \r\n      //建立Binder通道 (创建新线程) \r\n      thread.attach(false); \r\n      Looper.loop(); //消息循环运行\r\n      throw new RuntimeException(\"Main thread loop unexpectedly exited\"); \r\n}\r\n```\r\n`thread.attach(false)` 便会创建一个 `Binder` 线程（具体是指 `ApplicationThread` ，`Binder` 的服务端，用于接收系统服务**AMS**发送来的事件），该 `Binder` 线程通过 `Handler` 将 `Message` 发送给主线程,具体过程可查看 [startService流程分析](http://gityuan.com/2016/03/06/start-service/)\r\n\r\n另外，`ActivityThread` 实际上并非线程，不像 `HandlerThread` 类，`ActivityThread` 并没有真正继承 `Thread` 类，只是往往运行在主线程，给人以线程的感觉，其实承载 `ActivityThread` 的主线程就是由 **Zygote fork** 而创建的进程。\r\n\r\n主线程的死循环一直运行是不是特别消耗CPU资源呢？ 其实不然，这里就涉及到 **Linux pipe/epoll** 机制，简单说就是在主线程的 `MessageQueue` 没有消息时，便阻塞在 `Looper` 的 `queue.next()` 中的 `nativePollOnce()` 方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往 **pipe管道** 写端写入数据来唤醒主线程工作,也就是 `MessageQueue` 中 `enqueueMessage(...)` 方法被调用时, `Message` 被添加到空的队列中触发的 `nativeWake(mPtr)` 方法。\r\n\r\n这里采用的 **epoll机制**，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。\r\n\r\n#### 3.Activity的生命周期是怎么实现在死循环体外能够执行起来的？\r\n\r\n`ActivityThread` 的内部类 `H` 继承于 `Handler`，通过 `Handler` 消息机制，简单说 `Handler` 机制用于同一个进程的线程间通信。\r\n\r\n`Activity` 的生命周期都是依靠主线程的 `Looper.loop()` ，当收到不同 `Message` 时则采用相应措施：\r\n\r\n在 `H.handleMessage(msg)` 方法中，根据接收到不同的 `msg`，执行相应的生命周期。\r\n\r\n比如收到 `msg.what=H.LAUNCH_ACTIVITY`，则调用 `ActivityThread.handleLaunchActivity()` 方法，最终会通过反射机制，创建 `Activity` 实例，然后再执行 `Activity.onCreate()` 等方法；\r\n\r\n再比如收到 `msg.what=H.PAUSE_ACTIVITY`，则调用 `ActivityThread.handlePauseActivity()` 方法，最终会执行 `Activity.onPause()` 等方法。 上述过程，只挑核心逻辑讲，真正该过程远比这复杂。\r\n\r\n**主线程的消息又是哪来的呢?** 当然是App进程中的其他线程通过Handler发送给主线程，请看接下来的内容：\r\n\r\n最后，从进程与线程间通信的角度，通过一张图加深大家对App运行过程的理解：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/handler_sourcecode/002.jpg)\r\n\r\n**system_server进程是系统进程**，java framework框架的核心载体，里面运行了大量的系统服务，比如这里提供ApplicationThreadProxy（简称ATP），ActivityManagerService（简称AMS），这个两个服务都运行在system_server进程的不同线程中，由于ATP和AMS都是基于IBinder接口，都是binder线程，binder线程的创建与销毁都是由binder驱动来决定的。\r\n\r\n**App进程则是我们常说的应用程序**，主线程主要负责Activity/Service等组件的生命周期以及UI相关操作都运行在这个线程； 另外，每个App进程中至少会有两个binder线程 ApplicationThread(简称AT)和ActivityManagerProxy（简称AMP），除了图中画的线程，其中还有很多线程，比如signal catcher线程等，这里就不一一列举。\r\n\r\nBinder用于不同进程之间通信，由一个进程的Binder客户端向另一个进程的服务端发送事务，比如图中线程2向线程4发送事务；而handler用于同一个进程中不同线程的通信，比如图中线程4向主线程发送消息。\r\n\r\n**结合图说说Activity生命周期，比如暂停Activity**，流程如下：\r\n\r\n- 1.线程1的AMS中调用线程2的ATP；（由于同一个进程的线程间资源共享，可以相互直接调用，但需要注意多线程并发问题）\r\n- 2.线程2通过binder传输到App进程的线程4；\r\n- 3.线程4通过handler消息机制，将暂停Activity的消息发送给主线程；\r\n- 4.主线程在looper.loop()中循环遍历消息，当收到暂停Activity的消息时，便将消息分发给ActivityThread.H.handleMessage()方法，再经过方法的调用，最后便会调用到Activity.onPause()，当onPause()处理完后，继续循环loop下去。\r\n \r\n# 总结\r\n\r\n\r\n回顾一下之前的 `Handler` 流程，总结一下就是：\r\n\r\n- 创建 `Handler` : 因为 `Handler` 需要获取当前线程的 `Looper` ，如果不是在主线程创建，则需要先调用 `Looper.prepare()` 给当前线程创建一个 `Looper`\r\n-  `Looper` 初始化 : 一个 `Looper` 在创建的同时，也会创建一个 `MessageQuene` 与之对应\r\n- 发送 `Message` : `Handler` 调用 `postXXX` 方法，会通过 `Looper` 进入到 `MessageQuene` 的 `enqueueMessage(...)` 方法。这个方法会在 `MessageQuene` 中维护的 `Message` 队列插入 `Message`，插入顺序根据  `Message` 的 `when` 来决定\r\n- 复用 `Message` : `Message` 中存在一个静态变量 `sPool` ,它用于复用  `Message` ，每当 `MessageQuene` 中的 `Message` 被回收掉时，就会调用 `Message` 对象的 `recycleUnchecked()` 方法， `sPool` 就会新增一个节点。它的最大长度是50。而 `Handler` 调用 `postXXX` 相关方法时候，传递给 `MessageQuene` 的 `Message` 就是从这里复用的，没有可复用的对象时候，会创建新的 `Message` \r\n- 进入循环：通过 `Looper` 的 `loop()` 方法，会一直调用 `MessageQuene` 的 `next()` 方法来获取 `Message`，并通过这个  `Message` 中的 `Handler`对象 `target` 的 `dispatchMessage()` 方法，来进行事件的分发\r\n- 事件分发：有三个优先级分别处理 `msg` 对象：\r\n    - 如果 `msg` 的 `Runnable` 对象存在，交给它处理，否则下一步\r\n    - 如果 `Handler` 的 `CallBack` 对象存在，调用 `CallBack`的 `handleMessage(msg)` 方法 ，返回 **true** 的话结束，否则继续下一步\r\n    - 交给 `Handler` 的  `handleMessage(msg)` 方法\r\n- 循环结束 : `Looper` 通过 `quit()` 方法结束循环，不过主线程的 `Looper` 是无法退出的，具体原因上面已经说明\r\n\r\n\r\n那么，关于 `Handler` 相关源码就到此结束了！","HashMap源码分析":"---\ntitle: HashMap源码分析\ndate: 2020-03-10 23:49:47\nindex_img: /img/hashmap.jpg\ntags: 源码系列\n---\n\n\n# 序\n\n我到底为什么要分析HashMap的源码呢？\n\n这天是2020年3月9日，进行了一场视频面试，其中面试官问我HashMap结构是什么，因为没看过源码，所以确实不知道。\n\n正好，最近断断续续也刷了不少leecode，对于数据结构方面精进了一些，看看源码好像感觉也还蛮舒服的。于是，就开始看啦！\n\n\n# 引子\n\n先进入 `HashMap` 的类康一康吧\n\n\n```\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable{\n        ...\n    }\n```\n\n让我们一步步来\n\n可以看到 `HashMap` 继承于一个抽象类 `AbstractMap<K,V>`\n\n进去看一下 `AbstractMap<K,V>` 的内容吧\n\n\n# 分析\n\n\n\n### AbstractMap<K,V>\n\n我将这个抽象类的代码简化一下：\n\n\n```\npublic abstract class AbstractMap<K,V> implements Map<K,V>{\n    public abstract Set<Entry<K,V>> entrySet();\n    \n    \n    public boolean containsValue(Object value) {...}\n    \n    public boolean containsKey(Object value){...}\n    \n    public V get(Object key) {...}\n    \n    public V put(K key, V value) {\n        throw new UnsupportedOperationException();\n    }\n    \n    public boolean equals(Object o) {...}\n    \n    public int hashCode() {...}\n    \n}\n```\n\n上面的这些方法，就是我们日常使用中，最主要的一些方法。我们简单的看其中几个\n\n#### containsValue(Object value)\n\n\n```\n    public boolean containsValue(Object value) {\n        Iterator<Entry<K,V>> i = entrySet().iterator();\n        if (value==null) {\n            while (i.hasNext()) {\n                Entry<K,V> e = i.next();\n                if (e.getValue()==null)\n                    return true;\n            }\n        } else {\n            while (i.hasNext()) {\n                Entry<K,V> e = i.next();\n                if (value.equals(e.getValue()))\n                    return true;\n            }\n        }\n        return false;\n    }\n```\n\n`containsValue(Object value)` 用于判断是否包含这个对象，就是遍历 `Set<Entry<K,V>>` 去进行对比，其中也有对值为 `null` 的判断，这说明，`AbstractMap` 中，值是可以为  `null` 的\n\n#### get(Object key)\n\n\n```\n    public V get(Object key) {\n        Iterator<Entry<K,V>> i = entrySet().iterator();\n        if (key==null) {\n            while (i.hasNext()) {\n                Entry<K,V> e = i.next();\n                if (e.getKey()==null)\n                    return e.getValue();\n            }\n        } else {\n            while (i.hasNext()) {\n                Entry<K,V> e = i.next();\n                if (key.equals(e.getKey()))\n                    return e.getValue();\n            }\n        }\n        return null;\n    }\n```\n和 `containsValue(Object value)` 差不多，也是通过遍历。可以看出，`key` 也是可以为 `null` 的\n\n\n看了上面两个，明显发现有点不对劲了？\n\n因为 `HashMap` 的 `containsKey` 和 `get` 的时间复杂度不应该是 **O(1)** 吗？上面用到了遍历的话，时间复杂度就是 **O(n)** 了\n\n显然，这样是8对的！因为这些方法都不是抽象方法，所以作为 `AbstractMap` 的子类， `HashMap` 一定是自己实现了这些方法。接下来，我们看一看 `HashMap`\n\n不过，在此之前，我们需要看一下上面比较关键的 `Entry<K,V>` 究竟是个什么东西\n\n### Entry<K,V>\n\n\n```\n    interface Entry<K, V> {\n        K getKey();\n        \n        V getValue();\n        \n        V setValue(V value);\n        \n        boolean equals(Object o);\n        \n        int hashCode();\n        \n        public static <K extends Comparable<? super K>, V> Comparator<Map.Entry<K, V>> comparingByKey() {...}\n        \n        public static <K extends Comparable<? super K>, V> Comparator<Map.Entry<K, V>> comparingByValue() {...}\n        ...\n    }\n    \n```\n\n可以看到  `Entry<K,V>` 是一个实现了一些基础操作的接口，而在 `HashMap` 中，由`Node` 对象实现了这个接口\n\n\n\n### Node<K,V>\n\n主要看其中的某些方法\n\n```\nstatic class Node<K,V> implements Map.Entry<K,V>{\n        final int hash;\n        final K key;\n        V value;\n        Node<K,V> next;\n        \n        ...\n        public final int hashCode() {\n            return Objects.hashCode(key) ^ Objects.hashCode(value);\n        }\n\n\n        public final boolean equals(Object o) {\n            if (o == this)\n                return true;\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n                if (Objects.equals(key, e.getKey()) &&\n                    Objects.equals(value, e.getValue()))\n                    return true;\n            }\n            return false;\n        }\n}\n```\n\n因为每个 **Node** 还存储了一个 `Node<K,V> next` 对象，所以 **Node** 其实就是链表结构\n\n`hashCode()` 这个方法，结合了 `key` 与 `value`，至于 `Objects.hashCode(key)` 的具体逻辑，主要是调用 `identityHashCode(Object obj)` 根据内存地址来得出 **hasCode** ，这里就不展示了\n\n\n接下来把目光放到  `HashMap` 上来吧\n\n\n### HashMap\n\n简化代码入下：\n\n\n```\npublic class HashMap<K,V> extends AbstractMap<K,V>implements Map<K,V>, Cloneable, Serializable{\n    \n    transient Node<K,V>[] table;\n    \n    transient Set<Map.Entry<K,V>> entrySet;\n    \n    transient int size;\n    \n    final void putMapEntries(Map<? extends K, ? extends V> m, boolean evict){...}\n    \n    public V get(Object key) {...}\n    \n    final Node<K,V> getNode(int hash, Object key) {...}\n    \n    public boolean containsKey(Object key) { return getNode(hash(key), key) != null; }\n    \n    public V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n    }\n    \n    final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {...}\n    \n    public boolean containsValue(Object value) {...}\n    \n}\n```\n\n\n有了上面的一些铺垫，我们直接从 `put(...)` 方法开看\n\n可以看到 `put` 调用的是 `putVal`\n\n#### putVal(...)\n\n看一看 `putVal` 的详细内容\n\n\n```\n\n    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K,V> e; K k;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else {\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n先看第一段\n\n```\nif ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n```\n\n这里表示当 **tab** 为 **null** 或者没有内容的时候，对 **tab** 进行初始化\n\n初始化的关键代码就是 `resize()` 方法了，看一下 `resize()` \n\n##### resize()\n\n```\n    final Node<K,V>[] resize() {\n    ...\n    //判断数组是否初始化过，没有初始化就初始化，否则扩容\n    ...\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            ...\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n```\nresize()的作用有两个，分别是 **初始化table** 或者 **给table扩容**\n\n上面的逻辑主要分为两段：\n\n- 前面省略号中的逻辑如下:\n\n     >具体就是：如果数组为空，用默认值16去初始化。  \n     否则，数组扩容一倍。这里还涉及到另一个参数：threshold，它表示数组扩容的阙值。每当数组元素到达阙值时，就说明数组需要扩容了，threshold每次也扩大一倍，初始的threshold数值为 16*0.75\n    \n\n- 后一段代码逻辑如下:\n    > 如果旧的table数组不为空，则需要遍历它，并放入新的table中去，也就是进行扩容。其中，元素在数组中存放的索引，是根据哈希算法来生成的\n\n哈希算法看起来比较奇幻：`newTab[e.hash & (newCap - 1)] = e`\n\n因为新数组的长度就是 **newCap** ，每次数组都扩容一倍，所以**newCap**一定是2的次幂数 。不过上面这个代码到底是如何运作的呢？我还不是太清楚原理，但是我作了一个实验\n\n\n```\n    @Test\n    public void test() {\n        int newCap = 1 << 4;//16\n        int[] newTab = (int[])new int[newCap];\n        for(int i = 0; i < 8; i++){\n            Object o = i;\n            newTab[o.hashCode() & (newCap - 1)] = i;\n        }\n        System.out.println(Arrays.toString(newTab));\n    }\n```\n\n上面这段代码打印内容如下：\n\n```\n[0, 1, 2, 3, 4, 5, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0]\n```\n看起来非常的神奇。不过这里就暂时先不去管这个算法的原理了。\n\n我们还注意到一段代码：\n\n```\nelse if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n```\n\n这里又引入了一个新的概念： **TreeNode** ，不过暂时我们还不需要管它，继续看 `putVal(...)` 方法后面的内容吧\n\n大概逻辑如下：\n\n> 如果 put 时，数组对应index的Node为null，则创建一个新的放进去  \n如果Node不为null，则通过 hash 值、key来进行对比  \n如果对比值相同的话，用新Node替换旧Node  \n不相同的话(哈希冲突)，遍历旧Node，将新Node存放在旧Node的尾部  \n如果Node节点数量超过8个了的话，通过treeifyBin()将Node转换为TreeNode\n\n上面看到的 `TreeNode` 对象，其实就是 **红黑树**\n\n关于 `putValue` 的分析就到这里，接下来是 `get(Object key)` 方法\n\n\n```\n    public V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;\n    }\n```\n\n直接来看 `getNode(...)` 吧\n\n#### getNode(...)\n\n\n```\n    final Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n            if (first.hash == hash && // always check first node\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;\n            if ((e = first.next) != null) {\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n    }\n```\n\n上面的逻辑很清晰，先是通过 `(n - 1) & hash` 来获得 `key` 在 `table` 数组中对应的 **index**   \n如果该 `index` 对应的 **Node** 为空，则说明不存在该元素，返回null  \n如果不为空，且 `hash` 值与 `key` 值都相同则返回该 **Node** 的值，hash不同的话，遍历链表找到相同的返回，否则返回null\n\n\n\n到这里 **HashMap** 的源码就分析完成啦，关于 **TreeNode** ，后面有机会再介绍吧！\n\n\n# 总结\n\n关于 `HashMap` 的总结，大致如下\n\n- 数据结构：由 **数组** + **链表** 组成，链表就是 `Node<K,V>` 对象，通过 **哈希算法** 将 `Node<K,V>` 在数组中的索引与 `Key` 相关联，因为这个算法，在数组中 **put** 和 **get** 的耗时都是 **O(1)**\n- 数组扩容：因为是通过数组存储的 `Node<K,V>` 对象，我们知道，数组的长度是无法改变的，所以这里会因为 **put** 到了一定数量后就需要创建更大的新数组。\n- 扩容规则：初始的数组长度为 **16**, 扩容**阙值**为 `16 * 0.75` = **12**, 之后每当数组中元素数量到达**阙值**时，就会对数组进行扩容。数组长度每次增加一倍，**阙值**也增加一倍\n- 哈希冲突：其实可以很明显的想到，如果只需要存键值对的话，为什么还需要将 `Node<K,V>` 链表放在数组里，直接放一个普通的对象不就可以了吗，比如 `class Obj<K,V>{var key: K, var value: V}` ，那为什么不这样呢？还是因为 **哈希算法** 可能导致的 **哈希冲突** 问题。也就是说可能存在 **hash(Key1) == hash(Key2)** 的情况，这时候就需要用到链表了，将有冲突的对象添加到链表里。看过源码也知道，当这个链表的长度超过 **8** 时，链表会转换成 **红黑树**，即 **Node<K,V>** 变成 **TreeNode<K,V>**\n\n\n那么 `HashMap` 的源码就分析就暂时结束啦！\n\n\n","Kotlin学习笔记（第三章）":"---\r\ntitle: Kotlin笔记(二):基础篇plus\r\ndate: 2018-10-01 21:49:47\r\nindex_img: /img/kotlin_2.png\r\ntags: Kotlin\r\n---\r\n\r\n### 1.顶层函数和属性\r\n\r\n在Kotlin中，可以把那些工具类里的函数直接放到代码文件的顶层，不用从属于任何的类。这些放在文件顶层的函数依然是包内的成员，如果你需要从包外访问它，则需要import，但不再需要额外包一层\r\n\r\n\r\n### 2.给别人的类添加方法：扩展函数和属性\r\n\r\n扩展函数非常简单，它就是一个类的成员函数，不过定义在类的外面。举个例子：\r\n\r\n```\r\npackage strings \r\nfun String.lastChar(): Char = this.get(this.length - 1) //this可以省略\r\n```\r\n从某种意义上说，你已经为String类添加了自己的方法。即使字符串不是代码的一部分，也没有类的源代码，你仍然可以在自己的项目中根据需要去扩展方法。\r\n\r\n> 注意，扩展函数并不允许你打破它的封装性。和在类内部定义的方法不同的是，扩展函数不能访私有的或者是受保护的成员。 \r\n>    \r\n> 对于你定义的一个扩展函数，它不会自动地在整个目范围内生效。相反，如果你要使用它，需要进行导入\r\n>      \r\n> 扩展函数并不存在重写，因为Kotiin会把它们当作静态函数对待\r\n\r\n\r\n下面是声明一个扩展属性：\r\n\r\n```\r\nval String.lastChar: Char get() = get(length - 1) \r\n```\r\n\r\n可以看到，和扩展函数一样，扩展属性也像接收者的一个普通的成员属性一样。这里，必须定义getter函数，因为没有支持字段，因此没有默认getter的实现。同理，初始化也不可以：因为没有地方存储初始值。\r\n\r\n    注意，当你需要从Java中访问扩展属性的时候，应该显式地调用它的getter函数\r\n    \r\n    \r\n### 3.可变参数：让函数支持任意数量的参数\r\n\r\n当你在调用一个函数来创建列表的时候，可以传递任意个数的参数给它：\r\n\r\n```\r\nval list= list0f(2, 3, 5, 7, 11) \r\n```\r\nKotlin的可变参数与Java类似，但语法略有不同：Kotlin在该类型之后不会再使用三个点，而是在参数上使用vararg修饰符。\r\n\r\nKotlin和Java 之间的另一个区别是，当需要传递的参数己经包装在数组中时，调用该函数的语法。在Java中，可以按原样传递数组，而Kotlin 则要求你显式地解包数组，以便每个数组元素在函数中能作为单独的参数来调用。从技术的角度来讲，这个功能被称为展开运算符，而使用的时候，不过是在对应的参数前面放一个*：\r\n\r\n```\r\nfun main(args: Array<String>）{\r\nval list = listOf(\"args:”,*args) \r\nprintln(list) \r\n}\r\n\r\n```\r\n\r\n\r\n### 4.键值对的处理：中缀调用和解构声明\r\n\r\n可以使用 mapOf 函数来创建 map:\r\n\r\n```\r\nval map= mapOf(l to \"one\"， 7 to \"seven\"， 53 to \"fifty-three\")\r\n```\r\n这行代码中的单词to不是内置的结构，而是一种特殊的函数调用，被称为中缀调用。 \r\n\r\n在中缀调用中，没有添加额外的分隔符，函数名称是直接放在目标对象名称和 参数之间的。以下两种调用方式是等价的：\r\n\r\n\r\n```\r\n1.to(\"one\")\r\n1 to \"one\"\r\n```\r\n\r\n中缀调用可以与只有一个参数的函数一起使用，无论是普通的函数还是扩展函 数。要允许使用中缀符号调用函数，需要使用 infix 修饰符来标记它。下面是一个 简单的 to 函数的声明：\r\n\r\n\r\n```\r\ninfix fun Any.to(other: Any) = Pair(this, other)\r\n```\r\n\r\nto 函数是一个扩展函数，可以创建一对任何元素，这意味着它是泛型接收者的 扩展：可以使用 1 to \"one\" 、\"one\" to 1、list to list.size()等写法。 \r\n\r\n\r\n\r\n### 5.让你的代码更整洁：局部函数和扩展\r\n\r\nKotlin可以在函数中嵌套类中提取的函数。这样，既可以获得所需的结构，也无须额外的语法开销。\r\n\r\n举个栗子：\r\n\r\n```\r\nclass User(val id: Int, val name: String, val address: String) \r\n\r\nfun saveUser(user : User){\r\n    if(user.name.isEmpty()){\r\n        ...\r\n    }\r\n    if(user.address.isEmpty()){\r\n        ...\r\n    }\r\n    //保存...\r\n}\r\n```\r\n如果将验证代码放到局部函数中，可以摆脱重复，并保持清晰的代码结构，可以这样做 ：\r\n\r\n\r\n```\r\nclass User(val id: Int, val name: String, val address: String) \r\n\r\nfun saveUser(user : User){\r\n    fun validate(user: User, value: String, fieldName: String){\r\n        if(value.isEmpty()){\r\n            ...\r\n        }\r\n    }\r\n    \r\n    validate (user, user.name, \"Name\")\r\n    validate (user, user.address, \"Address\")\r\n    //保存...\r\n    \r\n}\r\n```\r\n\r\n上面的代码看起来好多了，而且局部函数可以访问所在函数中的所有参数和变量。 我们可以利用这一点，去掉冗余的User参数，这里就不再演示了\r\n\r\n我们可以继续改进，把验证逻辑放到 User 类的扩展函数中。\r\n\r\n```\r\nclass User(val id: Int, val name: String, val address: String) \r\n\r\nfun User.validateBeforeSave(){\r\n    fun validate(value: String, fieldName: String){\r\n        if(value.isEmpty()){\r\n            ...\r\n        }\r\n    }\r\n    \r\n    validate (user.name, \"Name\")\r\n    validate (user.address, \"Address\")\r\n}\r\n\r\n\r\nfun saveUser(user : User){\r\n    user.validateBeforeSave()\r\n    //保存...\r\n}\r\n```\r\n\r\n**小结：**\r\n\r\n- Kotlin没有定义自己的集合类，而是在Java集合类的基础上提供了更丰富的API。\r\n\r\n- Kotlin可以给函数参数定义默认值，这样大大降低了重载函数的必要性，而且命名参数让多参数函数的调用更加易读。\r\n\r\n- Kotlin允许更灵活的代码结构：函数和属性都可以直接在文件中声明，而不仅仅是在类中作为成员。\r\n\r\n- Kotlin可以用扩展函数和属性来扩展任何类的API，包括在外部库中定义的类，而不需要修改其源代码，也没有运行时开销。 \r\n\r\n- 中缀调用提供了处理单个参数的，类似调用运算符方法的简明语法。\r\n\r\n- Kotlin为普通字符串和正则表达式都提供了大量的方便字符串处理的函数。 \r\n\r\n- 三重引号的字符串提供了一种简洁的方式，解决了原本在Java中需要进行大量啰嗦的转义和宇符串连接的问题。\r\n\r\n- 局部函数帮助你保持代码整洁的同时，避免重复。\r\n\r\n\r\n\r\n","Kotlin学习笔记（第二章）":"---\ntitle: Kotlin笔记(一):基础篇\ndate: 2018-09-30 21:49:47\nindex_img: /img/kotlin_1.png\ntags: Kotlin\n---\n\n>  在2017年的Google开发者大会上，Kotlin正式作为Android的官方开发语言闪亮登场。而现在已经到了2018年的下半年末，身为一名Android开发者，如果不会一点Kotlin，总感觉少了什么。  \r\n>   \r\n> 于是乎，我准备动手学一学这门“年轻”的新语言了。不过新学一些东西往往会因为知识的消化需要时间而导致知识接收的效率不高，所以这时候好记性不如烂笔头的优势才得以体现嘛！  \r\n> \r\n> 所以，初学阶段，我还是准备记一记笔记，这样也许会对我学这门语言有所帮助吧？!\r\n\r\n\r\n关于Kotlin的官方文档，地址如下：\r\n\r\n[Kotlin学习](https://www.kotlincn.net/docs/reference/)\r\n<!--more--> \r\n\r\n### 1.在 Kotlin 中，if是表达式，而不是语句。\r\n\r\n 语句和表达式的区别在于，表达式有值，并且能作为另一个表达式的一部分使用；而语句总是包围着它的代码块中的顶层元素，并且没有自己的值。\r\n- 在Java中，所有的控制结构都是语句。而在Kotlin中，除了循环（ for, do 和 do/while ）以外大多数控制结构都是 表达式。\r\n这种结合控制结构和其他表达式的能力让你可以简明扼要地表示许多 常见的模式，稍后你会在本书中看到这些内容。\r\n- 另一方面，Java中的赋值操作是表达式，在Kotlin中反而变成了语句。这有助于避免比较和赋值之间的混淆，而这种混淆是常见的错误来源。\r\n\r\n\r\n### 2.声明变量的关键字有两个 ：\r\n\r\n- val （来自 value） 一一不可变引用。使用 val 声明的变量不能在初始化之 后再次赋值。它对应的是 Java 的 final 变量。  \r\n- var （来自 variable） 一一可变引用。这种变量的值可以被改变。这种声明对 应的是普通（非 final）的 Java 变量。\r\n\r\n\r\n### 3.局部变量的引用\r\n\r\n和许多脚本语言一样， Kotlin 让你可 以在字符串字面值中引用局部变量，只需要在变量名称前面加上字符$。\r\n\r\n这等价于 Java 中的字符串连接（ \"Hello,\"+ name ＋\"！\"），效率一样但是更紧凑。\r\n\r\n```\r\nfun main(args: Array<String>) {\r\n    val name = if(args.size > 0) args[0] else \"Kotlin\"\r\n    println(\"Hello, $name !\")\r\n}\r\n```\r\n\r\n\r\n还可以引用更复杂的表达式，而不是仅限于简单的变量名称，只需要把表达式 用花括号括起来.\r\n\r\n### 4.在Java中可以用switch语句完成的，而Kotlin 对应的结构是when\r\n\r\n```\r\nfun getMnemonic(color: Color) = \r\nwhen (color) { \r\nColor . RED ->”Richard\" \r\nColor.ORANGE ->”Of” \r\nColor.YELLOW ->”York\" \r\nColor .GREEN ->”Gave” \r\nColor.BLUE ->”Battle\" \r\nColor ．工NDIGO ->”In” \r\nColor.VIOLET ->”Vain \r\n}\r\n```\r\n\r\n  在一个 when 分支上合并多个选项：\r\n  \r\n```\r\nfun getWarmth(color: Color) = when(color) {\r\nColor.RED, Color.ORANGE, Color.YELLOW - > ”warm”\r\nColor.GREEN -> ”neutral”\r\nColor.BLUE, Color.INDIGO, Color.VIOLET ->”cold”\r\n}\r\n```\r\n上面的代码中，也可以导入枚举常量后不用限定词就可以访问。比如去掉花括号里的Color也是可以的。\r\n\r\n> Kotlin中的when结构比Java中的switch强大得多。switch要求必须使用常量（枚举常量、字符串或者数字字面值）作为分支条件，和它不一样， when允许使用任何对象。\r\n\r\n\r\n\r\n### 5.类型判断\r\n\r\n在Kotlin中，你要使用is检查来判断一个变量是否是某种类型。is检查和Java中的instanceOf相似，不过在instanceOf检查之后还需要显式地加上类型转换。\r\n\r\n在Kotlin中，编译器帮你完成了这些工作。如果你检查过一个变量是某种类型，后面就不再需要转换它，可以就把它当作你检查过的类型使用。\r\n\r\n使用as关键字来表示到特定类型的显式转换；\r\n\r\n\r\n### 6.循环中的\"in\"关键字\r\n\r\nKotlin里面关键字“in”有许多作用，比如检查区间的成员；作为when的分支；在for循环中使用等。关于in如何在list中使用，下章再介绍\r\n\r\n\r\n### 7.关于\"try\"\r\n\r\nKotlin中的try关键字就像if和when一样,引入了一个表达式，可以把它的值赋给一个变量。不同于if，你总是需要用花括号把语句主体括起来。和其他语句一样，如果其主体包含多个表达式，那么整个 try 表达式的值就是最后一个表达式的值。","Kotlin学习笔记（第五章）":"---\ntitle: Kotlin笔记(四):基础篇most plus\ndate: 2018-10-03 21:49:47\nindex_img: /img/kotlin_4.png\ntags: Kotlin\n---\n\n\n### 1.成员引用\r\n\r\nKotlin和Java8一样，如果把函数转换成一个值，你就可以传递它。  \r\n> 使用:: 运算符来转换 ：\r\n\r\n```\r\nval getAge = Person::age \r\n```\r\n这种表达式称为成员引用，它提供了简明语法，来创建一个调用单个方法或者 访问单个属性的函数值。双冒号把类名称与你要引用的成员（一个方法或者一个属性）名称隔开\r\n\r\n### 2.集合的函数式API\r\n\r\n**filter** 函数遍历集合并选出应用给定 **lambda** 后会返回 **true** 的那些元素：\r\n\r\n```\r\n>> val list= listOf(l, 2, 3, 4) \r\n>> println(list.filter{it % 2 == 0}) \r\n```\r\n\r\n**filter** 函数可以从集合中移除你不想要的元素，但是它并不会改变这些元素。 元素的变换是 **map** 的用武之地。 \r\n\r\n**map** 函数对集合中的每一个元素应用给定的函数并把结果收集到一个新集合。可以把数字列表变换成它们平方的列表，比如：\r\n\r\n```\r\n>> val list= listOf(l, 2, 3, 4) \r\n>> println(list.map { it * it }\r\n{1, 4, 9, 16}\r\n```\r\n\r\n### 3.\"all\"\"any\"\"count\"和\"find\"：对集合应用判断式\r\n\r\n检查集合中的所有元素是否都符合某个条件（或者它的变种，是否存在符合的元素）。Kotlin中，它们是通过 **all** 和 **any** 函数表达的。 \r\n\r\n\r\n```\r\nval canBeinClub27 = { p: Person - > p.age <= 27 } \r\n```\r\n> 如果你对是否所有元素都满足判断式感兴趣，应该使用 **all** 函数：\r\n\r\n```\r\n>> val people= listOf(Person (\"Alice\", 27), Person(\"Bob\", 31))\r\n>> println( people.all(canBeinClub27) ) \r\nfalse\r\n```\r\n> 如果你需要检查集合中是否至少存在一个匹配的元素，那就用 **any** :\r\n\r\n```\r\n>> println(people any(canBeinClub27)) \r\ntrue \r\n```\r\n> 如果你想知道有多少个元素满足了判断式，使用 **count** : \r\n\r\n```\r\n>> val people= listOf(Person(\"Alice\", 27) , Person (\"Bob\", 31)) \r\n>> println(people.count(canBeinClub27))\r\n1\r\n```\r\n> 要找到一个满足判断式的元素，使用 **find** 函数 ：\r\n\r\n```\r\n>> val people= listOf(Person(\"Alice\"， 27) , Person(\"Bob\", 31)) \r\n>> println(people.find(canBeinClub27)) \r\nPerson(name=Alice, age=27) \r\n```\r\n### 4.groupBy ：把列表转换成分组的 map\r\n\r\n假设你需要把所有元素按照不同的特征划分成不同的分组。例如，你想把人按年龄分组，相同年龄的人放在一组。把这个特征直接当作参数传递十分方便。**groupBy** 函数可以帮你做到这一点：\r\n\r\n```\r\n>> val people= listOf(Person(\"Alice\", 31), Person(\"Bob\", 29), Person (\"Carol\", 31))\r\n>> println(people.groupBy {it.age})\r\n```\r\n这次操作的结果是一个 **map**，是元素分组依据的键（这个例子中是age）和元素分组（persons）之间的映射\r\n\r\n### 5.flatMap 和 flatten ：处理嵌套集合中的元素 \r\n\r\n假设你有一堆藏书，使用 Book 类表示 ：\r\n\r\n```\r\nclass Book (val title: String, val authors: List<String>) \r\n```\r\n每本书都可能有一个或者多个作者，可以统计出图书馆中的所有作者的 set : \r\n\r\n```\r\nbooks.flatMap { it.authors } toSet() \r\n```\r\n**flatMap** 函数做了两件事情：首先根据作为实参给定的函数对集合中的每个元素做变换（或者说映射），然后把多个列表合并（或者说平铺）成一个列表。 \r\n\r\n> **注意，如果你不需要做任何变换，只是需要平铺一个集合，可以使用flatten函数：listOfLists.flatten() 。**\r\n\r\nKotlin 标准库参考文档有说明，**filter** 和 **map** 都会返回一个列表。这意味着元素过多的时候，（链式）调用就会变得十分低效。为了提高效率，可以把操作变成使用序列，而不是直接使用集合，下面是对比的例子\r\n\r\n\r\n```\r\npeople.map(Person: :name) .filter { it.startsWith(\"A\")｝\r\n```\r\n转化为：\r\n```\r\npeople.asSequence()\r\n    .map (Person: : name)\r\n    .filter{it.startsWith(\"A\")}\r\n    .tolist\r\n```\r\nKotlin惰性集合操作的入口就是 **Sequence** 接口。这个接口表示的就是一个可以逐个列举元素的元素序列。 \r\n\r\n可以调用扩展函数 **asSequence** 把任意集合转换成序列，调用  **toList** 来做反向的转换。 \r\n\r\n\r\n### 6.使用Java函数式接口\r\n\r\n **OnClickListener** 接口只有一个抽象方法。这种接口被称为 **函数式接口**，或者 **SAM接口**，**SAM** 代表抽象方法。JavaAPI中随处可见像**Runnable**和**Callable**这样的函数式接口，以及支持它们\r\n 的方法。 Kotlin 允许你在调用接收函数式接口作为参数的方法时使用 **lambda**，来保证你的 Kotlin代码既整洁又符合习惯。\r\n\r\n可以把 **lambda** 传给任何期望函数式接口的方法。例如，下面这个方法，它有一个 **Runnable** 类型的参数：\r\n\r\n```\r\n/* Java */ \r\nvoid postponeComputation(int delay, Runnable computation); \r\n```\r\n下面是显式地创建一个实现了 **Runnable** 的匿名对象的例子：\r\n\r\n```\r\npost postponeComputation(1OOO, object : Runnable { \r\n    override fun run() {\r\n    println(42) \r\n    }\r\n)}\r\n```\r\n\r\n\r\n在 Kotlin 中，可以调用它并把一个 **lambda** 作为实参传给它。编译器会自动把它转换成一个 **Runnable** 的实例：\r\n\r\n```\r\npostponeComputation(lOOO) { println(42) }\r\n```\r\n完全等价的实现应该是下面这段代码中的显式**object**声明，它把**Runnable**实例存储在一个变量中，并且每次调用的时候都使用这个变量：\r\n\r\n```\r\nval runnable = Runnable { println(42) } \r\nfun handleComputation(){ postponeComputation(1OOO, runnable)} \r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","Kotlin学习笔记（第六章）":"---\r\ntitle: Kotlin笔记(五):基础篇latest\r\ndate: 2018-10-05 21:49:47\r\nindex_img: /img/kotlin_5.png\r\ntags: Kotlin\r\n---\r\n\r\n### 1.可空类型\r\n\r\n问号可以加在任何类型的后面来表示这个类型的变量可以存储 null 引用 ： String?、 Int?、 MyCustomType? ，等等\r\n\r\n一旦你有一个可空类型的值，能对它进行的操作也会受到限制。例如，不能再调用它的方法 \r\n```\r\n>> fun strLenSafe(s: String?) = s.length() \r\nERROR: only safe (?.) or non null asserted (!!.) calls are allowed on a nullable receiver of type kotlin.String?\r\n```\r\n也不能把它赋值给非空类型的变量 ：\r\n```\r\n>> val x: String? = null \r\n>> var y: String = x \r\nERROR: Type mismatch: inferred type is String? but String was expected \r\n```\r\n也不能把可空类型的值传给拥有非空类型参数的函数 ：\r\n```\r\n>> strLen(x) \r\nERROR: Type mismatch: inferred type is String? but String was expected \r\n```\r\n那么你可以对它做什么呢？最重要的操作就是和 null 进行比较。 而且一旦你 进行了比较操作，编译器就会记住，并且在这次比较发生的作用域内把这个值当作非空来对待\r\n\r\n\r\n### 2.安全调用运算符：\"?.\"\r\n\r\n> Kotlin的弹药库中最有效的一种工具就是安全调用运算符：?.，它允许你把一 次null检查和一次方法调用合并成一个操作。\r\n\r\n例如，表达式 s?.toUpperCase() 等同于下面这种烦琐的写法：if(s!=null) s.toUpperCase() else null。 \r\n\r\n### 3.Elvis运算符：\"?:\" \r\n\r\nKotlin 有方便的运算符来提供代替null的默认值。它被称作**Elvis运算符**（或者 null合并运算符，如果你喜欢听起来更严肃的名称）。下面展示了它是如何使用的：\r\n```\r\nfun foo(s: String?) {\r\n    val t: String= s?:\"\"\r\n}\r\n```\r\n*Elvis 运算符接收两个运算数，如果第一个运算数不为null，运算结果就是第 一个运算数；如果第一个运算数为null，运算结果就是第二个运算数。*\r\n\r\n### 4.安全转换：\"as?\"\r\n\r\n> as? 运算符尝试把值转换成指定的类型，如果值不是合适的类型就返回 null\r\n\r\n一种常见的模式是把安全转换和 Elvis 运算符结合使用。例如，实现 equals 方法的时候这样的用法非常方便。\r\n\r\n\r\n```\r\nclass Person(val firstNarne: String, val lastNarne: String){\r\n    override fun equals(o: Any?): Boolean {\r\n        val otherPerson = o as? Person?: return false\r\n        return otherPerson.firstNarne == firstNarne && otherPerson.lastNarne == lastNarne \r\n    }\r\n    \r\n    override fun hashCode(): Int = firstNarne.hashCode() * 37 + lastNarne.hashCode() \r\n}\r\n\r\n\r\n>> val pl = Person ( \"Drnitry\",\"Jernerov\") \r\n>> val p2 = Person ( \"Drnitry\",\"Jernerov\") \r\n>> println (pl == p2) \r\ntrue\r\n>> println(pl.equals(42)) \r\nfalse \r\n```\r\n\r\n### 5.非空断言：\"!!\"\r\n\r\n> 非空断言是 Kotlin 提供给你的最简单直率的处理可空类型值的工具。它使用双感叹号表示，可以把任何值转换成非空类型。如果对 null 值做非空断言，则会抛出异常。\r\n\r\n某些问题适合用非空断言来解决。当你在一个函数中检查一个值是否为null，而在另一个函数中使用这个值时，这种情况下编译器无法识别这种用法是否安全。如果你确信这样的检查一定在其他某个函数中存在，你可能不想在使用这个值之前重复检查，这时你就可以使用非空断言。\r\n\r\n 当你使用 !! 并且它的结果是异常时， 异常调用械的跟踪信息只表明异常发生在哪一行代码，而不会表明异常发生在哪一个表达 式。 为了让跟踪信息更清晰精确地表示哪个值为 null，最好避免在同一行中使用多个!!断言\r\n\r\n### 6.\"let\"函数\r\n\r\n> let 函数让处理可空表达式变得更容易。 和安全调用运算符一起，它允许你对表达式求值，检查求值结果是否为 null，并把结果保存为一个变量。 所有这些动作都在同一个简洁的表达式中。 \r\n\r\n下面举个栗子：\r\n\r\n```\r\nfun sendEmailTo(email: String) { /* ... */ } \r\n```\r\n不能把可空类型的值传上面给这个函数：\r\n\r\n\r\n```\r\n>> val email: String? = ...\r\n>> sendEmailTo(email) \r\nERROR: Type mismatch: inferred type is String? but String was expected \r\n```\r\n必须显式地检查这个值不为 null:\r\n\r\n```\r\nif (email != null) sendEmailTo(email)\r\n```\r\n如果使用了let函数，会是下面这样子的：\r\n\r\n```\r\nemail?.let { email -> sendEmailTo(email) } \r\n```\r\n**let** 函数只在 email 的值非空时才被调用，所以你就能在 lambda 中把 email 当作非空的实参使用。\r\n使用自动生成的名字 it 这种简明语法之后，上面的代码就更短了 ： \r\n```\r\n email?.let{ sendEmailTo(it) ｝ \r\n```\r\n\r\n### 7.延迟初始化的属性\r\n\r\nKotlin 通常要求你在构造方法中初始化所有属性，如果某个属性是 非空类型，你就必须提供非空的初始化值。否则，你就必须使用可空类型。否则， 你就必须使用可空类型。如果你这样做，该属性的每一次访问都需要 null 检查或者 !! 运算符。\r\n```\r\nclass MyService {\r\n    fun performAction() : String = \"foo\"\r\n}\r\n\r\nclass MyTest{\r\n    private var myService: MyService? = null \r\n    \r\n    @Before fun setUp(){\r\n        myService = MyService() \r\n    }\r\n    \r\n    \r\n    @Test fun testAction(){\r\n        //必须注意可空性：要么 用!!， 要么用?.\r\n        Assert.assertEquals( \"foo\" ， myService!!.performAction() ) \r\n    }\r\n}\r\n```\r\n这段代码很难看，尤其是你要反复使用这个属性的时候。 \r\n为了解决这个问题， 使用 **lateinit** 修饰符来完成这样的声明。\r\n```\r\nclass MyService {\r\n    fun performAction() : String = \"foo\"\r\n}\r\n\r\nclass MyTest{\r\n    //声明一个不需要初始化 器的非空类型的属性\r\n    private lateinit var myService: MyService\r\n    \r\n    @Before fun setUp(){\r\n        myService = MyService() \r\n    }\r\n    \r\n    @Test fun testAction(){\r\n        //不需要 null 检查直接访问属性\r\n        Assert.assertEquals( \"foo\" ， myService!!.performAction() ) \r\n    }\r\n}\r\n```\r\n*注意， 延迟初始化的属性都是 var，因为需要在构造方法外修改它的值*\r\n\r\n### 8.\"Any\"和\"Any?\"：根类型\r\n\r\n> 和 Object 作为 Java 类层级结构的根差不多， **Any** 类型是 Kotlin 所有非空类型的超类型（非空类型的根）。\r\n>\r\n> 但是在 Java 中， Object 只是所有引用类型的超类 型（引用类型的根），而基本数据类型并不是类层级结构的一部分。\r\n>\r\n> 这意味着当你 需要 Object 的时候，不得不使用像 java.lang.Integer 这样的包装类型来表示基本数据类型的值。 **而在 Kotlin 中， Any 是所有类型的超类型（所有类型的根）**， 包括像 Int 这样的基本数据类型。 \r\n\r\n和 Java 一样，把基本数据类型的值赋给 **Any** 类型的变量时会自动装箱：\r\n\r\n```\r\nval answer: Any = 42 \r\n```\r\n*注意 **Any** 是非空类型，所以 **Any** 类型的变量不可以持有 null 值*\r\n\r\n### 9.Unit 类型 ： Kotlin 的\"void\"\r\n\r\nKotlin 中的 **Unit** 类型完成了 Java 中的 void 一样的功能。当函数没什么有意思的结果要返回时，它可以用作函数的返回类型：\r\n```\r\nfun f () : Unit { . . . } \r\n```\r\n语法上，这和写一个带有代码块体但不带类型声明的函数没有什么不同：\r\n\r\n```\r\nfun f () { .. }         //缩写版\r\n```\r\n> Unit 是一个完备的类型，可以作为类型参数，而 void 却不行。\r\n\r\n在函数式编程语言中， Unit 这个名字习惯上被用来表示“只有一个实例”，这正是 Kotlin 的 Unit 和 Java 的 void 的区别。\r\n\r\n### 10.Nothing类型：“这个函数永不返回”\r\n\r\n对某些 Kotlin 函数来说，\"返回类型\"的概念没有任何意义，因为它们从来不会成功地结束\r\n,Kotlin 使用一种特殊的返回类型 Nothing 来表示：\r\n\r\n```\r\nfun fail(message: String): Nothing { \r\n    throw IllegalStateException (message)\r\n}\r\n\r\n>> fail (\"Error occurred\")\r\njava.lang.IllegalStateException: Error occurred \r\n```\r\nNothing 类型没有任何值， 只有被当作函数返回值使用，或者被当作泛型函数 返回值的类型参数使用才会有意义。在其他所有情况下，声明一个不能存储任何值 的变量没有任何意义。 \r\n\r\n\r\n### 11.可空性和集合\r\n\r\n遍历一个包含可空值的集合并过滤掉 null 是一个非常常见的操作，因此 Kotlin 提供了一个标准库函数 **filterNotNull** 来完成它。 \r\n\r\n### 12.只读集合与可变集合 \r\n\r\nKotlin 的集合设计和 Java 不同的另一项重要特质是，它把访问集合数据的接口和修改集合数据的接口分开了。这种区别存在于最基础的使用集合的接口之中:kotlin.collections.Collection。\r\n\r\n使用 kotlin.collections.MutableCollection 接口可以修改集合中的数据。它继承了普通的 kotlin.collections.Collection 接口,还提供了方法来添加和移除元素、清空集合等。 \r\n\r\n一般的规则是在代码的任何地方都应该使用只读接口，只在代码需要修改集合的地方使用可变接口的变体\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","Kotlin学习笔记（第四章）":"---\r\ntitle: Kotlin笔记(三):基础篇more plus\r\ndate: 2018-10-02 21:49:47\r\nindex_img: /img/kotlin_3.png\r\ntags: Kotlin\r\n---\r\n\r\n### 1.接口的默认实现\r\n\r\n接口的方法可以有一个默认实现。与Java8不同的是，Java8中需要你在这样的实现上标注default关键字，对于这样的方法，Kotlin没有特殊的注解 ：只需要提供一个方法体\r\n\r\n```\r\ninterface Clickable{\r\n    fun click()\r\n    fun showOff = println(\"I'm clickable\")\r\n}\r\n```\r\n在实现接口的地方如果要显式地实现方法，在Kotlin中需要把 基类的名字放在尖括号中 ：\r\n```\r\nsuper<Clickable>.showOff() \r\n```\r\n<!--more--> \r\n### 2.定义类的继承结构\r\n\r\n    Java的类和方法默认是open的，而Kotlin中默认都是final的。 \r\n\r\n如果你想允许创建一个类的子类，需要使用 **open** 修饰符来标示这个类。此外，需要给每一个可以被重写的属性或方法添加open修饰符。\r\n\r\n> *注意，如果你重写了一个基类或者接口的成员，重写了的成员同样默认是 open的。如果你想改变这一行为，阻止你的类的子类重写你的实现，可以显式地将重写的成员标注为 **final** 。*\r\n\r\n\r\n\r\n### 3.嵌套类与内部类\r\n\r\nKotlin中没有显式修饰符的嵌套类与Java中的static嵌套类是一样的。要把它变成一个内部类来持有一个外部类的引用的话需要使用 **inner** 修饰符。\r\n\r\n在Kotlin中引用外部类实例的语法也与Java不同。需要使用 **this@Outer** 从 **Inner** 类去访问 **Outer** 类：\r\n\r\n\r\n```\r\nclass Outer{\r\n    inner class Inner{\r\n        fun getOuterReference() : Outer = this@Outer\r\n    }\r\n}\r\n```\r\n\r\n\r\n### 4.密封类：定义受限的类继承结构\r\n\r\n为父类添加一个 **sealed** 修饰符，对可能创建的子类做出严格的限制。\r\n\r\n如果你在 when 表达式中处理所有 **sealed** 类的子类，你就不再需要提供默认分支。注意， **sealed** 修饰符隐含的这个类是一个 **open** 类， 你不再需要显式地添加 **open** 修饰符。\r\n\r\n\r\n### 5.声明一个带非默认构造方法或属性的类\r\n\r\n举个栗子：\r\n\r\n```\r\nclass User constructor(_nickname: String) {\r\n    val nickname : String\r\n    \r\n    init{\r\n        nickname = _nickname\r\n    }\r\n}\r\n```\r\n在这个例子中，可以看到两个新的Kotlin关键宇：**constructor** 和 **init** 。 **constructor** 关键字用来开始一个主构造方法或从构造方法的声明。 **init** 关键字用来引入一个初始化语句块。这种语句块包含了在类被创建时执行的代码， 并会与主构造方法一起使用。\r\n\r\n> 如果你想要确保你的类不被其他代码实例化，必须把构造方法标记为 private：\r\n\r\n```\r\nclass Secretive private constructor() {}\r\n//一般这么做表示这个类是一个静态实用工具成员的容器或者是单例的\r\n```\r\n\r\n### 6.通过 getter 或 setter 访问支持字段\r\n\r\n假设你想在任何对存储在属性中的数据进行修改时输出日志，你声明了一个可变属性并且在每次 setter 访问时执行额外的代码。\r\n\r\n```\r\nclass ·user (val name: String) { \r\n    var address: String =\"unspecified\" \r\n        set(value: String) { \r\n            println (””“ A Address was changed for $name:\r\n            \"$field\" -> \"value\".\"\"\"\".trimIndent())\r\n            field = value\r\n        }\r\n    }\r\n```\r\n可以像平常一样通过使用 user.address ＝ \"new value\"， 来修改一个属性的值，这其实在底层调用了 setter。\r\n\r\n\r\n在 setter 的函数体中，使用了特殊的标识符 **field** 来访问支持字段的值。\r\n\r\n如果你想修改访问器的可见性，可以像下面这样：\r\n\r\n```\r\nclass LengthCounter {\r\n    var counter: Int = 0 \r\n    private set     //这下就不能在类外部修改这个属性了\r\n    \r\n    fun addWord(word: String){\r\n        counter += word.length\r\n    }\r\n}\r\n```\r\n\r\n### 7.数据类：自动生成通用方法的实现 \r\n\r\n如果想要你的类是一个方便的数据容器，你需要重写这些方法 ： **toString**、 **equals** 和 **hashCode** 。在Kotlin中你不必再去生成这些方法了 。如果为你的类添加 **data** 修饰符，必要的方法将会自动生成好。\r\n\r\n比如：\r\n```\r\ndata class Client(val name: String, val postalCode: Int)\r\n```\r\n\r\n### 8.数据类和不可变性： copy()方法\r\n\r\n为了让使用不可变对象的数据类变得更容易，Kotlin编译器为它们多生成了一个方法：一个允许 **copy** 类的实例的方法，并在 **copy** 的同时修改某些属性的值:\r\n\r\n\r\n```\r\nclass Client (val name: String, val postalCode: Int) {\r\n    fun copy(name: String = this.name, postalCode: Int = \r\n    this.postalCode) = Client(name, postalCode)\r\n}\r\n\r\n\r\n//使用\r\n>>> val bob = Client(\"Bob”, 973293) \r\n>>> println(bob.copy(postalCode = 382555)) \r\n```\r\n\r\n### 9.类委托：使用“by”关键字\r\n(装饰模式我还不是太了解，了解以后再记录)\r\n\r\n### 10.对象声明：创建单例易如反掌\r\n\r\n在面向对象系统设计中一个相当常见的情形就是只需要一个实例的类。在Java中，这通常通过单例模式来实现 \r\n\r\nKotlin 通过使用对象声明功能为这一切提供了最高级的语言支持。对象声明将类声明与该类的单一实例声明结合到了一起。 \r\n\r\n\r\n```\r\nobject Payroll { \r\n    val allErnployees = arrayListOf<Person>()\r\n\r\n    fun calculateSalary() { \r\n        for {person in allErnployees) { \r\n        ...\r\n        }\r\n    }\r\n}\r\n```\r\n> 对象声明通过object关键宇引入。一个对象声明可以非常高效地以一句话来定义一个类和一个该类的变量。 \r\n\r\n### 11.伴生对象：工厂方法和静态成员的地盘\r\n\r\n在类中定义的对象之一可以使用一个特殊的关键字来标记：**companion**。如果这样做，就获得了直接通过容器类名称来访问这个对象的方法和属性的能力，不再需要显式地指明对象的名称。最终的语法看起来非常像 Java 中的静态方法调用。\r\n\r\n```\r\nclass A { \r\n    companion object { \r\n        fun bar() { \r\n        println (\"Companion object called\") \r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n>> A.bar() \r\nCompanion object called\r\n```\r\n\r\n\r\n伴生对象可以访问类中的所有private成员，包括private构造方法，它是实现工厂模式的理想选择。 \r\n\r\n```\r\nclass User private constructor(val nickname: String) {\r\n    companion object {\r\n        fun newSubscribingUser(email: String) =\r\n        User(email.substringBefore ('@')) \r\n        \r\n        fun newFacebookUser(accountld: Int) = \r\n        User(getFacebookName(accountld)) \r\n    }\r\n}\r\n\r\n\r\n>> val subscribingUser = User.newSubscribingUser (\"bob@gmail.com\") \r\n>> val facebookUser = User.newFacebookUser(4) \r\n>> println(subscribingUser.nickname)\r\nbob\r\n```\r\n\r\n### 小结：\r\n\r\n\r\n- Kotlin 的接口与 Java 的相似，但是可以包含默认实现 (Java 从第8版才开始支持)和属性。\r\n- 所有的声明默认都是 final 和 public 的。\r\n- 要想使声明不是 final 的，将其标记为 open。\r\n- internal 声明在同一模块中可见。\r\n- 嵌套类默认不是内部类。使用inner关键字来存储外部类的引用。\r\n- sealed 类的子类只能嵌套在自身的声明中（Kotlin 1.1 允许将子类放置在同一文件的任意地方）。\r\n- 初始化语句块和从构造方法为初始化类实例提供了灵活性。 \r\n- 使用 field 标识符在访问器方法体中引用属性的支持字段。\r\n- 数据类提供了编译器生成的 equals、 hashCode、 toString、 copy 和其他方法。 \r\n- 类委托帮助避免在代码中出现许多相似的委托方法。 \r\n- 对象声明是 Kotlin 中定义单例类的方法。\r\n- 伴生对象（与包级别函数和属性一起）替代了Java静态方法和字段定义。 \r\n- 伴生对象与其他对象一样，可以实现接口，也可以拥有有扩展函数和属性。\r\n- 对象表达式是 Kotlin中针对Java匿名内部类的替代品，并增加了诸如实现多个接口的能力和修改在创建对象的作用域中定义的变量的能力等功能。","Room Database入门指南":"---\r\ntitle: Room Database入门指南\r\ndate: 2018-10-30 21:49:47\r\nindex_img: /img/room_database.png\r\ntags: Android\r\n---\r\n\r\n说到Android端有哪些可以使用的数据库，大家首先想到的自然是SQLite这种带有官方属性加持的轻型的数据库。\r\n\r\n不过对于像我这种基本上没有接触过SQL数据库语言编写的人来说，要通过去写难以查错且又毫不熟悉的数据库代码才能操作数据库的话，那就太令人头大了。\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/001-001.jpg)\r\n\r\n于是乎，便于Android开发者操作数据库的框架也就多了起来，其中人气较高的就有GreenDao、Realm，ObjectBox等，而Room则是谷歌官方十分推荐的，可以代替SQlite的不二之选。\r\n\r\n本篇的主要介绍对象也是Room数据库，不过在此之前，还得简单介绍一下上面提到过的其他几位，同时做个小小的对比。\r\n\r\n# 一、介绍与比较\r\n\r\n\r\n由于我用过的数据库框架并不多，所以对于用过的可以说一下感受，没用过的就简单带过了。\r\n\r\n## 介绍\r\n\r\n### GreenDao 和 ObjectBox \r\n\r\n在这些数据库中， **GreenDao** 算是早闻其名，不过一直没有用过，后来它的作者又出了个 **ObjectBox** ，而且你可以在 [**GreenDao**的GitHub页面](https://github.com/greenrobot/greenDAO) 找到推荐使用 **ObjectBox** 的 [ObjectBox地址](https://objectbox.io/) .\r\n\r\n### Realm\r\n\r\n我真正使用过的还只有 **Realm** 数据库，这里要提一下，**Realm** 数据库对于中国的开发者非常的友好，就像大名鼎鼎的Glide一样， **Realm** 也有中文的介绍文档，文档地址在此：  \r\n[开始使用Realm](https://realm.io/cn/docs/java/latest/)  \r\n虽然这份文档对应的版本不是最新的. 不过对于初次接触 **Realm** 人来说，看这份文档就可以上手了\r\n\r\n最开始使用Realm的时候也是碰过不少坑，不过最主要的是所有数据库对象需要继承 **RealmObject** 这个类(也可以通过接口实现)，这样对项目已有的数据结构不太友好，同时我还发现继承了 **RealmObject** 的对象并不能与 **Gson** 完美结合，如果需要转换的话，还是得费一番周折的。\r\n种种原因，导致我最后从项目中抽去了Realm这个数据库.\r\n\r\n### Room\r\n\r\n与 Realm 分手后的日子里，我并没有放弃对新的数据库的寻找，后来在浏览 Google官方文档的时候才发现了 **Room** 这个新的数据库，经过我一番使用后，就决定是它了！\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/001-002.jpg)\r\n\r\n\r\n## 比较\r\n\r\n因为懒惰的原因，我并没有做过深入的测试，下面会给出从网上找到的关于这些数据库的对比，原文地址如下：\r\n\r\n[**Realm, ObjectBox or Room. Which one is for you?**](https://notes.devlabs.bg/realm-objectbox-or-room-which-one-is-for-you-3a552234fd6e)\r\n\r\n然后是数据量达到 **100k/10k** 的时候，进行增删改查等操作消耗的时间对比：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/001.jpeg)\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/002.jpeg)\r\n\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/003.jpeg)\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/004.jpeg)\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/005.jpeg)\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/006.jpeg)\r\n\r\n可以看到，在各个方面，统统都是 **ObjectBox** 傲视群雄。  \r\n那这篇文章为什么还是要写介绍关于 **Room Database** 呢？\r\n\r\n首先是官方Buff加持，和介绍文档里的一句话：  \r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/007.png)  \r\n[这里是Room的官方介绍文档地址](https://developer.android.google.cn/training/data-storage/room/)\r\n\r\n大致意思就是：**我们强烈建议你用Roon去代替SQLite，不过如果你是个铁头娃非得用SQLite，那我们也没有办法。**\r\n\r\n除了上面这段话，还有一点也可以作为选择Room的原因，就是对于Apk的“增量”是多少。据别人的测试\r\n\r\n> ObjectBox和Realm分别占用1-1.5MB和3-4MB（大小取决于手机架构），而作为SQL封装的Room只占用大约50KB。在方法的增量上，Room只有300多个，ObjectBox和Realm则分别是1300和2000个\r\n\r\n\r\n当然，如果你的数据量很大的话，我觉得还是 **ObjectBox** 更加适合你，因为就从上面的操作数据对比来看， **ObjectBox** 太牛逼了！我以后肯定也会花时间去对 **ObjectBox** 做一番研究，不过目前还是先来介绍介绍 **Room** 吧。\r\n\r\n\r\n# 二、Room的结构\r\n\r\n之前有说过，**Room** 是可以代替 **SQLite** 的，不过我觉得Google推出它更多的是为了搭配 **DataBinding** 使用，如果你对于 **DataBinding** 不太熟悉，可以看一看我前面的关于 **DataBinding** 的文章，这里就不再赘述了。下面就开始说说 **Room** 的结构。\r\n\r\nRoom主要分为三个部分，分别是 **Database**(数据库) 、**Entity**(实体) 、**DAO**(数据访问对象) \r\n\r\n## Database(数据库)\r\n\r\n数据库指的就是一个数据库对象，它继承于 **RoomDataBase** 这个类，并且需要用 **@DataBase** 注解，获取这个数据库对象的方法是通过调用 **Room.databaseBuilder()** 或者 **Room.inMemoryDatabaseBuilder()** ，后者表示在内存中存储数据，如果程序结束了数据也就消失了，所以一般还是使用前者。\r\n\r\n## Entity(实体)\r\n\r\n实体的概念就比较简单了，就类似于MySQL数据库里面的表，一个实体类相当于一个表，而一个实体类有多个属性，就相当于表的多个字段，这个看一看接下来关于 **Entity** 的代码便一目了然。\r\n\r\n## DAO\r\n\r\n关于 **DAO** ，抽象的概念就表示**数据访问对象**，在这里简单的解释一下就是数据操作接口，可以通过编写 **DAO接口** 对数据库进行增删改查等一系列操作。  \r\n> PS:这些接口可以支持RxJava的哦！\r\n\r\n下面是图片说明：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/009.png)\r\n\r\n# 三、开始使用\r\n\r\n在 **Room** 的使用过程中，也是遇到一些坑的，不过都已经解决掉了。如果你也遇到过某些问题，不妨对照一下我的接入流程，说不定就找到了问题所在。\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/008.png)\r\n\r\n## 接入Gradle\r\n\r\n为了避免之后的单元测试出现 <font color=\"#DC143C\">java.lang.RuntimeException: Method e in android.util.Log not mocked. See http://g.co/androidstudio/not-mocked for details.</font> 的错误，除了 **Room** 相关的依赖需要添加外，这里还需要再引用一下 **robolectric单元测试库** 解决问题！\r\n\r\n```\r\n    //room数据库\r\n    def room_version = \"1.1.1\"\r\n    implementation \"android.arch.persistence.room:runtime:$room_version\"\r\n    annotationProcessor \"android.arch.persistence.room:compiler:$room_version\"\r\n    kapt \"android.arch.persistence.room:compiler:$room_version\"      // 由于要使用Kotlin,这里使用了kapt\r\n    implementation \"android.arch.persistence.room:rxjava2:$room_version\"        //之后会用到rxjava，所以这里也可以有\r\n//    implementation \"android.arch.persistence.room:guava:$room_version\"        //由于我们不用guava，这行注释掉\r\n    testImplementation \"android.arch.persistence.room:testing:$room_version\" \r\n    \r\n    //robolectric测试\r\n    testImplementation 'org.robolectric:shadows-multidex:3.8'\r\n    testImplementation \"org.robolectric:robolectric:3.8\"\r\n    //这样就资瓷单元测试咯！\r\n```\r\n\r\n和我一样使用Kotlin的童鞋别忘了下面这行：\r\n\r\n```\r\napply plugin: 'kotlin-kapt'\r\n```\r\n还有，需要做如下更改：\r\n\r\n```\r\n    androidTestImplementation 'com.android.support.test:runner:1.0.2'\r\n\r\n    //更改为\r\n    implementation 'com.android.support.test:runner:1.0.2'\r\n\r\n```\r\n这点一定要改哦！不然会出现一些莫名其妙的问题\r\n\r\n\r\n\r\n\r\n相关库的依赖成功添加后就可以开始动手了！\r\n\r\n## 创建 Entity、Dao 与 DataBase\r\n\r\n### 创建Entity\r\n\r\n首先，创建一个 **Entity** 对象，就把它命名为 **Book** 吧\r\n\r\n\r\n```\r\n@Entity\r\nclass Book(@field:ColumnInfo(name = \"book_name\")\r\n           var bookName: String?, var author: String?, var type: String?) {\r\n\r\n    @PrimaryKey(autoGenerate = true)\r\n    var id: Int = 0\r\n}\r\n```\r\n**Book** 有三个属性，分别表示书名、作者、类型。其中有三点需要注意：\r\n\r\n- 每个 **Entity对象** 都需要使用 **@Entity** 注释声明\r\n- **@PrimaryKey** 注释用于声明主键，这里还添加了 autoGenerate = true，表示它是自增的\r\n- **@ColumnInfo** 注释用来给属性设置别名，如果 **bookName** 属性不设置别名的话，查询的时候可以通过 “**bookName**”进行查询，设置别名后就可以通过设置的“**book_name**” 进行查询了，看 **DAO接口** 便知\r\n\r\n\r\n\r\n### 创建 DAO \r\n\r\n这里，通过 **DAO接口** 来对 **Book** 这个对象进行增删改查：\r\n\r\n```\r\n@Dao\r\ninterface BookDao {\r\n\r\n    @get:Query(\"SELECT * FROM book\")\r\n    val all: List<Book>\r\n\r\n    @Query(\"SELECT * FROM book WHERE author LIKE :author\")\r\n    fun getBookByAuthor(author: String): List<Book>\r\n\r\n    @Query(\"SELECT * FROM book WHERE book_name LIKE :name\")\r\n    fun getBookByNamer(name: String): List<Book>\r\n\r\n    @Insert\r\n    fun insert(book: Book): Long?\r\n\r\n    @Insert\r\n    fun insert(vararg books: Book): List<Long>\r\n\r\n    @Insert\r\n    fun insert(books: List<Book>): List<Long>\r\n\r\n    @Update\r\n    fun update(book: Book): Int\r\n\r\n    @Update\r\n    fun update(vararg books: Book): Int\r\n\r\n    @Update\r\n    fun update(books: List<Book>): Int\r\n\r\n    @Delete\r\n    fun delete(book: Book): Int\r\n\r\n    @Delete\r\n    fun delete(vararg books: Book): Int\r\n\r\n    @Delete\r\n    fun delete(books: List<Book>): Int\r\n\r\n}\r\n```\r\n\r\n上面的 **DAO接口**，同样需要进行几点说明：\r\n\r\n- **DAO接口** 需要使用 **@Dao** 注释进行声明\r\n- **Insert** 操作可以使用 **Long** 作为返回值的类型，表示插入操作前的对象数量\r\n- **Update** 和 **Delete** 操作可以使用 Int 作为返回值，表示更新或者删除的行数\r\n- 返回类型还可以是 **void** ，如果结合 **Rxjava** 使用的话还可以是 **Completable、Single、 Maybe、Flowable**等，具体可以参见这篇文章：[Room 🔗 RxJava](https://medium.com/androiddevelopers/room-rxjava-acb0cd4f3757)(需要备好梯子，不过后续有时间的话我也会介绍一下Room搭配Rxjava的使用)\r\n\r\n**Dao接口** 编写完成后，还剩下最重要的 **DataBase**\r\n\r\n### 创建 DataBase\r\n\r\n> 由于实例化一个 **RoomDatabase** 对象的开销是比较大的，所以 **DataBase** 的使用需要遵循单例模式，只在全局创建一个实例即可。\r\n\r\n这里为了方便理解，还是使用java代码去创建一个 **BookDataBase类**，当然，转换成Kotlin只需要Shift + Alt + Ctrl + K 即可\r\n\r\n如果你使用的是饿汉式的单例模式，在Kotlin中通过object修饰可达到同样效果\r\n```\r\n@Database(entities = {Book.class}, version = 1)\r\npublic abstract class BookDataBase extends RoomDatabase {\r\n    public abstract BookDao bookDao();\r\n    private static BookDataBase instance;\r\n\r\n    public static BookDataBase getInstance(Context context){\r\n        if (instance == null){\r\n            synchronized (BookDataBase.class){\r\n                if (instance == null){\r\n                    instance = create(context);\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    private static BookDataBase create(Context context) {\r\n        return Room.databaseBuilder( context,BookDataBase.class,\"book-db\").allowMainThreadQueries().build();\r\n    }\r\n}\r\n```\r\n\r\n上面的例子中有一些需要特别注意：\r\n\r\n- **@Database** 注释用于进行声明，同时还需要有相关的 **entity对象**，其中 **version** 是当前数据库的版本号，如果你对数据相关的**实体类结构**进行了更改，这里的 **version** 就需要**加一**\r\n- **BookDataBase** 除了继承于 **RoomDatabase** ，还需要实例出相关的 **DAO接口**\r\n- create()方法中的\"**book-db**\"是数据库的名字，这里随意，不过需要注意的是 **allowMainThreadQueries()** 方法，这里由于我们会用到单元测试，所以加上这行代码是为了防止 【*Cannot access database on the main thread since it may potentially lock the UI for a long period of time.*】 的报错。正式使用时，请务必去掉这行代码，因为它会让所有耗时操作运行在主线程！\r\n\r\n到这里，我们就可以先愉快的进行测试了.\r\n\r\n\r\n\r\n## 测试\r\n\r\n### 初级测试\r\n\r\n找到 **src** 下的 **test** 目录，然后可以像我这样创建一个 **RoomTest** 类进行测试\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/010.png)\r\n\r\n说到这里，可能会有童鞋尚未了解过单元测试，这时候你可以先去看看相关博客，比如这篇\r\n\r\n[Android 单元测试只看这一篇就够了](https://juejin.im/post/5b57e3fbf265da0f47352618)\r\n\r\n不过这里使用的单元测试是 Android Studio 自带的，也没有用到太复杂的东西，同时我会做一些说明，不够了解的童鞋也可以继续往下看，看完你也就了解了\r\n\r\n\r\n```\r\n@RunWith(AndroidJUnit4::class)\r\nclass RoomTest {\r\n\r\n    private var bookDao: BookDao? = null\r\n    private var bookDataBase: BookDataBase? = null\r\n\r\n    @Before\r\n    @Throws(Exception::class)\r\n    fun setUp() {\r\n        ShadowLog.stream = System.out      //这样方便打印日志\r\n        val context = InstrumentationRegistry.getTargetContext()\r\n        bookDataBase = BookDataBase.getInstance(context)\r\n        bookDao = bookDataBase?.bookDao()\r\n    }\r\n\r\n\r\n    @Test\r\n    fun insert() {\r\n        val book1 = Book(\"时间简史\", \"斯蒂芬·威廉·霍金\", \"科学\")\r\n        val book2 = Book(\"百年孤独\", \"西亚·马尔克斯\", \"文学\")\r\n        val list = bookDao?.insert(book1, book2)\r\n\r\n        assert(list?.size == 2)\r\n    }\r\n\r\n    @Test\r\n    fun query(){\r\n        val books = bookDao?.all\r\n        for (book in books?: emptyList()) {\r\n            Log.e(javaClass.name, \"获取的书籍数据: ${Gson().toJson(book)}\")\r\n        }\r\n    }\r\n\r\n    @After\r\n    @Throws(Exception::class)\r\n    fun cloaseDb() {\r\n        bookDataBase?.close()\r\n    }\r\n}\r\n```\r\n\r\n可以看到，这里的单元测试使用的是 **AndroidJUnit4**，通过 **@Before** 注释的方法，表示用于**相关资源的初始化**，类似于Activity的onCreate()方法；而通过 **@After** 注释的方法，则是用于**相关资源的销毁**，类似于Activity的onDestroy()方法。\r\n\r\n剩下的，通过 **@Test** 注释的方法就表示用于测试的单元，每个测试类里面可以有多个测试单元，这里目前只写了插入和查询两个单元，在 **RoomTest** 类上通过右键运行，然后看一下结果：\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/011.png)\r\n\r\n在测试代码中的 **insert()单元 ** 里，有这样一行代码：\r\n\r\n```\r\nassert(list.size == 2)\r\n```\r\n而测试的结果是一片绿色，就表示这个断言是正确的，list列表长度刚好为2，这里为了验证返回的list是整个数据库长度还是仅仅表示此次进行插入操作的长度，我们修改一下 insert()测试单元：\r\n\r\n```\r\n   @Test\r\n    fun insert() {\r\n        val book1 = Book(\"时间简史\", \"斯蒂芬·威廉·霍金\", \"科学\")\r\n        val book2 = Book(\"百年孤独\", \"西亚·马尔克斯\", \"文学\")\r\n        val list = bookDao?.insert(book1, book2)\r\n        assert(list?.size == 2)\r\n\r\n        val list2 = bookDao?.insert(book1, book2)\r\n        assert(list2?.size == 4)\r\n    }\r\n```\r\n\r\n这时候在 **insert()单元测试区域** 右键运行，就只测试这一个单元，然后结果如下：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/012.png)\r\n\r\n我们在 insert()单元 中进行了两次插入操作，所以数据库的总长度应该为 4 ，而这里第39行的代码：\r\n\r\n```\r\nassert(list2?.size == 4)\r\n```\r\n返回的cede 是 -1，就表示实际上每次插入操作返回的列表长度应该为插入的数量，而非数据库总量。其他操作亦是如此。\r\n\r\n在单元测试中，我们的测试并不能直接用于正式的项目中，因为数据库操作属于耗时操作，所以一定不能把这些操作放在主线程里，而最方便的线程切换，莫过于 **Rxjava** 啦！\r\n\r\n现在开始使用 **Rxjava** 进行测试吧\r\n\r\n### 结合Rxjava的测试\r\n\r\n首先，要在项目中添加 **Rxjava** 的依赖：\r\n\r\n```\r\n    //rxJava2+rxAndroid\r\n    implementation \"io.reactivex.rxjava2:rxjava:2.x.y\"\r\n    implementation 'io.reactivex.rxjava2:rxandroid:2.1.0'\r\n```\r\n\r\n在单元测试中，RxJava 如果做 **IO线程** 到 **UI线程** 的切换操作，结果是无法获取的，所以需要将这些线程进行合并，方法如下：\r\n\r\n```\r\n    @Before\r\n    @Throws(Exception::class)\r\n    fun setUp() {\r\n        val context = InstrumentationRegistry.getTargetContext()\r\n        bookDataBase = BookDataBase.getInstance(context)\r\n        bookDao = bookDataBase?.bookDao()\r\n        ShadowLog.stream = System.out\r\n\r\n        initRxJava2()\r\n    }\r\n    \r\n    private fun initRxJava2() {\r\n        RxJavaPlugins.reset()\r\n        RxJavaPlugins.setIoSchedulerHandler { Schedulers.trampoline() }\r\n        RxAndroidPlugins.reset()\r\n        RxAndroidPlugins.setMainThreadSchedulerHandler { Schedulers.trampoline() }\r\n    }\r\n```\r\n\r\n在 **@Before注解** 下的 **setUp()** 方法中进行RxJava的配置，然后我们可以把RxJava常用的线程切换写在一个方法里，方便复用：\r\n\r\n```\r\n    private fun<T> doWithRxJava(t: T): Observable<T>{\r\n        return Observable.create<T>{it.onNext(t)}\r\n                .subscribeOn(Schedulers.io())\r\n                .unsubscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n    }\r\n```\r\n\r\n接着，对 **insert单元** 和 **query单元** 进行修改：\r\n\r\n```\r\n    @Test\r\n    fun insert() {\r\n        val book1 = Book(\"时间简史\", \"斯蒂芬·威廉·霍金\", \"科学\")\r\n        val book2 = Book(\"百年孤独\", \"西亚·马尔克斯\", \"文学\")\r\n        doWithRxJava(bookDao?.insert(book1, book2))\r\n                .subscribe ({\r\n                    Log.e(\"insert长度：\" , \"${it?.size}\")\r\n                    assert(it?.size == 2)\r\n                },{\r\n                    Log.e(\"insert出错：\" , \"${it.stackTrace}-${it.message}\")\r\n                })\r\n    }\r\n\r\n    @Test\r\n    fun query(){\r\n        doWithRxJava(bookDao?.all)\r\n                .subscribe({\r\n                    for(book in it?: emptyList()){\r\n                        Log.e(javaClass.name, \"获取的书籍数据: ${Gson().toJson(book)}\")\r\n                        assert(it?.size == 2)\r\n                    }\r\n                },{\r\n                    Log.e(\"query出错：\" , \"${it.stackTrace}-${it.message}\")\r\n                })\r\n    }\r\n```\r\n\r\n然后看一下测试的结果：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/013.png)\r\n\r\n\r\n那么， **Room DataBase** 的入门指南，就写到这里啦！\r\n\r\n后续我可能会再写一篇进阶版的文章，涵盖了真实使用的场景，然后看能不能写一个简单的Demo出来，这样更方便学习吧！\r\n\r\n~~*不过我发现我现在的懒癌是越来越严重了，也不知道下一篇是什么时候*~~\r\n\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/014.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","单例与锁":"---\r\ntitle: 单例与锁\r\ndate: 2020-03-13 21:17:23\r\nindex_img: /img/lock.jpg\r\ntags: 源码系列\r\n---\r\n\r\n\r\n# 序\r\n\r\n关于单例和锁的概念，以前一直都是把别人的分析文章简单看一遍，自己实操的不多，其中很多东西都知之甚少，没有一个完整的概念。\r\n\r\n而在之前的面试中，也被要求过手写单例，并且是在编译器上写的。即便如此，写出来的东西问题也非常多。所以我有必要再对这些知识重新认识一遍了。\r\n\r\n# 引子\r\n\r\n简单介绍一下单例的概念吧：就是**一个对象在整个系统中只能存在一个实例**\r\n\r\n那么在java中单例一定是和 **static** 关键字挂钩的\r\n\r\n如何去实现一个单例呢？我们下面一步步来看\r\n\r\n# 单例\r\n\r\n先来试一下最简单的单例\r\n\r\n### 饿汉式单例\r\n\r\n这个名字特别有意思，也比较符合这个单例的情况。\r\n\r\n\r\n```\r\npublic class SingleClass {\r\n    private SingleClass() { }\r\n    private static SingleClass instance = new SingleClass();\r\n    public static SingleClass getInstance(){\r\n        return instance;\r\n    }\r\n}\r\n```\r\n> 注意，单例模式暴露给调用者的接口要保证它不会破坏单例模式，所以这里的构造方法是私有的。  \r\n想要获取SingleClass对象，只能通过调用它的 getInstance()方法。当然，还有很多破坏这种单例的方法，后面再说\r\n\r\n\r\n我们来通过多线程获取的方式检验一下，看看它是不是单例：\r\n\r\n```\r\n    @Test\r\n    public void test(){\r\n        for(int i = 0; i < 10; i++){\r\n            new Thread(() -> {\r\n                SingleClass singleClass = SingleClass.getInstance();\r\n                System.out.println(\"hashcode: \" + singleClass.hashCode());\r\n            }).start();\r\n        }\r\n    }\r\n```\r\n\r\n打印内容：\r\n```\r\nhashcode: 1202440441\r\nhashcode: 1202440441\r\nhashcode: 1202440441\r\nhashcode: 1202440441\r\nhashcode: 1202440441\r\nhashcode: 1202440441\r\nhashcode: 1202440441\r\nhashcode: 1202440441\r\nhashcode: 1202440441\r\nhashcode: 1202440441\r\n```\r\n\r\n可以看到，获取的都是同一个对象。显然，这样的单例模式是可以的。\r\n\r\n不过因为一开始就创建了一个静态的对象，这就导致了不管程序是否需要使用到它，它都会消耗掉一部分资源。所以我们可以优化一下\r\n\r\n### 有缺陷的懒汉式单例\r\n\r\n\r\n```\r\npublic class SingleClass {\r\n    private SingleClass() { }\r\n    private static SingleClass instance;\r\n    public static SingleClass getInstance(){\r\n        if(instance == null){\r\n            instance = new SingleClass();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n看一下上面的单例模式，只有调用 **getInstance()** 方法才会去创建一个单例对象，好像没有问题。\r\n\r\n但是如果放在多线程模式下运行呢？我们再来检验一下，还是上面的检验方法，看一下检验后的结果：\r\n\r\n\r\n```\r\nhashcode: 1225245564\r\n\r\nhashcode: 686369273\r\nhashcode: 686369273\r\nhashcode: 686369273\r\nhashcode: 686369273\r\nhashcode: 686369273\r\nhashcode: 686369273\r\n\r\nhashcode: 416757494\r\nhashcode: 686369273\r\nhashcode: 686369273\r\n```\r\n显然，在10个线程同时去获取这个单例对象时，创建了多个实例\r\n\r\n那这里，就要介绍到另一个关键字 **synchronized** 了\r\n\r\n### synchronized\r\n\r\n **synchronized** 的作用是给 **方法或者代码块加锁**，也就是说它不能被用来修饰一个变量。\r\n \r\n 并且根据 **synchronized** 的不同使用方式，加的锁类型也不同。\r\n \r\n 主要分为两种，分别是 **对象锁(也叫方法锁)** 和 **类锁**，接下来我们需要搞明白两个问题：\r\n \r\n - **什么是对象锁和类锁？**\r\n - **对象锁和类锁分别有什么作用？**\r\n\r\n#### 对象锁和类锁\r\n\r\n我们可以先在概念上线介绍一下这个问题\r\n\r\n如果我们有这样一个类：\r\n\r\n```\r\npublic class SynchronizedClass {\r\n    //对象锁\r\n    public synchronized void methodA(){}\r\n    public void methodB(){\r\n        synchronized(this){ }\r\n    }\r\n    Object object = new Object();\r\n    public void methodC(){\r\n        synchronized(object){ }\r\n    }\r\n\r\n    //类锁\r\n    public static synchronized void methodD(){}\r\n    public static void methodE(){\r\n        synchronized (SynchronizedClass.class){ }\r\n    }\r\n}\r\n```\r\n根据这个类展开：\r\n- 对象锁：\r\n     - 如果 **new** 了100个 **SynchronizedClass** 对象，而每一个对象都有他们独自的**对象锁**，这时候如果有两个线程 **X** 和 **Y**，**X** 在访问某个对象的 `methodA()` 方法时候， **Y** 是不可以访问这个对象的 `methodA()` 的，必须要等待 **X** 访问完毕才可以，但是这时候 **Y** 可以访问其他99个对象的 `methodA()`\r\n- 类锁：\r\n    - 同样的，上面的流程走一遍。对于线程  **X** 和 **Y** ，不能同时访问 `methodD()` 或者 `methodE()` 方法\r\n\r\n来做个试验吧，这样看起来更加明显\r\n\r\n#### 对象锁\r\n\r\n```\r\npublic class SynClassTest{\r\n\r\n    public synchronized void printSyn()  {\r\n        int i = 0;\r\n        while (i++ < 5){\r\n            System.out.println(\"Syn-\" + Thread.currentThread().getName() + \":\" + i);\r\n        }\r\n    }\r\n    public synchronized void printNoSyn()   {\r\n        int i = 0;\r\n        while (i++ < 5){\r\n            System.out.println(\"NoSyn-\" + Thread.currentThread().getName() + \":\" + i);\r\n        }\r\n    }\r\n}\r\n```\r\n我们注意到，上面两个方法都是用 **synchronized** 关键字修饰了的。接下来看一下测试方法：\r\n\r\n```\r\n    @Test\r\n    public void test()  {\r\n        SynClassTest obj = new SynClassTest();\r\n        Thread a = new Thread(() -> {\r\n            obj.printNoSyn();\r\n        }, \"NoSyn\");\r\n        Thread b = new Thread(() -> {\r\n            obj.printSyn();\r\n        }, \"Syn\");\r\n        a.start();\r\n        b.start();\r\n    }\r\n```\r\n\r\n打印内容：\r\n\r\n```\r\nNoSyn-NoSyn:1\r\nNoSyn-NoSyn:2\r\nNoSyn-NoSyn:3\r\nNoSyn-NoSyn:4\r\nNoSyn-NoSyn:5\r\nSyn-Syn:1\r\nSyn-Syn:2\r\nSyn-Syn:3\r\nSyn-Syn:4\r\nSyn-Syn:5\r\n```\r\n可以看到，当一个线程执行完毕了另一个线程才开始执行，因为他们持有的都是同一个对象锁\r\n\r\n接下来，把 **printNoSyn()** 方法的 **synchronized** 去掉，看看打印什么：\r\n\r\n```\r\nNoSyn-NoSyn:1\r\nNoSyn-NoSyn:2\r\nSyn-Syn:1\r\nNoSyn-NoSyn:3\r\nNoSyn-NoSyn:4\r\nNoSyn-NoSyn:5\r\nSyn-Syn:2\r\nSyn-Syn:3\r\nSyn-Syn:4\r\nSyn-Syn:5\r\n```\r\n这时候，输出结果是两个线程交替进行的。\r\n\r\n这说明，**某个线程得到了对象锁，但是另一个线程还是可以访问没有进行同步的方法或者代码**。进行了同步的方法（加锁方法）和没有进行同步的方法（普通方法）是互不影响的。\r\n\r\n这时候，我们修改一下，看一看 **类锁** 的效果\r\n\r\n#### 类锁\r\n\r\n在 `SynClassTest` 中添加一个方法，表示类锁：\r\n\r\n```\r\n    public void printClassSyn()   {\r\n        synchronized (SynClassTest.class){\r\n            int i = 0;\r\n            while (i++ < 5){\r\n                System.out.println(\"ClassSyn-\" + Thread.currentThread().getName() + \":\" + i);\r\n            }\r\n        }\r\n    }\r\n```\r\n同时，测试的地方也添加一个线程打印\r\n\r\n```\r\n        Thread c = new Thread(() -> {\r\n            obj.printClassSyn();\r\n        }, \"ClassSyn\");\r\n        ...\r\n        c.start();\r\n```\r\n\r\n再来看看打印结果：\r\n\r\n```\r\nNoSyn-NoSyn:1\r\nSyn-Syn:1\r\nSyn-Syn:2\r\nSyn-Syn:3\r\nClassSyn-ClassSyn:1\r\nClassSyn-ClassSyn:2\r\nClassSyn-ClassSyn:3\r\nClassSyn-ClassSyn:4\r\nClassSyn-ClassSyn:5\r\nSyn-Syn:4\r\nSyn-Syn:5\r\nNoSyn-NoSyn:2\r\nNoSyn-NoSyn:3\r\nNoSyn-NoSyn:4\r\nNoSyn-NoSyn:5\r\n```\r\n\r\n从这个打印结果来看，类锁和方法锁的打印结果是交替进行的，说明这两个锁是不互斥的。\r\n\r\n同时也说明了，类锁只是一个抽象出来的概念而已，并不是像名字上的那样给一整个类加上锁\r\n\r\n> ps:因为上面的类锁，synchronized修饰的是SynClassTest.class对象，所以没有在方法前加static修饰，当然我也测试过加了static后的结果，还是差不多的\r\n\r\n当然，锁的概念还有很多，比如 `死锁`、`自旋锁`、`重置锁` 等等，这里就不进行介绍了。感兴趣的小伙伴可以去看这篇文章了解一下：\r\n[不可不说的Java“锁”事](https://tech.meituan.com/2018/11/15/java-lock.html)\r\n\r\n接下来，我们回到前面那个没有完成的懒汉式单例模式。\r\n\r\n### 完善一点的懒汉式单例模式\r\n\r\n知道了 `synchronized` 的用法后，我们就可以来对之前的单例模式进行完善了。\r\n\r\n```\r\n    public static SingleClass getInstance(){\r\n        synchronized (SingleClass.class){\r\n            if (instance == null){\r\n                instance = new SingleClass();\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n```\r\n这样，我们就对这个方法加上了类锁，但是这里又有一个问题了。\r\n\r\n也就是每次调用 `getInstance()` 方法的时候，都会访问到这个锁，因为加锁是有一定的性能开销的。所以这里还有一种更好的方法去完成这个单例模式\r\n\r\n\r\n```\r\n    public static SingleClass getInstance(){\r\n        if(instance == null){\r\n            synchronized (SingleClass.class){\r\n                if (instance == null){\r\n                    instance = new SingleClass();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n```\r\n上面的代码中，只有当 `instance == null` 时才进入加锁的代码中，然后再做和之前一样的操作。这也就是我们常说的 `DCL(Double-Check Lock)` 了\r\n\r\n那么这样是不是就完成了呢？\r\n\r\n没想到吧！其实还有一个坑！\r\n\r\n因为实例化一个对象其实可以分为三个步骤：　　\r\n- （1）分配内存空间。　　\r\n- （2）初始化对象。　　\r\n- （3）将内存空间的地址赋值给对应的引用。\r\n\r\n但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：　\r\n- （1）分配内存空间。　　\r\n- （2）将内存空间的地址赋值给对应的引用。　　\r\n- （3）初始化对象\r\n\r\n也就是说上面的 `instance = new SingleClass();` 不是一个原子性的操作，在多线程中可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。(详细原因请看：[双重检查锁定与延迟初始化](https://www.infoq.cn/article/double-checked-locking-with-delay-initialization/))\r\n\r\n为了避免对指令的重排序，我们需要使用 `volatile` 关键字。\r\n\r\n这里，我们又引入了一个新的概念：**volatile**\r\n\r\n### volatile\r\n\r\n`volatile` 是一个关键字，它的作用如下：\r\n- **可见性**：使系统中所有线程对该关键字修饰的变量共享可见，可以禁止线程的工作内存对volatile修饰的变量进行缓存\r\n- **有序性**：就像上面所提到的，防止指令重排\r\n- **原子性**：volatile关键字用于声明简单类型变量，如int、float、 boolean等数据类型。对这些变量的**读**和**写**都是原子性的，但是其他对于变量的操作就不是了，比如：\r\n    - 基本类型的自增（如count++）等操作不是原子的。\r\n    - 对象的任何非原子成员调用（包括 **成员变量** 和 **成员方法**）不是原子的。\r\n\r\n因为 **有序性** 在上面已经讲过了，下面就针对 **可见性** 和 **原子性** 分别来看几个例子\r\n\r\n#### 可见性\r\n\r\n先创建一个class对象用于进行数据操作\r\n```\r\npublic class VolatileClass {\r\n    private int i = 0;\r\n\r\n    public void increase(){\r\n        i++;\r\n    }\r\n\r\n    public int get(){\r\n        return i;\r\n    }\r\n}\r\n\r\n```\r\n然后是测试\r\n\r\n```\r\n    @Test\r\n    public void test(){\r\n        VolatileClass volatileClass = new VolatileClass();\r\n        Thread write =  new Thread(() -> {\r\n            for(int i = 0; i < 100; i++){\r\n                volatileClass.increase();\r\n            }\r\n            print(\"写入结果：\"+ volatileClass.get());\r\n        }, \"WriteThread\");\r\n        Thread read =   new Thread(() -> {\r\n            print(\"读取开始：\"+ volatileClass.get());\r\n            while (volatileClass.get() < 100){\r\n\r\n            }\r\n            print(\"读取结束：\"+ volatileClass.get());\r\n        }, \"ReadThread\");\r\n        read.start();\r\n        try {\r\n            Thread.sleep(100);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        write.start();\r\n    }\r\n```\r\n上面先让 **读取线程** 一直运行， 在 100ms 后再用 **写入线程** 修改数据，因为 读取线程是死循环，所以如果它能够获取到修改后的结果，就会打印 **读取结束**。我们看一下打印结果\r\n\r\n\r\n```\r\n读取开始：0\r\n写入结果：100\r\n\r\n```\r\n显然，这里我们就验证了 **可见性** 的问题，接下来，是 **原子性**\r\n\r\n#### 原子性\r\n\r\n> 原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败\r\n\r\n\r\n```\r\nint a = 10;\r\na++;\r\nint b=a;\r\na = a+1;\r\n```\r\n上面的四个语句中，只有第一个是原子操作，其他都不是原子操作。\r\n\r\n接下来，我们来验证一下，`volatile` 的原子性\r\n\r\n\r\n```\r\n    @Test\r\n    public void test(){\r\n        VolatileClass volatileClass = new VolatileClass();\r\n        for(int i = 0; i < 10000; i++){\r\n            new Thread(() -> {\r\n                volatileClass.increase();\r\n            }).start();\r\n        }\r\n        print(\"结果:\" + volatileClass.get());\r\n    }\r\n```\r\n为了保证 `increase()` 方法操作不受多线程的影响，我们给它加上了 **synchronized**修饰，同时我们也将变量用 `volatile` 修饰一下：看一下打印结果：\r\n\r\n\r\n```\r\n结果:9993\r\n```\r\n你会发现，结果经常是小于 **10000** 的，所以这也就说明了， `volatile`无法保证修饰对象相关操作的原子性\r\n\r\n那么到此，我们最后用另一个单例作为这篇文章的终点吧\r\n\r\n### 静态内部类单例\r\n\r\n\r\n```\r\npublic class SingleClass {\r\n    \r\n    private SingleClass() { }\r\n    \r\n    private static class LazyHolder{\r\n        private static SingleClass instance = new SingleClass();\r\n    }\r\n\r\n    public static SingleClass getInstance(){\r\n        return LazyHolder.instance;\r\n    }\r\n}\r\n```\r\n\r\n这种单例模式和懒汉式一样，也是只有调用了 `getInstance()` 方法才会初始化实例对象。并且实现起来也比较方便。是最为推荐的一种单例写法。\r\n\r\n还剩下一种枚举实现的单例：\r\n\r\n```\r\npublic enum Singleton {  \r\n    INSTANCE;  \r\n    public void whateverMethod() {  \r\n    }  \r\n}\r\n```\r\n\r\n不算常见，这里就提一下\r\n\r\n之前提过的，一些可以破坏单例的方法，可以去阅读这篇文章，写的比较详细： \r\n[那些年，我们一起写过的“单例模式”](https://zhuanlan.zhihu.com/p/25733866)\r\n\r\n最后，关于单例的内容就到此结束啦(后面有空的话，锁会深入一下)。","手把手教你android端微信支付接入":"---\r\ntitle: 手把手教你android端微信支付接入\r\ndate: 2018-10-08 21:49:47\r\nindex_img: /img/wechat_pay.png\r\ntags: Android\r\n---\r\n\r\n## Android端接入微信支付，蛮简单的\r\n\r\n\r\n### 一、添加gradle依赖：\r\n\r\n在app module目录下的build.gralde中添加\r\n\r\n```\r\ndependencies {\r\n    //微信SDK接入\r\n    implementation 'com.tencent.mm.opensdk:wechat-sdk-android-with-mta:+'\r\n}\r\n```\r\ngralde构建完成之后，再做下一步的操作。\r\n\r\n### 二、在AndroidManifest.xml中添加相关权限：\r\n\r\n```\r\n    <!--微信支付权限-->\r\n    <uses-permission android:name=\"android.permission.INTERNET\" />\r\n    <uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\"/>\r\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\r\n```\r\n\r\n### 三、创建wxapi目录，并创建WXPayEntryActivity\r\n\r\n在你的package目录下，创建**wxapi**目录，比如说我使用的demo项目，**wxapi**就在目录**net.sourceforge.simcpux**目录下\r\n\r\n同时，在**wxapi**目录下创建**WXPayEntryActivity**\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-001.png)\r\n\r\n**WXPayEntryActivity**实现**IWXAPIEventHandler**接口，这个Activity页面就是支付结果的回调页面，下面是它最简单地实现：\r\n```\r\npublic class WXPayEntryActivity extends Activity implements IWXAPIEventHandler{\r\n\t\r\n\tprivate static final String TAG = \"MicroMsg.SDKSample.WXPayEntryActivity\";\r\n\t\r\n    private IWXAPI api;\r\n\t\r\n    @Override\r\n    public void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.pay_result);\r\n        \r\n    \tapi = WXAPIFactory.createWXAPI(this, \"你的appid\");\r\n        api.handleIntent(getIntent(), this);\r\n    }\r\n\r\n\t@Override\r\n\tprotected void onNewIntent(Intent intent) {\r\n\t\tsuper.onNewIntent(intent);\r\n\t\tsetIntent(intent);\r\n        api.handleIntent(intent, this);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void onReq(BaseReq req) {\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void onResp(BaseResp resp) {\r\n\t\tLog.d(TAG, \"onPayFinish, errCode = \" + resp.errCode);\r\n\r\n\t\tif (resp.getType() == ConstantsAPI.COMMAND_PAY_BY_WX) {\r\n\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n\t\t\tbuilder.setTitle(\"支付结果\");\r\n\t\t\tbuilder.setMessage(getString(R.string.pay_result_callback_msg, String.valueOf(resp.errCode)));\r\n\t\t\tbuilder.show();\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n同时，别忘了在**AndroidManifest.xml**中声名**WXPayEntryActivity**\r\n\r\n\r\n```\r\n        <activity\r\n            android:name=\".wxapi.WXPayEntryActivity\"\r\n            android:exported=\"true\"\r\n            android:launchMode=\"singleTop\">\r\n            <intent-filter>\r\n                <action android:name=\"android.intent.action.VIEW\"/>\r\n                <category android:name=\"android.intent.category.DEFAULT\"/>\r\n                <data android:scheme=\"你的appid\"/>\r\n            </intent-filter>\r\n\r\n        </activity>\r\n```\r\n\r\n当这些准备工作都做好之后，就可以准备使用了。\r\n\r\n### 四、使用\r\n\r\n当你从服务端获取到订单的相关信息后，就可以调用支付接口了：\r\n```\r\n                IWXAPI api = WXAPIFactory.createWXAPI(context, null);\r\n                api.registerApp(IntentKey.WX_APP_ID);\r\n                PayReq req = new PayReq();\r\n                req.appId\t\t\t= \"wx8888888888888888\";//你的微信appid\r\n                req.partnerId\t\t= \"1900000109\";//商户号\r\n                req.prepayId\t\t= \"WX1217752501201407033233368018\";//预支付交易会话ID\r\n                req.nonceStr\t\t= \"5K8264ILTKCH16CQ2502SI8ZNMTM67VS\";//随机字符串\r\n                req.timeStamp\t\t= \"1412000000\";//时间戳\r\n                req.packageValue\t= \"Sign=WXPay\";扩展字段,这里固定填写Sign=WXPay\r\n                req.sign\t\t\t= \"C380BEC2BFD727A4B6845133519F3AD6\";//签名\r\n//\t\t\t\treq.extData\t\t\t= \"app data\"; // optional\r\n                // 在支付之前，如果应用没有注册到微信，应该先调用IWXMsg.registerApp将应用注册到微信\r\n                api.sendReq(req);\r\n```\r\n\r\n这里需要注意的是，上面的这些信息，都应该从服务器去获取，比如说随机字符串之类的长短也不一定和上面例子中的一致。具体是什么，得看你们的后端给的是什么。\r\n\r\n不出意外的话，通过上面接口的调用，你就可以正常使用微信提供的APP支付了。\r\n\r\n是不是非常简单？！\r\n\r\n***然鹅。。。***\r\n\r\n事情哪儿有这么顺利，到了真正使用的时候，遇到的问题可不少，下面会列举出遇到过的问题，然后说明解决办法。\r\n\r\n\r\n## Android端接入微信支付，坑蛮多的\r\n\r\n**微信支付app的接入，要我来说，对初次尝试的人非常不友好**\r\n\r\n一般情况下，开发者使用新的工具都需要先看一看它的说明文档，如果说明文档写的够好，直接用就是了；如果文档介绍的不够全面，还需要有Demo提供参考。微信的App支付就属于后者。\r\n下面是它的接入文档页面：\r\n\r\n[Android接入指南](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=1417751808&token=&lang=zh_CN)（还有其他相关信息也可以通过这个页面接入）\r\n\r\n由于仅仅靠着文档的说明不足以让我掌握对微信支付的使用，所以自然而然的，Demo就成了初次接触微信支付者的学习教材啦！\r\n\r\n[Demo下载](https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=11_1)\r\n\r\n当你接入Demo后，一系列的问题将会接踵而至，下面来看一看具体是什么问题\r\n\r\n### 接入Demo\r\n\r\n将下载后的Demo按照Import moudule的方式接入到某个项目中：\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-002.png)\r\n\r\n然后选中这个项目，进行编译：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-003.png)\r\n\r\n接下来，编译器就开始报错了，找到报错的位置，发现是如下问题：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-004.png)\r\n\r\n**到这里开始，我就要吐槽了**\r\n\r\n这种问题一看就是找不到包了，于是我们看一下这个项目中的build.gralde中的依赖，如下\r\n```\r\ndependencies {\r\n    compile files('libs/libammsdk.jar')\r\n    compile files('libs/wechat-sdk-android-with-mta-1.0.2.jar')\r\n}\r\n\r\n```\r\n很显然，是导入的本地jar包，为了方便起见，我们将这里的依赖修改成之前配置时的：\r\n\r\n```\r\ndependencies {\r\n    //微信SDK接入\r\n    implementation 'com.tencent.mm.opensdk:wechat-sdk-android-with-mta:+'\r\n}\r\n```\r\n同时，我们还可以发现，重新构建完项目后，上面的问题并没有解决。\r\n\r\n这时候我们在Android studio的中的**External Libraries**去看一看新构建的库:\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-005.png)\r\n\r\n可以看到，正确的引用路径应该是把**sdk**换成**opensdk**\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-006.png)\r\n\r\n当你将所有的路径都修改过来后，还会有如下问题：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-007.png)\r\n\r\n将上面的 **imgObj.imageUrl = url** 修改为：\r\n\r\n```\r\nimgObj.setImagePath(url);\r\n```\r\n这个错误出现的地方有两处吧，当你把这些错误都解决后，再次进行编译，就可以正常运行啦！\r\n\r\nDemo运行后的界面是这样的：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-008.png)\r\n\r\n到了这里，基本上就可以进行测试了，剩下的东西无需再多说，过程差不多和上面直接接入的流程一样，不过要demo里面的更加详细，只需多多观摩即可。\r\n\r\n那么，最后还是说一下需要注意的点吧。\r\n\r\n### 注意事项\r\n\r\n在微信开放平台上面设置app相关参数的时候，需要**应用包名**以及**应用签名**\r\n\r\n![image](https://pay.weixin.qq.com/wiki/doc/api/img/chapter8_5_2.png)\r\n\r\n获取应用签名的工具地址是：[签名工具下载地址](https://open.weixin.qq.com/zh_CN/htmledition/res/dev/download/sdk/Gen_Signature_Android.apk)\r\n\r\n> 这里又要吐槽一下，签名工具就是一个apk，装到手机上后，输入包名，然后生成签名，最关键的是这个签名无法复制，使用下来就一个感受，不方便啊！！！！\r\n\r\n签名工具里面输入的包名就是之前提到过的，可以直接在Androidmanifest.xml中复制。\r\n\r\n**但是**\r\n\r\n    尽管包名一样，release版的项目和debug版的项目最后生成的签名都是不一样的，这点很重要！\r\n    \r\n**所以如果你是用的debug进行测试，那么网站里面的签名一定要填写debug版下获取到的签名，正式发布的时候，要把它换成release版的！如果签名不一致，你是无法通过那个“-1”返回值获取到任何有效的错误信息的!切记！**\r\n\r\n\r\n<font face=\"STCAIYUN\">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~那么</font>\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-009.png)","骚年，你还没开始学Flutter吗？":"---\r\ntitle: 骚年，你还没开始学Flutter吗？\r\ndate: 2019-05-04 21:49:47\r\nindex_img: /img/study_flutter.png\r\ntags: Flutter\r\n---\r\n\r\n# 开场闲聊\r\n\r\n在去年12月份的Flutter Live 2018上，谷歌的Flutter团队宣布**Flutter 1.0 release版**正式发布。\r\n\r\n想必很多小伙伴和我一样，都是从那个时候开始了解到Flutter的，而我也是顺带从那个时候入了Flutter的坑。\r\n\r\n不过应该还有一部分小伙伴对Flutter只是略有耳闻，甚至闻所未闻。为了把这部分小伙伴拉到这个 **“大坑”** 里面来，我不得不在这里向你们展示**Flutter的魅力**所在，同时为了保持客观公正，我也会介绍一些我遇到过的**Flutter的麻烦**之处。  \r\n就像谈恋爱一样，因为优点才会在一起，也因为接受得了缺点才能使情感继续保持。\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/001.png)\r\n\r\n\r\n话不多说，接下来就由我来为诸位展示Flutter所具备的这些的特性吧。\r\n<!--more--> \r\n\r\n\r\n# Flutter的特性\r\n\r\n在我看来，Flutter的特性主要分为两类，分别是**高效性**与**舒适性**，这两者都会是你在进行Flutter开发时最直观的感受，而下面的这些特性从侧面也会展示出这部分效果\r\n\r\n\r\n### 一、热重载\r\n\r\n热重载大家应该都耳熟能详了，和前端开发一样，对代码进行修改后，可以即时看到效果，这点相比于原生开发每次做了一点修改就要从头到尾编译一次不知道高到哪里去了！\r\n\r\n下面是一点简单的演示效果：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/002.gif)\r\n\r\n可以看到，热重载带来的体验提升是巨大的！作为一名原生开发者，你心动了吗？\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/003.gif)\r\n\r\n不过关于热重载还有一些需要说明的地方，在用到可以保存状态的控件时，热重载不能将状态重置，比如说一个动画控件，在动画结束后再进行热重载是无法再次播放动画的（除非你对动画做了循环处理），所以有的时候你看着觉得热重载没效果，这时候就要考虑是不是用到了 **StatefulWidget** 之类的控件。\r\n\r\nFlutter将热重载作为一个亮点，不过由于Flutter的布局是用代码去写的，和Android中的xml不同，它无法进行实时预览，所以你无法想象没有热重载的话，要怎么面对Flutter进行编程，这么看来热重载既是亮点，也是要点。\r\n\r\n### 二、万物基于Widget\r\n\r\nFlutter中的页面都是由一个个的Widget组合而成，甚至连页面本身也是一个Widget，Widget与android中的组件类似，不过前者具有更好的组合性。  \r\n同时Flutter已经封装了许多简单好用的Widget，使用起来非常方便。\r\n\r\n比如在android中你想创建下面这样一个圆，你需要重新写一个xml，并在xml定义各种属性：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/004.png)\r\n\r\n而在Flutter中实现是非常容易的：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/005.png)\r\n\r\n不管是圆形，还是圆角矩形，又或者是不对称圆角矩形，Flutter都提供了很方便的实现方法。\r\n\r\n关于Widget可以看到代码的结构是一层一层的，对于初次接触的人来说想必是很难接受这种代码格式。因为我当初看到Flutter这样的代码时，还产生过劝退的想法，不过写了一段时间后还是觉得蛮带感的。打个比方的话就像初见JoJo和再见JoJo的感觉。\r\n\r\n在android中视图在xml中，代码则由java负责，在习惯了flutter后，我觉得用代码直接去创建视图也未尝不是一种好的解决方法，毕竟xml+java也算历史悠久了。而我也接触过一个前端框架——Vue，flutter的这种结构和vue的就非常类似。\r\n\r\n孰好孰坏因人而异，想必等你使用过一段时间后的flutter后心中会有着一个自己的答案。\r\n\r\n\r\n### 三、跨平台\r\n\r\n跨平台其实是flutter最突出的一个特点了，与其他如React、Week这类跨平台框架不同，Flutter作为后起之秀能脱颖而出与其性能表现和稳点程度是有很大关系的。\r\n\r\n在Flutter Live 2018上，官方已经放出了好几个纯Flutter的应用，并演示了他们在android和ios上的运行效果，其中最为惊艳的就是 **《The History Of Everything》** 了，下面给大家简单的展示一下真机运行效果：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/007.gif)\r\n\r\n想自行体验的话可以去Google Play或者App Store中下载\r\n\r\n上面应用中的动画大部分由 **Flare** 实现，具体可以参见 [2dimensions(需科学上网)](https://www.2dimensions.com/)，这样可以跑满60帧的矢量动画也只是Flutter性能展现的一面，在跨平台上，其最大的特点就是**接近原生效果**。\r\n\r\n不过目前而言，flutter在跨平台上有一些问题还是需要完善的。比如视频的播放  \r\n具体原因可以看这篇文章：[万万没想到——flutter这样外接纹理](https://www.yuque.com/xytech/flutter/pfpo68)\r\n\r\n还有那些需要用到第三方sdk的时候，可能就需要做双端的channel通信了，但是也有比较积极的团队专门做了flutter的sdk，**声网**就是其中之一\r\n\r\n### 四、年轻\r\n\r\n年轻是flutter的一大优势，同时也是一大劣势。\r\n\r\n就像上面说的，许多第三方sdk还没有开始为flutter做适配，所以flutter的开发生态自然比不了其他技术框架和平台，然而因其发展的势头非常迅猛，所以这其实也是一个机会。大量的开发者可以在这个领域再做建树，未来会是何种状况还是非常令人期待的。\r\n\r\n如同 **Kotlin** 一样，现阶段如果去看国外的一些技术博客，如 **Medium** 里关于 Android 的，大部分语言都已经是kotlin的了，只是国内的博客可能普及度还没有那么高。但是良禽择木而栖，趋势一直都在，怎么选择就看个人了。\r\n\r\n也正是因为flutter比较年轻，所以有些东西还没有一个既定的公认的解决方案。就比如flutter开发过程中都会遇到的 **状态管理**。\r\n\r\n目前flutter中的状态管理框架有许多，最知名的比如从前端引鉴过来的 **Redux**，同时还有 **Bloc**， **Provide** 等。每个状态管理框架解决的范围都不一样，学习成本也各有差异，如何选择还是需要看项目需求与个人喜好。  \r\n具体选择可以看这篇文章：[（译）让我来帮你理解和选择Flutter状态管理方案](https://juejin.im/post/5bac54c45188255c681589d3)\r\n\r\n\r\n### 五、Dart语言\r\n\r\nflutter的开发语言使用的是dart，对于刚接触kotlin的同学来说，再去使用dart想必是一件很苦恼的事情。\r\n\r\n比如kotlin中用 **var表示变量(variable)**，**val表示常量(value)**，而到了dart中虽然可以用var表示变量，但是常量还是只能用final或者const去修饰。\r\n\r\n从很多方面看来kotlin都算是算是采各家所长集于一身，而dart则像是修行还没结束就半路出山了。\r\n\r\n不过因为对比对象是kotlin，所以dart显得不那么出色，其实dart还是有很多好用的点的。\r\n\r\n比如\r\n#### 调用前做对象判空：\r\n\r\n```\r\n//kotlin\r\na?.m()\r\n//dart\r\na?.m()\r\n\r\n```\r\n不同之处在于kotlin如果对象为空则不做处理,同时要求你做对象为空时的赋值，dart如果对象为空则返回null,\r\n\r\n#### 对象为空时赋值\r\n\r\n```\r\n//kotlin\r\nvar x = a?.b ?: c\r\n//dart\r\nvar x = a?.b ?? c\r\n```\r\n两者区别不大.不过dart中还可以使用 ??= 代替?? ,区别是前者可以单独作为赋值语句\r\n\r\ndart虽然在使用上不及kotlin那么舒适，但dart也一直在更新换代，优秀的语言发展到最后一定是有很多共同性的，所以不要过于纠结于语言的选择上，因为它终究只是一种工具。\r\n\r\n# 结束闲聊\r\n\r\n从去年12月flutter发布1.0 release版本到今天，flutter已经迭代了好多个版本了\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/008.png)\r\n\r\n而我在使用过程中确实遇到过一些问题，或简单或麻烦，但大部分都有了解决方案。从稳定性上来讲，使用flutter的交互其实就是对数据进行操作，而正是因为这样，做到了视图与数据分离，所以出bug的情况要少得多。\r\n\r\n为什么我要介绍flutter甚至是鼓励各位原生开发者们去学flutter，主要原因有两个：\r\n- 一、学习flutter的成本很低，因为它难度不大\r\n- 二、从flutter的性能表现上来看，它是可以代替原生应用的，只是现在火候不够\r\n\r\n所以对于现阶段的初中级原生开发者而言，我建议你一定要抽出时间去了解了解flutter，因为大部分你能通过原生去实现的东西，用flutter一样也是可以的，并且还更加轻松，还可以跨平台。\r\n\r\n写到这里，文章中也很少涉及到技术上的东西，主要还是以介绍为主\r\n\r\n下面再介绍一点点我非常推荐的学习flutter的途径吧：\r\n\r\n\r\n\r\n1、 **首先自然是Youtube上flutter官方的视频项目(科学上网)：\r\n[Flutter](https://www.youtube.com/channel/UCwXdFgeE9KYzlDdR7TG9cMw)**\r\n\r\n这里面有个超赞的系列，就是每周一更的 **Flutter Widget of the Week**\r\n\r\n\r\n2、**然后你也可以关注B站的** **[Google中国账号](https://space.bilibili.com/64169458/)**\r\n\r\n其中的视频都有中文翻译，可以找到关于flutter的学习视频，不过和youtube上相比更新要慢很多\r\n\r\n3、**[《Flutter实战》](https://book.flutterchina.club/)**\r\n\r\n万分感谢这位作者开源这本技术书！\r\n\r\n\r\n剩下的学习途径还有许多，不过学习也是发散的，知道上面三个后，其他的途径于你也不在话下了。\r\n\r\n\r\n最后再介绍一个学习途径\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/apk/apk.png)\r\n\r\n没错，就是我用flutter写的一个小项目\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/009.jpg)\r\n\r\n"}